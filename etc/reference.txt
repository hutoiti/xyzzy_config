Converted by xy-reference.l at 07/12/25 01:20:39
======================================================================
■*
[       type]: Function
[  arguments]: * &rest NUMBERS
[    package]: lisp
[    seealso]: /
[       file]: builtin.l
[    section]: 数値
[description]: 
引数を全て乗算した数値を返します。

使用例：  
  (* 1 2 3)
  => 6


■*activate-hook*
[       type]: Variable
[    package]: editor
[    seealso]: verify-buffers-file-modtime , *deactivate-hook*
[    section]: 変数と定数
[description]: 
バッファがactivateされたときに任意の処理を行うために使用されます。
デフォルトではファイルの修正日付を確認しています。


■*after-save-buffer-hook*
[       type]: Variable
[    package]: editor
[    seealso]: save-buffer
[    section]: 変数と定数
[description]: 
多分 save-buffer の最後に実行されます。


■*apropos-no-regexp*
[       type]: Variable
[    package]: editor
[    seealso]: apropos
[       file]: help.l
[    section]: シンボル
[description]: 
non-nil に設定すると、apropos 実行時に、正規表現のメタ文字はエスケープさ
れます。デフォルトは nil です。


■*auto-encoding-alist*
[       type]: Variable
[    package]: editor
[    seealso]: *find-file-no-auto-encoding* , find-file
[       file]: files.l
[    section]: ファイルシステム
[description]: 
エンコーディング判定用の連想リストです。(key . datum) の組で登録します。
find-file または find-file-read-only の際に ENCODING が指定されず、
*find-file-no-auto-encoding* が nil の時、
(string-matchp key filename) が non-nil となった場合、datum をfuncallします。
datum にはエンコーディングもしくはエンコーディングを表す文字列を返す関数を指定します。


■*auto-fill-hook
[       type]: Variable
[    package]: editor
[    seealso]: auto-fill-mode , auto-fill-hook , self-insert-command , funcall
[       file]: cmds.l
[    section]: 変数と定数
[description]: 
auto-fill-mode の時に、self-insert-command から *last-command-char*
を引数として実行されます。普通は do-auto-fill が設定されています。
多分修正しない方が良いと思います。
※ run-hooks ではなく、 funcall されるので注意すること


■*auto-mode-alist*
[       type]: Variable
[    package]: editor
[    seealso]: *find-file-auto-mode-function* , *auto-mode-parameter-alist*
[       file]: defs.l
[    section]: モード
[description]: 
モード判定用の連想リストです。(key . datum)の組で登録します。
(string-matchp key filename)がnon-nilになった場合に、
datumをfuncallします。

datumにdecode-auto-modeのプロパティが存在する場合には、バッファを
第一引数にしてdatumをfuncallします。
cc-mode.lのdecode-c-modeを参照

使用例：
  (pushnew '("\\.asp" . basic-mode) *auto-mode-alist* :test 'equal)


■*auto-mode-parameter-alist*
[       type]: Variable
[    package]: editor
[    seealso]: *find-file-auto-mode-function* , *auto-mode-alist* , *buffer-package* , find-file
[       file]: files.l
[    section]: モード
[description]: 
ファイルの先頭のパラメータに対し、実行する関数を指定する alist です。
書式は (文字列 . 関数) となっています。

ファイルの先頭にパラメータ -*- aaa: bbb -*- がある場合、
"aaa" に string-equal な文字列が *auto-mode-parameter-alist* に登録されていれば、
対応する関数を "bbb" を引数にして funcall します。

デフォルト値は
  '(("mode" . find-file-auto-mode)
    ("package" . find-file-buffer-package))
です。


■*auto-update-per-device-directory*
[       type]: Variable
[    package]: lisp
[    seealso]: set-per-device-directory
[    section]: ファイルシステム
[description]: 
ファイラで移動したときにドライブ毎のデフォルトのディレクトリについて制御します。

  t   移動するたびに更新する
  nil set-perdevice-directoryで指定したディレクトリに固定する


■*before-delete-buffer-hook*
[       type]: Variable
[    package]: editor
[    seealso]: delete-buffer , *delete-buffer-hook*
[    section]: 変数と定数
[description]: 
delete-bufferを継続するかどうかを制御します。登録された関数が一
つでもnilを返すとdelete-bufferを中止します。

参考：
  ;;; 呼び出し方
  (run-hook-with-args-until-success
       '*before-delete-buffer-hook* (selected-buffer))

使用例：
  (add-hook '*before-delete-buffer-hook* 'func)
  =>(func)
  (defun func (x) (yes-or-no-p "delete-buffer ~A ?" (buffer-name x)))
  =>func


■*before-find-file-hook*
[       type]: Variable
[    package]: editor
[    seealso]: find-file
[   referred]: ed::find-file-internal
[       file]: files.l
[    section]: 変数と定数
[description]: 
find-fileの最初で実行されます。
※run-hook-with-args-until-successで実行されるので注意すること


■*before-save-buffer-hook*
[       type]: Variable
[    package]: editor
[    seealso]: save-buffer , run-hook-with-args-until-success
[    section]: 変数と定数
[description]: 
多分 save-buffer の最初に実行されます。
※ run-hook-with-args-until-success で実行されるので注意すること


■*brackets-is-wildcard-character*
[       type]: Variable
[    package]: lisp
[    seealso]: wild-pathname-p , pathname-match-p
[    section]: 変数と定数
[description]: 
non-nil ならばファイルパスとして渡した文字列中の [...] をワイルドーカー
ドとして扱います。
[共通設定] - [さまざま] - [[...]はワイルドカード(I)] で値を指定すること
ができます。
xyzzy ソース内で定義されており、デフォルト値は t です。
具体的には、wild-pathname-p, pathname-match-p 関数での判定の際に
*brackets-is-wildcard-character* の値が考慮されます。


■*buffer-bar-context-menu*
[       type]: Variable
[    package]: editor
[   referred]: *buffer-bar-context-menu-handler*
[       file]: buffer.l
[    section]: バッファ
[description]: 
バッファ・バー上で右クリックしたときに出てくるコンテキストメニューです。
define-popup-menu で作成されています。（作成は app-menu.l）


■*buffer-bar-context-menu-buffer*
[       type]: Variable
[    package]: editor
[       file]: buffer.l
[    section]: バッファ
[description]: 
バッファバー上で選択されているバッファです。ただし、バッファバー上の
コンテキストメニューで取得専用くらいしか使用できません。


■*buffer-bar-context-menu-handler*
[       type]: Variable
[    package]: editor
[    seealso]: *buffer-bar-context-menu*
[       file]: buffer.l
[    section]: バッファ
[description]: 
デフォルトのバッファバー用コンテキストメニューハンドラです。
setq-default によって定義されている標準の動作は、 
*buffer-bar-context-menu-buffer* を定義し、*buffer-bar-context-menu* を
返します。


■*buffer-bar-selected-buffer-to-first*
[       type]: Variable
[    package]: editor
[    section]: バッファ
[description]: 
non-nil なら、選択されたバッファがバッファバー上で一番先頭になります。
キーでタブを移動した場合は移動されません。デフォルトは nil です。
(setq *buffer-bar-selected-buffer-to-first* t) とやって、バッファバーを
クリックすれば分かると思います。


■*buffer-info-variable-list*
[       type]: Variable
[    package]: editor
[    seealso]: save-session
[       file]: session.l
[    section]: バッファ
[description]: 
セッションファイルに保存しておくバッファローカル変数のリストです。

このリストに含まれる変数のバッファごとの値はセッションファイルに保存さ
れ、ロードした際に復元されます。(正確には、バッファローカルになってい
る場合だけそのバッファの情報として保存されます)


■*buffer-menu-mode-hook*
[       type]: Variable
[    package]: editor
[       file]: buf-menu.l
[    section]: メニュー
[description]: 
buffer-menuの起動時に実行されます。

参考：
  (run-hooks '*buffer-menu-mode-hook*)


■*buffer-package*
[       type]: BufferLocal
[    package]: editor
[    seealso]: *auto-mode-parameter-alist*
[       file]: lispmode.l
[    section]: バッファ
[description]: 
ファイルの先頭のパラメータリストの Package で指定したパッケージ名が保
存されます。


■*change-buffer-colors-hook*
[       type]: Variable
[    package]: editor
[    section]: 変数と定数
[description]: 
途中


■*char-encoding-list*
[       type]: Variable
[    package]: editor
[   referred]: read-char-encoding , set-buffer-fileio-encoding
[       file]: encoding.l
[    section]: テキスト
[description]: 
文字エンコーディングのリストです。ミニバッファからの入力補完候補のリスト
や file-name-dialog のエンコーディングのリストとして使われたりするみたい
です。
文字エンコーディングはクオートしてはいけないみたいですので、定義しなおす
時は注意してください。


■*command-line-mailto-hook*
[       type]: Variable
[    package]: editor
[    seealso]: 起動時処理フロー
[       file]: estartup.l
[    section]: 変数と定数
[description]: 
コマンドラインで指定された -mailto オプションの引数を元に実行されます。 
※run-hooksではなくfuncallされるので注意すること


■*command-output-mode-hook*
[       type]: Variable
[    package]: editor
[       file]: process.l
[    section]: モード
[description]: 
execute-subprocessの中でcommand-output-mode起動時に実行されます。


■*create-buffer-hook*
[       type]: Variable
[    package]: editor
[    seealso]: *default-buffer-mode* , create-new-buffer
[    section]: 変数と定数
[description]: 
多分create-new-bufferで実行されます。


■*dabbrev-search-this-buffer-only*
[       type]: Variable
[    package]: editor
[    seealso]: dabbrev-expand
[       file]: dabbrev.l
[    section]: テキスト
[description]: 
dabbrev-expandの検索対象を設定します。

  t   カレントバッファのみを検索します
  nil 全バッファを検索します


■*dabbrevs-no-undo*
[       type]: Variable
[    package]: editor
[    seealso]: undo , dabbrev-expand
[       file]: defs.l
[    section]: バッファ
[description]: 
dabbrev-expand時のundoの方法を設定します。
dabbrev-expandを行なった際に候補が順次挿入されますが...
  non-nil  dabbrev-expandの直前まで一気に取り消す
  nil      途中の挿入過程を順番に取り消す


■*deactivate-hook*
[       type]: Variable
[    package]: editor
[    seealso]: *activate-hook*
[    section]: 変数と定数
[description]: 
バッファがdeactivateされたときに任意の処理を行うために使用されま
す。デフォルトではクリップボードの同期を行っています。


■*default-buffer-mode*
[       type]: Variable
[    package]: editor
[   referred]: *create-buffer-hook*
[       file]: defs.l
[    section]: バッファ
[description]: 
新しくバッファを作成した場合のモードを指定します。
例えば、lisp-modeを指定しておけば、新しく作成したバッファは全てlisp-mode
になります。

使用例：  
  (setq *default-buffer-mode* 'lisp-mode)
  => lisp-mode
  (switch-to-buffer "*new*")
  => #<buffer: *new*>
  buffer-mode
  => lisp-mode


■*default-eol-code*
[       type]: Variable
[    package]: editor
[    seealso]: buffer-eol-code , *default-fileio-encoding*
[    section]: バッファ
[description]: 
新規に作ったバッファの改行コードのデフォルト値です。


■*default-fileio-encoding*
[       type]: Variable
[    package]: editor
[    seealso]: buffer-fileio-encoding , *default-eol-code*
[    section]: バッファ
[description]: 
新規に作ったバッファの文字エンコーディングのデフォルト値です。


■*default-load-path*
[       type]: Variable
[    package]: editor
[    seealso]: *load-path*
[       file]: misc.l
[    section]: 変数と定数
[description]: 
siteinit.lから*load-path*を修正するために用いられます。
siteinit.lの直後に*default-load-path*の内容が、*load-path*にマー
ジされ、*pre-startup-hook*から有効になります。
追加するパスはリストで設定します。

使用例：
  (setq *default-load-path* '("C:/APPLICATIONS/XYZZY/lib"))


■*default-session-directory*
[       type]: Variable
[    package]: editor
[    seealso]: load-session , save-session , ed::session-directory
[       file]: session.l
[    section]: バッファ
[description]: 
セッションファイルの保存・ロードの際にファイル名を読むときにデフォルト
で表示されるディレクトリです。


■*default-write-file-directory*
[       type]: Variable
[    package]: editor
[    seealso]: emacs-write-file , write-file
[       file]: files.l
[    section]: ファイルシステム
[description]: 
write-file および emacs-write-file 時のデフォルトのディレクトリを指定します。


■*delete-buffer-hook*
[       type]: Variable
[    package]: editor
[    seealso]: delete-buffer , *before-delete-buffer-hook*
[    section]: 変数と定数
[description]: 
delete-bufferで実行されます。


■*diff-mode-hook*
[       type]: Variable
[    package]: editor
[       file]: diff.l
[    section]: モード
[description]: 
diff起動時に実行されます。


■*do-completion
[       type]: Function
[  arguments]: *do-completion STRING TYPE &optional WORDP LIST
[    package]: editor
[       file]: builtin.l
[    section]: テキスト
[description]: 
指定した文字列を条件に従い補完します。

  STRING : 補完したい文字列
  TYPE   : 補完する型
        :symbol-name
        :function-name
        :command-name
        :variable-name
        :non-trivial-symbol-name
        :exist-file-name
        :file-name
        :file-name-list
        :directory-name
        :buffer-name
        :exist-buffer-name
        :list
        :list-ignore-case
  WORD   : nilでなければ単語ごとの補完
  LIST   : TYPE が :list か :list-ignore-case の場合の補完リスト

戻り値は以下のとおりです。

  多値で3つの値が戻ってきますので、multiple-value-bind で受け取るといい
  でしょう。complete.lの中にある do-completion-internal を参考にしてくだ
  さい。以下は場合分けをしています。

        [1] 補完の候補が存在しない場合     :no-completions と nil
        [2] マッチする候補がなかった場合   :no-match と nil
        [3] 与えられた文字列がすでに候補の
            いずれかと一致していて
            補完する必要がない場合
            [3.1] 一致した候補が一つだけ   :solo-match と list と prefix
            [3.2] 複数と一致した場合       :not-unique と list と prefix
        [4] 補完した場合                   補完した結果の文字列と list と prefix

  list は、一致した候補のリスト。
  prefix は、例えばファイル名の補完のときのディレクトリ名とか、
  シンボルの補完のときのパッケージ修飾部分とか。


■*drag-and-drop-hook*
[       type]: Variable
[    package]: editor
[       file]: mouse.l
[    section]: 変数と定数
[description]: 
D&D時に実行されます。デフォルトでは、D&D先がミニバッファ
ならミニバッファへの入力として扱い、それ以外ならfind-fileする
ようになっています。

※run-hooksではなくfuncallされます。引数は2つで、ドロップされたウィンド
  ウとドロップしたファイルのリストです。


■*enter-minibuffer-hook*
[       type]: Variable
[    package]: editor
[    section]: ミニバッファ
[description]: 
ミニバッファに入ったときに実行されます。(interactive...)で指定さ
れた引数が渡されます。


■*eol-cr*
[       type]: Variable
[    package]: editor
[    seealso]: *eol-lf* , *eol-crlf* , set-buffer-eol-code
[       file]: encoding.l
[    section]: 入出力
[description]: 
改行コードのCRを表す値です。
プロセスやバッファの入出力の改行コードを設定するのに使用します。


■*eol-crlf*
[       type]: Variable
[    package]: editor
[    seealso]: *eol-cr* , *eol-lf* , set-buffer-eol-code
[       file]: encoding.l
[    section]: 入出力
[description]: 
改行コードのCRLFを表す値です。
プロセスやバッファの入出力の改行コードを設定するのに使用します。


■*eol-lf*
[       type]: Variable
[    package]: editor
[    seealso]: *eol-cr* , *eol-crlf* , set-buffer-eol-code
[       file]: encoding.l
[    section]: 入出力
[description]: 
改行コードのLFを表す値です。
プロセスやバッファの入出力の改行コードを設定するのに使用します。


■*error-regexp-list*
[       type]: Variable
[    package]: editor
[    seealso]: next-error , first-error
[       file]: errors.l
[    section]: エラー
[description]: 
first-error/next-errorで使用するエラー発生位置の表記形式を変更することが可能です。
*error-regexp-list*の形式は以下のとおりです。

  ((正規表現1 ファイル名のマッチ位置1 行のマッチ位置1)
   (正規表現2 ファイル名のマッチ位置2 行のマッチ位置2)
    ...
   (正規表現N ファイル名のマッチ位置N 行のマッチ位置N))

[xyzzy:05447]で亀井さんが示しているとおり、pushを使って追加するのが無難です。
(push (list (compile-regexp "^\"\\([^\"\n]+\\)\", line \\([0-9]+\\):") 1 2)
      *error-regexp-list*)


■*etc-path*
[       type]: Variable
[    package]: editor
[    seealso]: etc-path
[   referred]: *keyword-load-path*
[       file]: misc.l
[    section]: 変数と定数
[description]: 
キーワードファイル等を格納するパスが設定されています。
標準では(merge-pathnames "etc" (si:system-root))が設定されています。

参照例：
  *etc-path*
  => "C:/APPLICATIONS/XYZZY/etc"


■*executing-macro*
[       type]: Variable
[    package]: editor
[       file]: cmds.l
[    section]: マクロ
[description]: 
マクロを実行中か否かを返します。
  t    マクロを実行中
  nil  マクロを実行中ではない


■*exit-minibuffer-hook*
[       type]: Variable
[    package]: editor
[    section]: ミニバッファ
[description]: 
ミニバッファから出たときに実行されます。


■*features*
[       type]: Variable
[    package]: lisp
[    seealso]: featurep
[    section]: システム
[description]: 
実装の特徴を表すキーワードをリストとして格納しています。
#+ と #- の評価に影響します。

使用例：
  (+ 2 #+xyzzy 3 #+foo 4)
  => 5
  (push :foo *features*)
  => (:foo :windows-me :windows-98 :xyzzy :ieee-floating-point)
  (+ 2 #+xyzzy 3 #+foo 4)
  => 9
  (pop *features*)
  => :foo
  (+ 2 #+xyzzy 3 #+foo 4)
  => 5


■*filer-chdir-hook*
[       type]: Variable
[    package]: editor
[    section]: ファイラ
[description]: 
（ファイラでディレクトリが変更されたりすると実行されます。用途不明） 


■*filer-chdir-primary-p*
[       type]: Variable
[    package]: editor
[    section]: ファイラ
[description]: 
（詳細不明）


■*filer-click-toggle-marks-always*
[       type]: Variable
[    package]: editor
[    section]: ファイラ
[description]: 
nilなら、ファイラで左クリックしたとき、その位置にカーソルがある場合の
みマークを反転します。
non-nil なら、カーソルの移動とマークの反転の両方を同時に行います。
デフォルトは t です。


■*filer-directories*
[       type]: Variable
[    package]: editor
[    seealso]: filer
[       file]: filer.l
[    section]: ファイラ
[description]: 
ファイラのジャンプ用のディレクトリを連想リストで設定します。

使用例：
  (setq *filer-directories*
      '((" [デスクトップ]" . "c:/windows/デスクトップ")
        (" [スプール]" . "c:/spool")))


■*filer-drag-and-drop-helper
[       type]: Function
[  arguments]: *filer-drag-and-drop-helper EFFECT FILES SRC DEST
[    package]: editor
[       file]: filer.l
[    section]: ファイラ
[description]: 
（詳細不明）


■*filer-dual-window*
[       type]: Variable
[    package]: editor
[    section]: ファイラ
[description]: 
ミニバッファなどでディレクトリを入力した時に立ち上がるファイラを選択し
ます。 nil なら一画面ファイラ、non-nil なら二画面ファイラが起動します。
デフォルトは nil です。


■*filer-eat-esc*
[       type]: Variable
[    package]: editor
[    section]: ファイラ
[description]: 
nilなら、モードレスファイラでESCを押しても閉じません。
デフォルトは t です。


■*filer-echo-filename*
[       type]: Variable
[    package]: editor
[    seealso]: filer
[    section]: ファイラ
[description]: 
（途中）
ファイラのステータスウィンドウへのファイル名の表示を制御します。
ファイル名の表示は暇なときに行なっているようです。
  non-nil  暇なときに表示する
  nil      表示しない


■*filer-format-comma*
[       type]: Variable
[    package]: editor
[    section]: ファイラ
[description]: 
non-nilなら、ファイルサイズをカンマ区切りで表示します。
[共通設定] - [ファイラ] - [ファイルサイズをカンマ区切りで表示(C)] で値を
指定することができます。


■*filer-guide-text*
[       type]: Variable
[    package]: editor
[    seealso]: filer
[    section]: ファイラ
[description]: 
ファイラ下部に表示されるガイドテキストを設定します。

使用例：
  (setq *filer-guide-text*
      '("(A)ttribute  (B)yteCompile  (C)opy  (D)elete  (E)xtract  (F)ind"
        "(G)o  (J)ump  m(K)dir  <L>Cd  (M)ove  re(N)ame"))


■*filer-last-command-char*
[       type]: Variable
[    package]: editor
[    section]: ファイラ
[description]: 
ファイラにてコマンドを実行した時に最後に入力された文字を示します。


■*filer-last-file-mask*
[       type]: Variable
[    package]: editor
[    seealso]: *filer-primary-file-mask* , *filer-secondary-file-mask*
[    section]: ファイラ
[description]: 
一画面ファイラの初期のファイルマスクをリストで設定します。


■*filer-left-window-p*
[       type]: Variable
[    package]: editor
[    section]: ファイラ
[description]: 
二画面ファイラを閉じたとき、どちらのウィンドウがアクティブだったかが保存
されます。ファイラ未起動時の値は t です。

  nil     : 右側のウィンドウ
  non-nil : 左側のウィンドウ


■*filer-mark-file-size-unit*
[       type]: Variable
[    package]: editor
[    seealso]: filer
[    section]: ファイラ
[description]: 
ファイラのマークファイルの合計サイズの単位を指定します。
#\B, #\K, #\M, #\G, #\Tの何れかを指定可能です。ただし、例えば#\K
が設定されたとき、サイズが1K未満ならバイト単位になります。デフォ
ルトではnilに設定されています。

使用例：
  (setq *filer-mark-file-size-unit* #\M)


■*filer-modal*
[       type]: Variable
[    package]: editor
[    seealso]: filer
[       file]: filer.l
[    section]: ファイラ
[description]: 
ファイラの動作を指定します。

モーダルの場合には、ファイラはエディタとは同期的に動作します。
ファイラ起動中はエディタでの編集は不能です。
モードレスの場合には、ファイラはエディタとは非同期に動作します。
ファイラ起動中にエディタでの編集が可能です。

  t   モーダルで動作させます
  nil モードレスで動作させます


■*filer-path-masks*
[       type]: Variable
[    package]: editor
[    seealso]: filer
[       file]: filer.l
[    section]: ファイラ
[description]: 
ファイラのファイルマスクを設定します。

使用例：
  (pushnew '("Microsoft" "*.doc" "*.xls" "*.ppt" "*.sys" "*.bat" "*.ini")
           *filer-path-masks* :test 'equal)


■*filer-primary-directory*
[       type]: Variable
[    package]: editor
[    seealso]: *filer-secondary-directory*
[   referred]: filer
[    section]: ファイラ
[description]: 
二画面ファイラのアクティブな方のディレクトリを示します。
右側か左側かは *filer-left-window-p* の値によって決まります。
ファイラ未起動時は左側のディレクトリを指定できます。

使用例：
  ; [xyzzy:07218]
  ; 常にカレントディレクトリからファイラを起動する。
  (defun foo ()
    (interactive)
    (let ((*filer-primary-directory* nil)
          (*filer-secondary-directory* nil))
      (open-filer)))


■*filer-primary-file-mask*
[       type]: Variable
[    package]: editor
[    seealso]: filer , *filer-secondary-file-mask*
[   referred]: *filer-last-file-mask*
[    section]: ファイラ
[description]: 
ファイラ左側の初期のファイルマスクをリストで設定します。

使用例：
  (setq *filer-primary-file-mask* '("*"))


■*filer-retrieve-icon*
[       type]: Variable
[    package]: editor
[       file]: filer.l
[    section]: ファイラ
[description]: 
non-nil のとき、ファイラでファイルタイプに応じたアイコンを表示します。
[共通設定] - [ファイラ] - [アイコンをファイルから取ってくる(I)] で値を指
定することができます。


■*filer-secondary-directory*
[       type]: Variable
[    package]: editor
[    seealso]: *filer-primary-directory*
[   referred]: filer
[    section]: ファイラ
[description]: 
二画面ファイラのアクティブでない方のディレクトリを示します。
右側か左側かは *filer-left-window-p* の値によって決まります。
ファイラ未起動時は右側のディレクトリを指定できます。


■*filer-secondary-file-mask*
[       type]: Variable
[    package]: editor
[    seealso]: *filer-primary-file-mask* , filer
[   referred]: *filer-last-file-mask*
[    section]: ファイラ
[description]: 
ファイラ右側の初期のファイルマスクをリストで設定します。

使用例：
  (setq *filer-secondary-file-mask* '("*"))


■*filer-use-recycle-bin*
[       type]: Variable
[    package]: editor
[    seealso]: filer
[       file]: filer.l
[    section]: ファイラ
[description]: 
ファイラでファイルの削除にゴミ箱を使用するかを設定します。
  non-nil  ファイラで削除したときはゴミ箱行き
  nil      直接削除


■*find-file-auto-mode-function*
[       type]: Variable
[    package]: editor
[    seealso]: *auto-mode-parameter-alist* , *auto-mode-alist* , find-file
[   referred]: ed::find-file-internal
[       file]: files.l
[    section]: モード
[description]: 
find-file の際にモードを設定するための関数を登録します。

ファイルの先頭のパラメータ（-*- Mode: LISP -*- など）や 
*auto-mode-alist* よりも優先されます。


■*find-file-file-not-found-hook*
[       type]: Variable
[    package]: editor
[    seealso]: find-file , run-hook-with-args-until-success
[   referred]: ed::find-file-internal
[       file]: files.l
[    section]: 変数と定数
[description]: 
find-file で指定されたファイルが存在しないときに実行されます。
※run-hook-with-args-until-successで実行されるので注意すること


■*find-file-hooks*
[       type]: Variable
[    package]: editor
[    seealso]: *find-file-read-only-hook* , find-file-read-only , find-file
[   referred]: ed::find-file-internal
[       file]: files.l
[    section]: ファイルシステム
[description]: 
find-file および find-file-read-only で新しいファイルを開くたびに、最後に実行されます。
すでにファイルを開いているバッファが存在した場合には実行されません。


■*find-file-no-auto-encoding*
[       type]: Variable
[    package]: editor
[    seealso]: *auto-encoding-alist* , find-file
[       file]: files.l
[    section]: ファイルシステム
[description]: 
non-nil なら、*auto-encoding-alist* によるエンコーディングの判定が行われず、
ファイルの先頭にエンコーディング情報(-*- Encoding: EUC-JP -*-など)が記述され
ていても無視されます。


■*find-file-read-only-hook*
[       type]: Variable
[    package]: editor
[    seealso]: *find-file-hooks* , find-file-read-only
[       file]: files.l
[    section]: ファイルシステム
[description]: 
find-file-read-only でファイルごとに最後に実行されます。
*find-file-hooks* と異なり、すでにファイルが開かれていた場合にも実行されます。


■*find-other-file-requires-file-name*
[       type]: Variable
[    package]: editor
[    seealso]: find-other-file
[       file]: files.l
[    section]: ファイルシステム
[description]: 
non-nil なら find-other-file のプロンプト時に現在のバッファ名を表示します。


■*full-keymap-length*
[       type]: Variable
[    package]: editor
[    seealso]: make-keymap
[       file]: keymap.l
[    section]: キーマップ
[description]: 
make-keymap で作られるキーマップの長さです。


■*gensym-counter*
[       type]: Variable
[    package]: lisp
[    seealso]: gensym
[       file]: evalmacs.l
[    section]: シンボル
[description]: 
gensym で作られるシンボルの名前につく数字です。
使われるたびにインクリメントされます。


■*global-abbrev-table*
[       type]: Variable
[    package]: editor
[    seealso]: expand-abbrev , *local-abbrev-table* , define-abbrev-table
[       file]: abbrev.l
[    section]: テキスト
[description]: 
グローバルなabbrev-tableを設定します。


■*global-keymap*
[       type]: Variable
[    package]: editor
[    seealso]: global-set-key
[    section]: キーマップ
[description]: 
グローバルなキーマップです。モード毎のキーマップに何も割り当てられてい
ない場合に使われます。

global-set-key はこのキーマップにバインディングをセットします。


■*gmark-keep-column*
[       type]: Variable
[    package]: editor
[       file]: gmark.l
[    section]: ポジション
[description]: 
non-nil なら、global-mark-goto と back-tag-jump の移動の時に行頭へ移動し
ないようになります。


■*grep-directory-name-hook*
[       type]: Variable
[    package]: editor
[    seealso]: *grep-hook*
[       file]: grepd.l
[    section]: 変数と定数
[description]: 
grep-dialogでgrep対象のディレクトリを個々に設定したい場合に実行
されます。
※funcallされるので注意すること


■*grep-hook*
[       type]: Variable
[    package]: editor
[    seealso]: *grepd-hook*
[   referred]: *grep-directory-name-hook*
[       file]: grep.l
[    section]: 変数と定数
[description]: 
grep起動時に実行されます。


■*grepd-hook*
[       type]: Variable
[    package]: editor
[    seealso]: *grep-hook*
[       file]: grepd.l
[    section]: 変数と定数
[description]: 
grep-dialog起動時に実行されます。


■*gresreg-directory-name-hook*
[       type]: Variable
[    package]: editor
[    seealso]: gresreg-dialog
[       file]: gresregd.l
[    section]: 変数と定数
[description]: 
gresreg-dialog で gresreg 対象のディレクトリを個々に設定したい場合
に実行されます。
※funcallで実行されるので注意すること


■*history-file-name*
[       type]: Variable
[    package]: editor
[       file]: history.l
[    section]: 変数と定数
[description]: 
ヒストリを保存するファイル名です。
nil の場合は関数 history-file-name において
適当に決定されます。

例:
  *history-file-name*
  =>"X:/xyzzy/usr/username/wxp/.xyzzy.history"


■*ime-mode-hook*
[       type]: Variable
[    package]: editor
[    seealso]: toggle-ime
[    section]: モード
[description]: 
IMEの切替え時に呼び出されます。


■*inhibit-quit*
[       type]: Variable
[    package]: editor
[    seealso]: quit-char
[    section]: 変数と定数
[description]: 
この値が t のとき、 quit-char を入力しても無視されます。


■*init-app-menus-hook*
[       type]: Variable
[    package]: editor
[    seealso]: 起動時処理フロー
[       file]: app-menu.l
[    section]: メニュー
[description]: 
xyzzy実行後に実行されます。*app-menu*を直接変更する用途で用いら
れます。

使用例：
  (add-hook '*init-app-menus-hook*
            #'(lambda ()
                (add-menu-item *app-menu* 'close-box :close-box
                               #'kill-selected-buffer)))


■*isearch-scanner-hook*
[       type]: Variable
[    package]: editor
[       file]: isearch.l
[    section]: 検索・正規表現
[description]: 
isearch-scannerで実行されます。scan-bufferするパターンを書き換えることが
出来そうです。migemo用？

参考：
  (funcall *isearch-scanner-hook* pattern)


■*kbd-translate-table*
[       type]: Variable
[    package]: editor
[    seealso]: キー表現使用可能文字
[       file]: keyboard.l
[    section]: キーマップ
[description]: 
多分、入力された物理的なキーを論理的なキーに変換するためのものです。
この論理的なキーは、F13〜F24などのように存在しないキーに振り向けることが
出来ます。例えば、キートップのラベルに別の文字のラベルを貼り付けるような
ものだと思います。

  ・物理的なキーから論理的なキーへの変換
  ・ローカルキーマップに論理的なキーの設定があればコマンド実行
  ・グローバルキーマップに論理的なキーの設定があればコマンド実行

使用例：
  ;;; C-[ と ESC を別物にする
  (setf (svref *kbd-translate-table* (char-code #\C-[)) #\F15)
  (global-set-key #\F15 'xxxx)

  ;;; BSとCtrl-hを別物にする
  (setf (svref *kbd-translate-table* (char-code #\C-h)) #\F13)
  (global-set-key #\F13 'replace-dialog)


■*keyboard*
[       type]: Variable
[    package]: editor
[    seealso]: *standard-input*
[    section]: 入出力
[description]: 
キーボードからの入力を表すストリームです。


■*keyword-load-path*
[       type]: Variable
[    package]: editor
[    seealso]: load-keyword-file , *etc-path* , キーワードファイルの書き方
[       file]: kwd.l
[    section]: 変数と定数
[description]: 
キーワードファイルのパスをリストで設定します。
指定されたキーワードファイルがこのリストから見つからない場合には、
etc-pathで取得されるパスを検索します。

使用例：
  (setq *keyword-load-path* '("C:/Program Files/xyzzy/keyword"))


■*kill-buffer-kills-scratch*
[       type]: Variable
[    package]: editor
[    seealso]: kill-buffer
[       file]: lispmode.l
[    section]: 変数と定数
[description]: 
*kill-buffer-kills-scratch*がnon-nilの場合には、kill-bufferで
*scratch*が削除可能です。デフォルトはnilになっています。


■*kill-ring*
[       type]: Variable
[    package]: editor
[    seealso]: *kill-ring-max* , kill-region , yank , *selection-ring*
[   referred]: kill-line
[       file]: region.l
[    section]: リージョン
[description]: 
killした文字列を格納します。
*kill-ring*は長さが*kill-ring-max*であるリングバッファです。


■*kill-ring-max*
[       type]: Variable
[    package]: editor
[   referred]: *kill-ring*
[       file]: region.l
[    section]: リージョン
[description]: 
killで保存する個数です。*kill-ring*の長さです。


■*kill-xyzzy-hook*
[       type]: Variable
[    package]: editor
[    seealso]: kill-xyzzy , *query-kill-xyzzy-hook*
[    section]: 変数と定数
[description]: 
xyzzyの終了時に実行されます。


■*last-command*
[       type]: Variable
[    package]: editor
[    seealso]: *this-command*
[    section]: 変数と定数
[description]: 
最後に実行したコマンドが入っています。直前の *this-command* の値が設定されます。


■*lisp-popup-completion-list*
[       type]: Variable
[    package]: editor
[    seealso]: lisp-complete-symbol , *popup-completion-list-default*
[       file]: lispmode.l
[    section]: 変数と定数
[description]: 
lisp-complete-symbol 時の補完候補をポップアップ表示するかを設定します。 

動作:
  *lisp-popup-completion-list*
    :always   ポップアップ表示
    :never    *Completion*バッファで表示

    *popup-completion-list-default*
      :always ポップアップ表示
      :never  *Completion*バッファで表示

    non-nil   ポップアップ表示
    nil       *Completion*バッファで表示


■*load-history-hook*
[       type]: Variable
[    package]: editor
[    seealso]: 起動時処理フロー
[       file]: history.l
[    section]: 変数と定数
[description]: 
.xyzzy処理後に実行されます。コマンドバー、セッション等のヒストリ変
数の読み込みに使用されています。


■*load-path*
[       type]: Variable
[    package]: lisp
[    seealso]: si:*load-library , load-library , *default-load-path* , find-load-path
[    section]: 変数と定数
[description]: 
ライブラリをロードするパスがリストで設定されています。
直接リストを修正するよりも、siteinit.lで *default-load-path* 
に追加する方が好ましいようです。


■*load-pathname*
[       type]: Variable
[    package]: lisp
[    section]: ファイルシステム
[description]: 
現在読み込み中のファイル名（もしくはストリーム名）が入ります。

load-file内でバインドされます。


■*local-abbrev-table*
[       type]: BufferLocal
[    package]: editor
[    seealso]: expand-abbrev , *global-abbrev-table* , define-abbrev-table
[       file]: abbrev.l
[    section]: テキスト
[description]: 
バッファごとのabbrev-tableを設定します。
ここでの定義は*global-abbrev-table*よりも優先して使用されます。


■*make-backup-filename-hook*
[       type]: Variable
[    package]: editor
[       file]: backup.l
[    section]: 変数と定数
[description]: 
（多分触らないほうがいいと思われます） 


■*menu-display-length*
[       type]: Variable
[    package]: editor
[       file]: app-menu.l
[    section]: 変数と定数
[description]: 
メニューの「最近使ったファイル」で表示されるファイルパスの長さを指定します。
デフォルトでは40です。


■*minibuffer-buffer-name-history*
[       type]: Variable
[    package]: editor
[       file]: minibuf.l
[    section]: 変数と定数
[description]: 
ミニバッファのバッファ名の履歴です。


■*minibuffer-directory-name-history*
[       type]: Variable
[    package]: editor
[       file]: minibuf.l
[    section]: 変数と定数
[description]: 
ミニバッファのディレクトリ名の履歴です。


■*minibuffer-execute-history*
[       type]: Variable
[    package]: editor
[       file]: minibuf.l
[    section]: 変数と定数
[description]: 
（詳細不明）


■*minibuffer-file-name-history*
[       type]: Variable
[    package]: editor
[    seealso]: add-file-history-to-menu
[       file]: minibuf.l
[    section]: 変数と定数
[description]: 
ミニバッファのファイル名の履歴です。


■*minibuffer-lisp-sexp-history*
[       type]: Variable
[    package]: editor
[       file]: minibuf.l
[    section]: 変数と定数
[description]: 
ミニバッファのS式の履歴です。


■*minibuffer-popup-completion-list*
[       type]: Variable
[    package]: editor
[    seealso]: *popup-completion-list-default*
[       file]: minibuf.l
[    section]: ミニバッファ
[description]: 
ミニバッファで補完リストをポップアップ表示するかを設定します。

使用例：
  (setq *popup-completion-list-default* :always)
  (setq *minibuffer-popup-completion-list* :never)

動作：
  *minibuffer-popup-completion-list*
    :always   ポップアップ表示
    :never    *Completion*バッファで表示
  
    *popup-completion-list-default*
      :always ポップアップ表示
      :never  *Completion*バッファで表示
  
    non-nil   ポップアップ表示
    nil       *Completion*バッファで表示


■*minibuffer-save-ime-status*
[       type]: Variable
[    package]: editor
[    section]: ミニバッファ
[description]: 
ミニバッファのIMEの状態を制御します。
  nil  ミニバッファのIMEの状態を保存しません。
  t    ミニバッファのIMEの状態を保存します。


■*minibuffer-search-string-history*
[       type]: Variable
[    package]: editor
[       file]: minibuf.l
[    section]: 変数と定数
[description]: 
ミニバッファの検索文字の履歴です。


■*minibuffer-symbol-name-history*
[       type]: Variable
[    package]: editor
[       file]: minibuf.l
[    section]: 変数と定数
[description]: 
ミニバッファのシンボル名の履歴です。


■*minor-mode-alist*
[       type]: Variable
[    package]: editor
[    section]: モード
[description]: 
マイナモードがオンのときにモードラインに表示する文字列の連想リストです。
各要素の car はシンボル、 cdr は文字列かシンボルです。

car に指定したシンボルの値が non-nil であって、 cdr が文字列かまたは値が
文字列であるようなシンボルならば、その文字列がモードラインに表示されます。

使用例：
  (pushnew '(edict-mode . "Edict") *minor-mode-alist* :key #'car)

  (pushnew '(async-grep-mode . async-grep-status)
           *minor-mode-alist* :key #'car)


■*modal-filer-save-position*
[       type]: Variable
[    package]: editor
[    seealso]: *modal-filer-save-size*
[    section]: ファイラ
[description]: 
モーダルでファイラを動作させているときの、ファイラ終了時の動作を設定します。

  t   位置を保存します
  nil 位置を保存しません


■*modal-filer-save-size*
[       type]: Variable
[    package]: editor
[    seealso]: filer
[   referred]: *modal-filer-save-position*
[    section]: ファイラ
[description]: 
モーダルでファイラを動作させているときの、ファイラ終了時の動作を設定します。

  t   大きさを保存します
  nil 大きさを保存しません


■*modules*
[       type]: Variable
[    package]: lisp
[    seealso]: provide , require , modulep , 各種ロード関係の関数の違い
[       file]: evalmacs.l
[    section]: システム
[description]: 
ロードされたモジュールの一覧が格納されています。
(require "foo")で実際にモジュールを読み込むか否かは*modules*に登録されて
いるかどうかで決まります。モジュールの中で(provide "foo")すると、そのモ
ジュールが*modules*に追加されます。

使用例：
  ;;; モジュールの一覧を見てみる。
  *modules*
  => ( ... )
  (provide "foo")
  => ("foo" ... )
  *modules*
  => ("foo" ... )


■*move-forward-after-undo-deletion*
[       type]: Variable
[    package]: editor
[    seealso]: undo
[    section]: バッファ
[description]: 
削除をundoした場合のカーソルの位置を制御します。
  non-nil  削除範囲の最後尾
  nil      削除範囲の先頭


■*next-buffer-in-tab-order*
[       type]: Variable
[    package]: editor
[   referred]: next-buffer
[       file]: buffer.l
[    section]: バッファ
[description]: 
next-bufferで次に移動するバッファを、タブでの順番どおりにするか否かを設
定します。もちろんprevious-bufferにも影響します。
  t    バッファバーでの次のバッファに移動する。
  nil  どうなるでしょうか？


■*next-screen-context-lines*
[       type]: Variable
[    package]: editor
[    seealso]: next-page , previous-page , *page-scroll-half-window*
[       file]: page.l
[    section]: ウィンドウ
[description]: 
previous-page と next-page で重なって表示される行数を指定します。
*page-scroll-half-window* が non-nilのときは効果はありません。


■*package*
[       type]: Variable
[    package]: lisp
[    seealso]: パッケージ , defpackage , in-package
[    section]: パッケージ
[description]: 
実行中のパッケージを保持しています。
in-packageで別のパッケージに移ることができます。

使用例：
  *package*
  => #<package: user>


■*page-scroll-half-window*
[       type]: Variable
[    package]: editor
[    seealso]: next-page , previous-page , *next-screen-context-lines*
[       file]: page.l
[    section]: ウィンドウ
[description]: 
next-page/previous-pageのスクロールの単位を半画面ずつにするか制御します。

  t     半画面ずつスクロール
  nil   一画面ずつスクロール


■*page-scroll-keep-window-position*
[       type]: Variable
[    package]: editor
[   referred]: next-page
[       file]: page.l
[    section]: ポジション
[description]: 
next-page実行時にバッファの最後がウィンドウ内にある場合、バッファ
の最後に移動します。previous-pageも同様です。

  t   移動しません
  nil 移動します


■*popup-completion-list-default*
[       type]: Variable
[    package]: editor
[    seealso]: *minibuffer-popup-completion-list* , *lisp-popup-completion-list*
[   referred]: *print-completion-list-hook*
[       file]: complete.l
[    section]: その他
[description]: 
補完リスト表示のデフォルトの動作を制御します。
  :always   必ずポップアップ表示します。
  :never    *Completion*バッファで表示します。
  上記以外  個々の設定(*minibuffer-popup-completion-list*等)が
            適用されます。


■*post-command-hook*
[       type]: Variable
[    package]: editor
[    seealso]: *pre-command-hook*
[    section]: 変数と定数
[description]: 
コマンドループにおいてコマンドの実行後に実行されます。


■*post-startup-hook*
[       type]: Variable
[    package]: editor
[    seealso]: 起動時処理フロー
[       file]: estartup.l
[    section]: 変数と定数
[description]: 
初期設定ファイル.xyzzy実行後に以下の順番でフック変数が評価されま
す。
  1. *load-history-hook*
  2. *init-app-menu-hook*
  3. *command-line-mailto-hook*（-mailtoがある場合）
  4. *process-command-line-hook*（不明なオプションがある場合）
  5. *post-startup-hook*


■*pre-abbrev-expand-hook*
[       type]: Variable
[    package]: editor
[    seealso]: expand-abbrev
[       file]: abbrev.l
[    section]: 変数と定数
[description]: 
expand-abbrevの最初に実行されます。


■*pre-command-hook*
[       type]: Variable
[    package]: editor
[    seealso]: *post-command-hook*
[    section]: 変数と定数
[description]: 
コマンドループにおいてコマンドの実行前に実行されます。 


■*pre-startup-hook*
[       type]: Variable
[    package]: editor
[    seealso]: 起動時処理フロー
[       file]: estartup.l
[    section]: 変数と定数
[description]: 
初期設定ファイルsiteinit.l実行後に実行されます。


■*prefix-args*
[       type]: Variable
[    package]: editor
[    seealso]: *prefix-value* , universal-argument
[   referred]: command-execute , find-file , forward-char , forward-line , interactive
[    section]: 変数と定数
[description]: 
コマンドが数引き数付きで呼ばれた場合に設定される変数です。

  (defun test1 ()
    (interactive)
    (message "~s,~s " *prefix-args* *prefix-value*))

例えば、C-u 10 M-x test1と呼び出されると、
*prefix-args* が non nil になり、 *prefix-value* に値が入ります。


■*prefix-value*
[       type]: Variable
[    package]: editor
[    seealso]: *prefix-args* , universal-argument
[    section]: 変数と定数
[description]: 
コマンドが数引き数付きで呼ばれた時に数値が入ります。


■*print-circle*
[       type]: Variable
[    package]: lisp
[    seealso]: *print-length*
[    section]: 変数と定数
[description]: 
循環リストの表示を省略形にします

標準はnilです。read-eval-printのループでの
表示は常にtのようです。

(setq *print-circle* nil) => nil
(setq x (list 'a))        => (a)
(setf (cdr x) x)          => #1=(a . #1#)
(princ x)
=> (a a a ...
;;無限に続くのでC-gで終了
(setq *print-circle* t)   => t
(princ x)
#1=(a . #1#)
=> #1=(a . #1#)


■*print-completion-list-hook*
[       type]: Variable
[    package]: editor
[    seealso]: *popup-completion-list-default*
[       file]: complete.l
[    section]: 変数と定数
[description]: 
do-completion実行時に、補完リストを表示するために使用されています。
ポップアップ表示の前に処理されます。 
※funcallで実行されるので注意すること
  
使用例：
  (setq *print-completion-list-hook*
        #'(lambda (list prefix &optional string)
            (popup-string
             (format nil
                     "Possible completions are ~D items:\n~{\n~A~}"
                     (length list) list) (point))))


■*print-length*
[       type]: Variable
[    package]: lisp
[    seealso]: *print-circle*
[    section]: 変数と定数
[description]: 
長いリストの表示を途中で打ち切ります。

(setq *print-length* nil) => nil
(princ '(a b c d e f g h i j))
=>(a b c d e f g h i j)

(setq *print-length* 5)   => 5
(princ '(a b c d e f g h i j))
=>(a b c d e ...)


■*print-option-show-dialog*
[       type]: Variable
[    package]: editor
[       file]: estartup.l
[    section]: その他
[description]: 
nilの場合は、コマンドラインオプションで -p を指定した時、印刷ダイアログ
を表示しません。


■*print-pretty*
[       type]: Variable
[    package]: lisp
[    section]: 変数と定数
[description]: 
式の表示を見やすくします。

標準はtです。

(flet ((f (x) (princ x) (terpri)))
  (let ((*print-pretty* t))
    (f '('a #'b))  ;;tの時の表示
    (setq *print-pretty* nil)
    (f '('a #'b))));;nilの時の表示
=> ('a #'b)
   ((quote a) (function b))


■*process-command-line-hook*
[       type]: Variable
[    package]: editor
[    seealso]: 起動時処理フロー
[       file]: estartup.l
[    section]: システム
[description]: 
xyzzy.exeに渡されたオプション引数を判定する際に呼び出されます。
*post-startup-hook*の直前で呼び出されます。

参考：
  (run-hook-with-args-until-success
   '*process-command-line-hook* arg)


■*query-kill-buffer-hook*
[       type]: Variable
[    package]: editor
[    seealso]: kill-buffer , run-hook-with-args-while-success
[       file]: buffer.l
[    section]: 変数と定数
[description]: 
kill-buffer で実行されます。バッファの破棄を確認するために使用します。
※run-hook-with-args-while-successで実行されるので注意すること。


■*query-kill-xyzzy-hook*
[       type]: Variable
[    package]: editor
[    seealso]: *kill-xyzzy-hook*
[    section]: 変数と定数
[description]: 
xyzzy終了時に実行されます。このフック変数の実行がnilだと終了しません。
[xyzzy:03872]を参照


■*quotation-prefix*
[       type]: Variable
[    package]: editor
[    seealso]: quote-region
[       file]: region.l
[    section]: テキスト
[description]: 
引用を表す接頭子です。具体的には、 quote-region したときにリージョンの行頭
に挿入する文字列です。

参考：
  ;;; 初期値ではこんなものが設定されています。
  (defvar *quotation-prefix* "| ")


■*random-state*
[       type]: Variable
[    package]: lisp
[    seealso]: random , make-random-state
[    section]: 数値
[description]: 
現在の乱数の状態を保持してます。
random が STATE 無しで呼ばれたとき使われます。


■*readtable*
[       type]: Variable
[    package]: lisp
[    seealso]: si:*set-readtable-case , readtable-case , readtablep , copy-readtable , *ole-readtable*
[    section]: 入出力
[description]: 
現在のリードテーブルを格納している変数です。


■*rectangle-kill-buffer*
[       type]: Variable
[    package]: editor
[    seealso]: copy-rectangle , kill-rectangle , yank-rectangle
[       file]: rectangl.l
[    section]: リージョン
[description]: 
コピーした矩形を格納します。
中身は矩形の各行の文字列を並べたリストです。


■*save-buffer-no-filenames-hook*
[       type]: Variable
[    package]: editor
[    seealso]: save-buffer , get-buffer-file-name
[    section]: 変数と定数
[description]: 
get-buffer-file-name が nil とかだと実行されます。
使用例:
  (add-hook '*save-buffer-no-filenames-hook*
          #'(lambda ()
              (if (yes-or-no-p "保存しますか")
                  ;;この時点で set-buffer-file-name をしても遅い。
                  ;;emacs-write-file なりを呼んでからnon-nilを渡すべき
                  (emacs-write-file (read-file-name "filename:"))
                ;;次のhookに処理を渡す場合はnilを渡す
                nil)))


■*save-history*
[       type]: Variable
[    package]: editor
[       file]: history.l
[    section]: 変数と定数
[description]: 
保存するヒストリの個数です。
[共通設定] - [いろいろ] - [保存するヒストリの個数(S)] で値を指定すること
ができます。


■*save-history-hook*
[       type]: Variable
[    package]: editor
[       file]: history.l
[    section]: 変数と定数
[description]: 
*kill-xyzzy-hook*実行時に呼び出されます。
コマンドバー、セッション等のヒストリ変数の保存に使用されています。


■*save-resume-info*
[       type]: Variable
[    package]: editor
[       file]: history.l
[    section]: 変数と定数
[description]: 
non-nil ならば終了時の状態を保存します。
[共通設定] - [さまざま] - [終了時の状態を保存する(U)] で値を指定すること
ができます。


■*scroll-bar-step*
[       type]: Variable
[  arguments]: *scroll-bar-step*
[    package]: editor
[    section]: ウィンドウ
[description]: 
スクロールバーについている▲・▼ボタンを押したときのスクロール量です。
デフォルトは 2 です。


■*select-pseudo-frame-hook*
[       type]: Variable
[    package]: editor
[    seealso]: new-pseudo-frame , select-pseudo-frame , ed::pseudo-frame
[       file]: pframe.l
[    section]: ウィンドウ
[description]: 
フレームを選択、移動、および新規作成したときに実行されます。
すべてのフレームに対して適用されます。

フレームごとに違う動作をさせたい場合は、
フレーム構造体のスロット selected-fn に関数を設定します。


■*selection-ring*
[       type]: Variable
[    package]: editor
[    seealso]: yank-selection , copy-selection , *kill-ring*
[       file]: select.l
[    section]: リージョン
[description]: 
copy-selectionやkill-selectionで切り取った選択された領域を管理します。
*selection-ring*は*kill-ring*と同様にリングバッファとして管理されます。


■*show-cursor-line-always*
[       type]: Variable
[    package]: editor
[    seealso]: toggle-cursor-line , inverse-cursor-line
[    section]: バッファ
[description]: 
カレントでないウィンドウでもカーソルラインを表示します。

使用例：
  (setq *show-cursor-line-always* t)


■*show-match-hook*
[       type]: Variable
[    package]: editor
[    seealso]: search-dialog
[       file]: search.l
[    section]: 変数と定数
[description]: 
検索で一致したものの表示に使用しています。設定されていなければ、
show-matchが実行されます。
※run-hook-with-args-while-successで実行されるので注意すること。


■*show-matched-parenthesis*
[       type]: Variable
[    package]: editor
[    seealso]: set-syntax-match
[       file]: cmds.l
[    section]: バッファ
[description]: 
対応する括弧の表示を制御します。括弧に使用する文字は
set-syntax-match で指定します。
  non-nil  対応する括弧を表示する
  nil      対応する括弧を表示しない


■*smart-indentation*
[       type]: Variable
[    package]: editor
[    seealso]: smart-indentation
[       file]: cmds.l
[    section]: ポジション
[description]: 
インデント処理の前後で全く変更する必要が無かった場合の制御を設定します。

  nil      位置が同じでも従来通り常に変更する
  t        位置が違う場合のみ変更する（タブとスペースの組み合わせは気にする）
  上記以外 位置が違う場合のみ変更する（タブとスペースの組み合わせは気にしない）


■*standard-input*
[       type]: Variable
[    package]: lisp
[    seealso]: *standard-output* , *keyboard*
[    section]: 入出力
[description]: 
標準入力を表すストリームです。
普段はキーボードからの入力になっています。


■*standard-output*
[       type]: Variable
[    package]: lisp
[    seealso]: *standard-input*
[    section]: 入出力
[description]: 
標準出力を表すストリームです。
普段はステータスバーのウィンドウへの出力になっています。
lisp-interaction-mode の C-j(eval-print-last-sexp) では
そのバッファへの出力になっています。

使用例：
  ;;; eval-expression で評価した場合
  *standard-output*  
  => #<status window stream 48042808>

  ;;; eval-print-last-sexp で評価した場合
  *standard-output*
  => #<buffer stream 48042280>


■*status-bar-format*
[       type]: Variable
[    package]: editor
[   referred]: what-cursor-position
[       file]: page.l
[    section]: ウィンドウ
[description]: 
ステータスバーに表示する情報を指定する文字列です。文字の並び順に表示されます。

  t     時計
  p     カーソル位置
  c     カーソル位置の文字コード(内部コード)
  u     カーソル位置の文字コード(ユニコード)
  T     時計（曜日入り）

使用例：
  (setq *status-bar-format* "cupT")


■*std-control-default-char*
[       type]: Variable
[    package]: editor
[       file]: defs.l
[    section]: ダイアログ
[description]: 
select-bufferやダイアログのリストボックスで、デフォルト選択用の
キャラクタを設定します。

使用例：
  (setq *std-control-default-char* #\RET)


■*std-control-down-char*
[       type]: Variable
[    package]: editor
[    seealso]: *std-control-up-char*
[       file]: defs.l
[    section]: ダイアログ
[description]: 
select-bufferやダイアログのリストボックスで、下方向に移動するキ
ャラクタを設定します。

使用例：
  (setq *std-control-down-char* #\C-n)


■*std-control-next-char*
[       type]: Variable
[    package]: editor
[    seealso]: *std-control-prior-char*
[    section]: ダイアログ
[description]: 
select-bufferやダイアログのリストボックスで、
ページダウンするキャラクタを設定します。

使用例：
  (setq *std-control-next-char* #\C-v)


■*std-control-prior-char*
[       type]: Variable
[    package]: editor
[    seealso]: *std-control-next-char*
[    section]: ダイアログ
[description]: 
select-bufferやダイアログのリストボックスで、
ページアップするキャラクタを設定します。

使用例：
  (setq *std-control-prior-char* #\C-u)


■*std-control-up-char*
[       type]: Variable
[    package]: editor
[    seealso]: *std-control-down-char*
[       file]: defs.l
[    section]: ダイアログ
[description]: 
select-bufferやダイアログのリストボックスで、上方向に移動するキ
ャラクタを設定します。

使用例：
  (setq *std-control-up-char* #\C-p)


■*tail-f-mode-hook*
[       type]: Variable
[    package]: editor
[    seealso]: tail-f
[       file]: tail-f.l
[    section]: モード
[description]: 
tail-f起動時に実行されます。


■*this-command*
[       type]: Variable
[    package]: editor
[    seealso]: *last-command*
[    section]: 変数と定数
[description]: 
現在実行中の関数名のシンボルを格納しています。*last-command*に設定されます。
*pre-command-hook* / *post-command-hook*で特別な処理をかますのに使ったり、
実行中のコマンドを偽ったりできます。


■*unicode-to-half-width*
[       type]: Variable
[    package]: editor
[    seealso]: unicode-char , char-columns
[    section]: 文字
[description]: 
non-nil なら、UNICODE 文字の表示に半角文字を使用します。
デフォルトでは t が xyzzy ソース内で設定されています。

使用例：
  ;;; 半角文字で表示
  (setq *unicode-to-half-width* t)   => t
  (unicode-char 180)                 => #\x0134
  ;;; 全角文字で表示
  (setq *unicode-to-half-width* nil) => nil
  (unicode-char 180)                 => #\4


■*wrap-search*
[       type]: Variable
[    package]: editor
[   referred]: search-forward-again
[       file]: search.l
[    section]: 検索・正規表現
[description]: 
文字列検索でバッファの最後までいったら、最初に戻るかどうかを制御します。

| search-forward-again で、バッファの最後まで行くと、最初に
| 戻って探しつづけますよね。
| あれって禁止できないでしょうか？

  (setq *wrap-search* nil)

とすればできますけど、たまに禁止したいとなるとちょっと面倒ですね。

| と言うか、それはそれで便利なんだけど、禁止したい時もあるんです。
| 「ここ以降にあるか無いか」と言うことを知りたい時とか・・・

現在位置から最後までを narrow してサーチするとか。
count-matches が 0 だったら無いとか。
検索ダイアログから指定するとか。


■+
[       type]: Function
[  arguments]: + &rest NUMBERS
[    package]: lisp
[    seealso]: -
[       file]: builtin.l
[    section]: 数値
[description]: 
引数を全て加算して返します。

使用例：  
  (+ 1 2 3)
  => 6
  (+ 1.2 4 -2)
  => 3.2


■-
[       type]: Function
[  arguments]: - NUMBER &rest MORE-NUMBERS
[    package]: lisp
[    seealso]: +
[       file]: builtin.l
[    section]: 数値
[description]: 
引数が一つの場合にはその数値をマイナスにしたものを返します。
引数が二つ以上の場合には一つ目の引数からその他の引数を減算した数値を返します。

使用例：
  (- 3)
  => -3
  (- 3 2 1)
  => 0


■/
[       type]: Function
[  arguments]: / NUMBER &rest MORE-NUMBERS
[    package]: lisp
[    seealso]: denominator , numerator , *
[       file]: builtin.l
[    section]: 数値
[description]: 
引数が一つの場合には 1 を引数で除算した数値を返します。
引数が二つ以上の場合には一つ目の引数を二つ目の引数全てで除算した数値を返します。
  
使用例：  
  (/ 2)
  => 1/2  
  (/ 3 2 1)
  => 3/2
  (/ 4 3 2)
  => 2/3


■/=
[       type]: Function
[  arguments]: /= NUMBER &rest MORE-NUMBERS
[    package]: lisp
[    seealso]: =
[       file]: builtin.l
[    section]: 数値
[description]: 
引数がすべて異なっていればt、そうでなければnilを返します。

使用例：  
  (/= 2 3)
  => t
  (/= 3 3)
  => nil
  (/= 2 3 4 5)
  => t
  (/= 2 3 4 2)
  => nil


■1+
[       type]: Function
[  arguments]: 1+ NUM
[    package]: lisp
[    seealso]: 1-
[       file]: number.l
[    section]: 数値
[description]: 
NUMに1を足した数を返します。

使用例：  
  (1+ 1)
  => 2


■1-
[       type]: Function
[  arguments]: 1- NUM
[    package]: lisp
[    seealso]: 1+
[       file]: number.l
[    section]: 数値
[description]: 
NUMから1を引いた数を返します。

使用例：  
  (1- 2)
  => 1


■:case-fold
[       type]: Keyword
[    package]: keyword
[    seealso]: scan-buffer
[    section]: 変数と定数
[description]: 
検索する場合に大文字と小文字を区別するかどうかを指定します。

  t     大文字と小文字を区別しません。
  nil   大文字と小文字を区別します。


■:key
[       type]: Keyword
[    package]: keyword
[    seealso]: :test , :test-not
[    section]: 変数と定数
[description]: 
assoc や member、find などの関数で検索をする際に
各要素に適用する関数を指定します。
言い換えると、:test や :test-not で指定された関数に渡す値を
各要素から“取り出す”方法をこの関数で指定します。

使用例:
  ;; car が 'a である要素を除去する
  (remove 'a '((a . b) (b . x) (c d e) (a f h i) (x y)) :key #'car)
  => ((b . x) (c d e) (x y))
  ;; :test と組み合わせることも可能
  (remove "a" '(("a" . "b") ("b" . "c") ("d" . "a") ("a" . "e") ("b". "b"))
          :test #'string= :key #'car)
  => (("b" . "c") ("d" . "a") ("b" . "b"))


■:no-dup
[       type]: Keyword
[    package]: keyword
[    seealso]: scan-buffer
[    section]: 変数と定数
[description]: 
検索する場合に同じ位置から行うかどうかを指定します。

  t     ひとつ次から検索を行う。
  nil   同じ位置から検索を行う。


■:regexp
[       type]: Keyword
[    package]: keyword
[    seealso]: scan-buffer
[    section]: 変数と定数
[description]: 
検索文字列が正規表現か否かを指定します。

  t     検索文字列は正規表現
  nil   検索文字列はただの文字列


■:reverse
[       type]: Keyword
[    package]: keyword
[    seealso]: scan-buffer
[    section]: 変数と定数
[description]: 
検索する場合に正方向か逆方向かを指定します。

  t     逆方向に検索します。
  nil   正方向に検索します。


■:right-bound
[       type]: Keyword
[    package]: keyword
[    seealso]: scan-buffer
[    section]: 変数と定数

■:tail
[       type]: Keyword
[    package]: keyword
[    seealso]: scan-buffer
[    section]: 変数と定数
[description]: 
検索した場合にカーソルを文字列の先頭か末尾のどちらに位置づけるかを指定します。

  t     カーソルを末尾に位置づけます。
  nil   カーソルを先頭に位置づけます。


■:test
[       type]: Keyword
[    package]: keyword
[    seealso]: :test-not , :key
[    section]: 変数と定数
[description]: 
assoc や member、find などの関数で検索をする際に、
このキーワードに設定した関数を用いて真偽の判定をします。

なお :test-not と同時に指定することはできません。

使用例:
  (assoc "b" '(("a" . 1) ("B" . 2) ("b" . 3) ("c" . 4)))
  => nil
  (assoc "b" '(("a" . 1) ("B" . 2) ("b" . 3) ("c" . 4)) :test #'string=)
  => ("b" . 3)
  (assoc "b" '(("a" . 1) ("B" . 2) ("b" . 3) ("c" . 4)) :test #'string-equal)
  => ("B" . 2)


■:test-not
[       type]: Keyword
[    package]: keyword
[    seealso]: :test , :key
[    section]: 変数と定数
[description]: 
assoc や member、find などの関数で検索をする際に、
このキーワードに設定した関数の逆（not）を用いて真偽の判定をします。
  
なお :test と同時に指定することはできません。

使用例:
  ;; "abc" を含む文字列を選ぶ = "abc" を含まない文字列を除去する
  (remove "abc" '("abcd" "test" "xabcx" "abc" "xyz") :test-not #'string-match)
  => ("abcd" "xabcx" "abc")


■<
[       type]: Function
[  arguments]: < NUMBER &rest MORE-NUMBERS
[    package]: lisp
[    seealso]: >
[       file]: builtin.l
[    section]: 数値
[description]: 
引数が小さい順に並んでいればt、そうでなければnilを返します。

使用例：  
  (< 2 3 4)
  => t
  (< 2 4 3 5)
  => nil


■<=
[       type]: Function
[  arguments]: <= NUMBER &rest MORE-NUMBERS
[    package]: lisp
[    seealso]: >=
[       file]: builtin.l
[    section]: 数値
[description]: 
隣り合った引数がすべて<=の関係ならt、そうでなければnilを返します。

使用例：  
  (<= 2 3 3 4)
  => t
  (<= 2 4 3 5)
  => nil


■=
[       type]: Function
[  arguments]: = NUMBER &rest MORE-NUMBERS
[    package]: lisp
[    seealso]: equal , equalp , /=
[       file]: builtin.l
[    section]: 数値
[description]: 
引数の数値がすべて等しければt、そうでなければnilを返します。

使用例：  
  (= 3 3)
  => t
  (= 3 4)
  => nil
  (= 3 3 3 3)
  => t
  (= 3 3 3 4)
  => nil


■>
[       type]: Function
[  arguments]: > NUMBER &rest MORE-NUMBERS
[    package]: lisp
[    seealso]: <
[       file]: builtin.l
[    section]: 数値
[description]: 
引数が大きい順に並んでいればt、そうでなければnilを返します。

使用例：  
  (> 3 2 1)
  => t
  (> 3 2 1 4)
  => nil


■>=
[       type]: Function
[  arguments]: >= NUMBER &rest MORE-NUMBERS
[    package]: lisp
[    seealso]: <=
[       file]: builtin.l
[    section]: 数値
[description]: 
隣り合った引数がすべて>=の関係ならt、そうでなければnilを返します。
  
使用例：  
  (>= 4 3 3 2 1)
  => t
  (>= 4 2 3 1)
  => nil


■BS と C-h に別々の機能を割り当てるには？
[       type]: Tips
[    seealso]: global-set-key
[    section]: キーマップ
[description]: 
| (global-set-key #\C-h 'replace-dialog) という設定を行うと、
| BS Key を押下した場合も、ダイアログが出てきます。

伝統的な仕様ですが、

  (setf (svref *kbd-translate-table* (char-code #\C-h)) #\F13)
  (global-set-key #\F13 'replace-dialog)

このようにすれば逃げられなくもないです。


■C-z でアイコン化させるには？
[       type]: Tips
[    section]: その他
[description]: 
(require "wip/winapi")
(c:define-dll-entry winapi:BOOL ShowWindow (winapi:HWND c:int) "user32")

(global-set-key #\C-z #'(lambda () (interactive)
                          (ShowWindow (get-window-handle) 6)))


■DOSのコマンドをキックして結果を文字列にするには？
[       type]: Tips
[    section]: その他
[description]: 
| DOSのコマンド(コンソールアプリって言ったほうがいいのかな？）
| をキックして、結果を文字列として、取り出す事はできますか？

こんな感じでしょうか。

(defun command-substitution (command)
  (let ((outfile nil)
        (buffer nil))
    (unwind-protect
        (save-excursion
          (setq buffer (create-new-buffer "*foo*"))
          (setq outfile (make-temp-file-name))
          (call-process command :output outfile :show :hide :wait t)
          (set-buffer buffer)
          (insert-file-contents outfile)
          (goto-char (1- (point-max)))
          (when (looking-for "\n")
            (delete-char 1))
          (goto-char (point-min))
          (replace-buffer "\n+" " " :regexp t)
          (buffer-substring (point-min) (point-max)))
      (and buffer
           (delete-buffer buffer))
      (and outfile
           (delete-file outfile)))))


■Emacs 互換ではない正規表現は結構あるのでしょうか？
[       type]: Tips
[   referred]: 正規表現の表記
[    section]: 検索・正規表現
[description]: 
\'  \`  \=  \c  \C これだけです。


■OLEオートメーションの使用例
[       type]: Tips
[    section]: その他
[description]: 
; 意味もなく全部のシートに「東西南北」を書き込む
(setq application (ole-create-object "Excel.Application"))
(ole-putprop application 'visible 1)
(setq workbook (ole-method (ole-getprop application 'Workbooks) 'Add))
(setq numbers-of-worksheets
      (ole-getprop
       (ole-getprop workbook 'worksheets)
       'count))
(setq worksheet-index 1)
(while (<= worksheet-index numbers-of-worksheets)
  (setq worksheet
 (ole-getprop workbook 'Worksheets worksheet-index))
  (ole-putprop (ole-method worksheet 'Range "A1:D1")
        'value #("東" "西" "南" "北"))
  (setq worksheet-index (+ worksheet-index 1)))


こんな小細工をしてみたんですけどどうでしょう?

(defmacro $ (obj prop &rest args)
  `(ole-method ,obj ',prop ,@args))

(defsetf $ (obj prop &rest args) (x)
  `(progn
     (ole-putprop ,obj ',prop ,x ,@args)
     ,x))

(let (app workbook worksheet range)
  (setq app (ole-create-object "Excel.Application"))
  (setf ($ app Visible) t)
  (setq workbook ($ ($ app Workbooks) Add))
  (setq worksheet ($ workbook Worksheets 1))
  (setf ($ ($ worksheet Range "A1:D1") Value) '("North" "South" "East" "West"))
  (setf ($ ($ worksheet Range "A2:B2") Value) #(5.2 10))
  (setf ($ ($ worksheet Range "C2") Value) 8)
  (setf ($ ($ worksheet Range "D2") Value) 20)

  (setq range ($ worksheet Range "A1:D2"))
  ($ range Select)
  ($ ($ workbook Charts) Add)
  (sit-for 5)

  (setf ($ workbook saved) t)
  ($ ($ app ActiveWorkbook) Close 0)
  ($ app Quit))


■``'(backquote)
[       type]: Misc
[  arguments]: form
[    package]: ???
[   referred]: defmacro , quote
[    section]: マクロ
[description]: 
注：タイプはリードマクロなんですが・・・
　　info-modokiでどうしようか悩んでしまいます。

``'(逆引用符(backquote))はリストをquoteします。ただし、特別な標識 `,' 
及び `,@' を用いることで、リストの要素を選択的に評価することができます。

使用例：
  ;;; 逆引用符を使用してリストを作成
  (setq f0 '(0 1 2 3))         =>  (0 1 2 3)  
  (setq f1 `(0 1 2 3))         =>  (0 1 2 3)
  (setq f2 `(4 5 ,(car f1)))   =>  (4 5 0)
  (setq f3 `(6 7 ,(cdr f1)))   =>  (6 7 (1 2 3))
  (setq f4 `(8 9 ,@(cdr f1)))  =>  (8 9 1 2 3)


■abbrev-mode
[       type]: Function
[  arguments]: abbrev-mode &optional (ARG () SV)
[    package]: editor
[    seealso]: quietly-read-abbrev-file
[   referred]: expand-abbrev
[       file]: abbrev.l
[    section]: モード
[description]: 
abbrev-modeを開始します。

使用例：
  (abbrev-mode t)


■abbreviate-display-string
[       type]: Function
[  arguments]: abbreviate-display-string STRING LENGTH &optional PATHNAMEP
[    package]: editor
[       file]: builtin.l
[    section]: 文字列
[description]: 
文字列を表示幅に収まるように[...]で省略して返します。

  STRING    : 表示する文字列を指定します。
  LENGTH    : 表示幅を指定します。
  PATHNAMEP : 文字列がファイル名かどうかを指定します。
              ファイル名の場合には先頭の3文字(例："C:/"）だけ残して省略します。

使用例：
 (abbreviate-display-string "c:/xyzzy/lisp/builtin.l" 20 nil)
 => "c:/xyzzy.../builtin.l"
 (abbreviate-display-string "c:/xyzzy/lisp/builtin.l" 20 t)
 => "c:/.../lisp/builtin.l"


■abs
[       type]: Function
[  arguments]: abs NUMBER
[    package]: lisp
[       file]: builtin.l
[    section]: 数値
[description]: 
絶対値を返します。

使用例：
  ;;; 絶対値を返す。
  (abs -3.0)
  => 3.0  


■acons
[       type]: Function
[  arguments]: acons KEY DATUM A-LIST
[    package]: lisp
[       file]: builtin.l
[    section]: リスト
[description]: 
(KEY . DATUM) を A-LIST に加えた連想リストを返します。

  (acons x y a) == (cons (cons x y) a)

使用例：
  (setq foo '((b . 2))) => ((b . 2))
  (acons 'a 1 foo)      => ((a . 1) (b . 2))
  foo                   => ((b . 2))


■acos
[       type]: Function
[  arguments]: acos NUMBER
[    package]: lisp
[    seealso]: acosh
[       file]: builtin.l
[    section]: 数値
[description]: 
逆余弦関数の値を返します。


■acosh
[       type]: Function
[  arguments]: acosh Z
[    package]: lisp
[    seealso]: acos
[       file]: number.l
[    section]: 数値
[description]: 
逆双曲線余弦関数を計算します。


■activate-xyzzy-window
[       type]: Function
[  arguments]: activate-xyzzy-window INSTANCE
[    package]: editor
[    seealso]: si:*instance-number , list-xyzzy-windows
[       file]: builtin.l
[    section]: プロセス
[description]: 
指定したxyzzyをアクティブにします。
  
  INSTANCE : 起動中のxyzzyに割り当てられた非負の整数


■add-file-history-to-menu
[       type]: Function
[  arguments]: add-file-history-to-menu
[    package]: editor
[    seealso]: *minibuffer-file-name-history*
[       file]: app-menu.l
[    section]: その他
[description]: 
ファイルメニューの履歴のところに履歴を記録する？
（詳細不明）
(add-file-history-to-menu)


■add-history
[       type]: Function
[  arguments]: add-history ITEM VAR
[    package]: editor
[    seealso]: *minibuffer-maximum-history-count* , *minibuffer-enable-add-to-menu*
[       file]: minibuf.l
[    section]: 変数と定数
[description]: 
VAR に ITEM を LRU順で追加します。 *minibuffer-maximum-history-count* 
を超えるときは、最も使用されていないヒストリを削除します。

また、 *minibuffer-enable-add-to-menu* が non-nil のときに、
(get VAR 'add-lru-menu-function) に関数が設定されていれば、
その関数を実行します。例えば、 *minibuffer-file-name-history* には、 
add-file-history-to-menu が設定されており、開いたファイルをメニューの
「最近使ったファイル(F)」に登録しています。

使用例：
  (add-history file '*minibuffer-file-name-history*)
  (add-history cmd '*minibuffer-execute-history*)


■add-hook
[       type]: Function
[  arguments]: add-hook HOOK FN &optional APPEND
[    package]: editor
[    seealso]: delete-hook , run-hooks
[       file]: misc.l
[    section]: モード
[description]: 
フック変数に関数を追加します。

  HOOK : フック変数のシンボルを指定します。
  FN   : 関数のシンボルを指定します。

フックとは特定の処理においてユーザが望む処理を追加するための仕組みです。
xyzzyには「ユーザが修正したいだろうなぁ」と思うところにフックが仕掛けら
れています。例えば「find-fileするときには何か関数を実行したい」と思った
ら、「find-fileを上書き」したり、「xxx-find-fileを作ったり」するのではな
く、その用途に使えるフック変数がないかどうかを確認しましょう。

下の例はfind-fileする時にfunc1とfunc2を呼び出して何らかの処理をする例です。

  【準備処理】
        ;;; find-fileで呼び出される*before-find-file-hook*に
        ;;; ユーザが作った関数func1とfunc2が呼び出されるように登録する。
        (add-hook '*before-find-file-hook* 'func1)
        (add-hook '*before-find-file-hook* 'func2)

  【find-file実行時】
        ;;; find-fileを実行すると、ファイルの読み込みの前で
        ;;; *before-find-file-hook*に登録されている関数が実行される。
        (find-file ...)
          └(run-hooks '*before-find-file-hook*)
              ├(func1)
              └(func2)

  【後片付け】
        ;;; find-fileで呼び出される*before-find-file-hook*から
        ;;; ユーザが作った関数func1とfunc2を取り除く
        (delete-hook '*before-find-file-hook* 'func1)
        (delete-hook '*before-find-file-hook* 'func2)

なお、フック変数は用途に応じて呼び出され方や戻す値の意味が異なります。注
意しましょう。

使用例：
  ;;; lispmode.l
  (add-hook '*query-kill-buffer-hook* 'kill-scratch-hook)


■add-menu-item
[       type]: Function
[  arguments]: add-menu-item MENU TAG NAME &optional COMMAND INIT
[    package]: editor
[    seealso]: insert-menu-item , get-menu , create-menu , define-menu
[       file]: builtin.l
[    section]: メニュー
[description]: 
新たに作成したメニュー項目をメニューの末尾に追加します。

  MENU    : 追加先のメニューを指定します。
  TAG     : 識別用のタグを指定します。
  NAME    : メニューに表示される名前を指定します。
  COMMAND : メニューの項目が選択されたときに実行するコマンドを指定します。
  INIT    : メニューが開く直前に評価し返される値によってメニューの状態を
            設定します。任意のS式が指定できますが、あまり無茶なことはしな
            いでください。式の値として意味のある値には以下のものがあります。

        :modified     カレントバッファが変更されていなければ灰色表示。
        :undo         undo不可能であれば灰色表示。
        :redo         redo不可能であれば灰色表示。
        :selection    カレントバッファのテキストが未選択であるか矩形選択
                      であれば灰色表示。
        :rectangle    カレントバッファのテキストが未選択であるか矩形以外
                      の選択であれば灰色表示。
        :clipboard    クリップボードが空であれば灰色表示。
        :check        チェック。
        :disable      灰色表示。
        その他        使用可能。


■add-menu-separator
[       type]: Function
[  arguments]: add-menu-separator MENU &optional TAG
[    package]: editor
[    seealso]: insert-menu-separator , define-menu , define-popup-menu , get-menu , get-menu-position
[       file]: builtin.l
[    section]: メニュー
[description]: 
セパレータをメニューの末尾に追加します。

  MENU : 追加先のメニューを指定します。
  TAG  : 識別用のタグを指定します。


■add-popup-menu
[       type]: Function
[  arguments]: add-popup-menu MENU POPUP-MENU NAME
[    package]: editor
[    seealso]: insert-popup-menu , define-popup-menu
[       file]: builtin.l
[    section]: メニュー
[description]: 
ポップアップメニューをメニューの末尾に追加します。

  MENU       : 追加先のメニューを指定します。
  POPUP-MENU : 追加するポップアップメニューを指定します。
  NAME       : メニューに表示される名前を指定します。

使用例：
  ;;; 右クリックメニューを標準のメニューに追加してみる。
  (add-popup-menu *app-menu* *app-popup-menu* "編集2(&E)")
  => #<menu 48701736>


■adjoin
[       type]: Function
[  arguments]: adjoin ITEM LIST &key :test :test-not :key
[    package]: lisp
[    seealso]: pushnew
[       file]: builtin.l
[    section]: リスト
[description]: 
ITEM が LIST の member でなければ先頭に追加した LIST を返す。 member なら LIST を
そのまま返します。

  (adjoin item list) == (if (member item list) list (cons item list))

  :key : :keyに fn が指定された場合，xyzzyでは
          (adjoin item list) == (if (member item list :key fn) list (cons item list))
         となりますが，CLTL2では次のように動作し，非互換です．
          (adjoin item list) == (if (member (funcall fn item) list :key fn) list (cons item list))

使用例：
  (adjoin 'a '(b c d))
  => (a b c d)
  (adjoin 'b '(a b c d))
  => (a b c d)
  (adjoin '(a) '((b) (c) (d)) :key #'car)
  => ((a) (b) (c) (d))


■adjustable-array-p
[       type]: Function
[  arguments]: adjustable-array-p ARRAY
[    package]: lisp
[    seealso]: vector-push-extend , make-array
[       file]: builtin.l
[    section]: 配列
[description]: 
ARRAY がサイズ変更可能なら t、不可能なら nil を返します。


■alpha-char-p
[       type]: Function
[  arguments]: alpha-char-p CHAR
[    package]: lisp
[    seealso]: both-case-p , alphanumericp , characterp
[       file]: builtin.l
[    section]: データ型
[description]: 
文字が英字[A-Za-z]かどうかを判定します。

  CHAR : 判定する文字


■alphanumericp
[       type]: Function
[  arguments]: alphanumericp CHAR
[    package]: lisp
[    seealso]: alpha-char-p , characterp
[       file]: builtin.l
[    section]: データ型
[description]: 
文字が英数字[A-Za-z0-9]かどうかを判定します。

  CHAR : 判定する文字


■and
[       type]: Macro
[  arguments]: and &rest FORMS
[    package]: lisp
[    seealso]: or
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
フォームがnon-nilの間だけ順番に評価します。
フォームが一つでもnilならば、そこで評価を中断してnilを返して終了します。
全てのフォームがnon-nilならば、最後に実行したフォームの値を返します。

  ;;; exp1 がnon-nilなら exp2を実行し、
  ;;; exp2 がnon-nilなら exp3を実行し、
  ;;; exp3 がnon-nilなら.......
  (and exp1 exp2 exp3 ...)

例えば、以下の様にチェックを順番に記述するような場合に向いていると思います。
チェックに失敗すれば、以降の処理は実行しません。

  (and (file-exist-p ...) ; 特定のファイルの存在チェック
       (find-file ...)    ; そのファイルを読み込みチェック
       (scan-buffer ...)  ; 正規表現で検索
       (match-string 2)   ; 検索結果のチェック
       ...)


■append
[       type]: Function
[  arguments]: append &rest LISTS
[    package]: lisp
[    seealso]: nconc , concatenate
[       file]: builtin.l
[    section]: リスト
[description]: 
複数のリストを引数にとってそれらを結合したリストを返します。
引数は保存されます。

使用例：
  ;;; リストをくっつけてみる。
  (setq x '(a b c))
  (setq y '(d e f))
  (append x y)
  =>(a b c d e f)
  x
  =>(a b c)
  y
  =>(d e f)


■append-file
[       type]: Function
[  arguments]: append-file FILENAME &optional NOMSG CHAR-ENCODING EOL-CODE
[    package]: editor
[    seealso]: write-file
[       file]: files.l
[    section]: ファイルシステム
[description]: 
バッファの内容を FILENAME に追加書き込みします。
write-file で APPEND を non-nil にした場合と同じです。

  NOMSG         : non-nil ならステータスバーに経過メッセージを表示しません。
  CHAR-ENCODING : エンコーディングを指定します。
  EOL-CODE      : 改行コードを指定します。


■append-rectangle
[       type]: Function
[  arguments]: append-rectangle
[    package]: editor
[       file]: rectangl.l
[    section]: リージョン
[description]: 
コピーしている矩形の各行を現在行以下の行末へ追加します。

使用例：
  こんなのをコピーしているときに
          ┌────┐
          │A       │
          │BC      │
          │DEF     │
          │GHIJ    │
          └────┘
  * の位置で append-rectangle すると
   ┌─────┐      ┌─────┐
   │*-lmn     │      │--lmnA    │
   │--op      │  →  │--opBC    │
   │--        │      │--DEF     │
   │--q       │      │--qGHIJ   │
   └─────┘      └─────┘


■append-to-register
[       type]: Function
[  arguments]: append-to-register R START END &optional DELETE
[    package]: editor
[    seealso]: prepend-to-register
[   referred]: copy-to-register
[       file]: register.l
[    section]: リージョン
[description]: 
START と END で指定されるリージョンを、レジスタ R に格納されているテキ
ストの末尾へ追加します。 [C-x r a]
R にテキストが入っていないとエラーになります。
DELETE が non-nil ならば同時にリージョンをを削除します。


■append-trail-slash
[       type]: Function
[  arguments]: append-trail-slash STRING
[    package]: editor
[    seealso]: remove-trail-slash
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
文字列の末尾に"/"がなければ"/"を追加します。

使用例：
  (append-trail-slash "ffjfj")
  => "ffjfj/"
  (append-trail-slash "ffjfj/")
  => "ffjfj/"


■apply
[       type]: Function
[  arguments]: apply FUNCTION ARG &rest MORE-ARGS
[    package]: lisp
[    seealso]: funcall , multiple-value-call
[       file]: builtin.l
[    section]: 評価
[description]: 
引数を格納したリストを指定して関数を表すシンボルから関数を呼び出します。
FNには関数を表すシンボルでも関数でも構いません。引数の個数が必ず定まって
いる場合には、applyを使う必要は無くfuncallの方が良いと思います。

使用例：
  ;;; carをいろいろな呼び出し方でする。
  (car '(a b c))                => a
  (apply 'car '((a b c)))       => a
  (apply #'car '((a b c)))      => a


■apps-popup
[       type]: Function
[  arguments]: apps-popup
[    package]: editor
[    seealso]: mouse-menu-popup
[       file]: mouse.l
[    section]: メニュー
[description]: 
ポップアップメニューを表示します。[Apps]

メニューは、*app-popup-menu* に定義されたものが使用されます。


■apropos
[       type]: Function
[  arguments]: apropos STRING &optional PRINT-KEY PRED
[    package]: editor
[    seealso]: *apropos-no-regexp* , command-apropos
[       file]: help.l
[    section]: シンボル
[description]: 
指定した正規表現に一致するシンボルの一覧を表示します。

  STRING    : 検索する文字列
  PRINT-KEY : バインドされているキーを表示するかどうか
        non-nil : 表示する
        nil     : 表示しない
  PRED      : ？？？


■archiver-dll-config-dialog
[       type]: Function
[  arguments]: archiver-dll-config-dialog DLL &optional MODE
[    package]: editor
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
アーカイバの設定ダイアログを表示します。

  DLL  : 設定するアーカイバを指定します。
  MODE : （詳細不明）

使用例：
  (archiver-dll-config-dialog :unlha32)


■archiver-dll-version
[       type]: Function
[  arguments]: archiver-dll-version DLL
[    package]: editor
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
アーカイバのバージョンを取得します。

  DLL  : アーカイバを指定します。

使用例：
  (archiver-dll-version :unrar32)
  => "0.09"


■aref
[       type]: Accessor
[  arguments]: aref ARRAY &rest SUBSCRIPTS
[    package]: lisp
[    seealso]: make-array , setf , svref
[   referred]: row-major-aref , vector
[       file]: builtin.l
[    section]: 配列
[description]: 
SUBSCRIPTS で特定される配列の要素にアクセスします。SUBSCRIPTS がなく配列が
ゼロ次元の場合は、配列のただひとつの要素にアクセスします。
具体的な使い方については、以下の例を参照してください。

使用例：
  ;;; 2x2の初期化された配列を作ります。値の取得・変更を行います。
  (setf foo (make-array '(2 2) :initial-contents '((1 2) (3 4))))
  =>#2A((1 2) (3 4))
  (aref foo 1 1);配列fooの要素(1,1)の値を得る
  =>4
  (setf (aref foo 1 1) 10);配列fooの要素(1,1)の値を10にする
  =>10
  foo
  =>#2A((1 2) (3 10))


■array-dimension
[       type]: Function
[  arguments]: array-dimension ARRAY AXIS-NUMBER
[    package]: lisp
[    seealso]: array-dimensions , array-total-size
[       file]: array.l
[    section]: 配列
[description]: 
配列 ARRAY の AXIS-NUMBER 番目の次元のサイズを返します。
AXIS-NUMBER は 0 から始まる整数値です。
なお、フィルポインタを持っているベクタに関しても、本来のサイズを返します。

使用例:
  (setf x (make-array '(2 3)))
  => #2A((nil nil nil) (nil nil nil))
  (array-dimension x 0)
  => 2
  (array-dimension x 1)
  => 3

  ;; フィルポインタつきのベクタ
  (setf x (make-array 5 :initial-contents '(a b c d e) :fill-pointer 3))
  => #(a b c)
  (array-dimension x 0)
  => 5
  (length x) ; length だとフィルポインタまでの長さになる
  => 3


■array-dimensions
[       type]: Function
[  arguments]: array-dimensions ARRAY
[    package]: lisp
[    seealso]: array-dimension , array-total-size , make-array
[       file]: array.l
[    section]: 配列
[description]: 
配列 ARRAY の各次元のサイズをリストにして返します。

使用例:
  (setf x (make-array '(2 3)))
  => #2A((nil nil nil) (nil nil nil))
  (array-dimensions x)
  => (2 3)


■array-element-type
[       type]: Function
[  arguments]: array-element-type ARRAY
[    package]: lisp
[    seealso]: make-array
[       file]: builtin.l
[    section]: 配列
[description]: 
ARRAY の要素のタイプを判別します。
配列なら t、文字列なら character を返します。


■array-has-fill-pointer-p
[       type]: Function
[  arguments]: array-has-fill-pointer-p ARRAY
[    package]: lisp
[    seealso]: fill-pointer
[       file]: builtin.l
[    section]: 配列
[description]: 
配列 ARRAY がフィルポインタを持っているなら t、
持っていないなら nil を返します。


■array-rank
[       type]: Function
[  arguments]: array-rank ARRAY
[    package]: lisp
[    seealso]: make-array
[       file]: builtin.l
[    section]: 配列
[description]: 
配列 ARRAY の次元を返します。

使用例:
  (setf x (make-array '(2 3)))
  => #2A((nil nil nil) (nil nil nil))
  (array-rank x)
  => 2


■array-row-major-index
[       type]: Function
[  arguments]: array-row-major-index ARRAY &rest SUBSCRIPTS
[    package]: lisp
[    seealso]: row-major-aref
[       file]: builtin.l
[    section]: 配列
[description]: 
ARRAY の SUBSCRIPTS で表される要素が、ARRAY を一次元の配列とみなしたときに
何番目の要素にあたるかのインデックスを返します。

SUBSCRIPTS の数は ARRAY の次元と等しい必要があり、
また各引数は ARRAY の各次元のサイズ未満である必要があります。

使用例:
  (setf x (make-array '(2 3)))
  => #2A((nil nil nil) (nil nil nil))
  (array-row-major-index x 0 2)
  => 2
  (array-row-major-index x 1 1)
  => 4

  上の例はこんな感じです。

        0   1   2
     ┌─┬─┬─┐
   0 │ 0│ 1│ 2│
     ├─┼─┼─┤
   1 │ 3│ 4│ 5│
     └─┴─┴─┘


■array-total-size
[       type]: Function
[  arguments]: array-total-size ARRAY
[    package]: lisp
[    seealso]: array-dimension , array-dimensions
[       file]: builtin.l
[    section]: 配列
[description]: 
配列 ARRAY の全要素数を返します。

使用例:
  (setf x (make-array '(2 3)))
  => #2A((nil nil nil) (nil nil nil))
  (array-total-size x)
  => 6


■arrayp
[       type]: Function
[  arguments]: arrayp OBJECT
[    package]: lisp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECT が array なら t 、それ以外なら nil を返します。


■ash
[       type]: Function
[  arguments]: ash INTEGER COUNT
[    package]: lisp
[       file]: builtin.l
[    section]: 数値
[description]: 
整数をロジカルにシフトします。

  INTEGER : シフトする数値
  COUNT   : ビット数分だけ正ならば左に、負ならば右にシフト
  
例：
  ;;; 4を左と右に3ビットずつシフトさせてみる。
  (ash 4 3)
  => 32
  (ash 4 -3)
  => 0


■asin
[       type]: Function
[  arguments]: asin NUMBER
[    package]: lisp
[    seealso]: asinh
[       file]: builtin.l
[    section]: 数値
[description]: 
逆正弦関数の値を返します。


■asinh
[       type]: Function
[  arguments]: asinh Z
[    package]: lisp
[    seealso]: asin
[       file]: number.l
[    section]: 数値
[description]: 
逆双曲線正弦関数を計算します。


■assoc
[       type]: Function
[  arguments]: assoc ITEM A-LIST &key :test :test-not :key
[    package]: lisp
[    seealso]: assoc-if , assoc-if-not , rassoc
[       file]: builtin.l
[    section]: リスト
[description]: 
連想リスト A-LIST の中で car 部が ITEM との :test を満たす最初のペアを返します。

使用例：
  (assoc 'r '((a . b) (c . d) (r . x) (s . y) (r . z))) 
  =>  (r . x) 
  (assoc 'goo '((foo . bar) (zoo . goo)))
  => nil 
  (assoc '2 '((1 a b c) (2 b c d) (-7 x y z)))
  => (2 b c d)


■assoc-if
[       type]: Function
[  arguments]: assoc-if PREDICATE A-LIST &key :key
[    package]: lisp
[    seealso]: assoc , assoc-if-not
[       file]: builtin.l
[    section]: リスト
[description]: 
連想リスト A-LIST の中で car 部が PREDICATE を満たす最初のペアを返します。

使用例：
  (assoc-if #'numberp '((a . b) (1 . c) (2 . d)))
  => (1 . c)


■assoc-if-not
[       type]: Function
[  arguments]: assoc-if-not PREDICATE A-LIST &key :key
[    package]: lisp
[    seealso]: assoc , assoc-if
[       file]: builtin.l
[    section]: リスト
[description]: 
連想リスト A-LIST の中で car 部が PREDICATE を満たさない最初のペアを返します。

使用例：
  (assoc-if-not #'numberp '((a . b) (1 . c) (2 . d)))
  => (a . b)


■atan
[       type]: Function
[  arguments]: atan Y &optional X
[    package]: lisp
[    seealso]: atanh
[       file]: builtin.l
[    section]: 数値
[description]: 
逆正接関数の値を返します。


■atanh
[       type]: Function
[  arguments]: atanh Z
[    package]: lisp
[    seealso]: atan
[       file]: number.l
[    section]: 数値
[description]: 
逆双曲線正接関数を計算します。


■atom
[       type]: Function
[  arguments]: atom OBJECT
[    package]: lisp
[    seealso]: consp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTがconsでなければt、それ以外ならnilを返します。

  (atom x) == (typep x 'atom) == (not (typep x 'cons))

注意：(atom '()) は '() == nilなのでt


■auto-fill-hook
[       type]: Variable
[    package]: editor
[    seealso]: *auto-fill-hook
[   referred]: auto-fill-mode , fill-region-hook
[    section]: 変数と定数
[description]: 
入力の結果、fill-columnを越えたらdo-auto-fillから実行されます。


■auto-fill-mode
[       type]: Function
[  arguments]: auto-fill-mode &optional (ARG () SARG)
[    package]: editor
[    seealso]: fill-column , auto-fill-hook
[   referred]: *auto-fill-hook , set-fill-prefix
[       file]: fill.l
[    section]: テキスト
[description]: 
自動詰め込みモードの開始と終了をトグルします。


■auto-save
[       type]: BufferLocal
[    package]: editor
[    seealso]: setup-temp-buffer
[    section]: 変数と定数
[description]: 
自動保存を行うかを制御するためのフラグです。
個々のバッファ毎や特定のモードだけしたくないのであれば、使用例の様にロー
カル変数にします。

  t     自動保存する
  nil   自動保存しない

使用例：
  ;;; 現在のバッファは自動保存しないようにする。
  (make-local-variable 'auto-save)
  => t  
  (setq auto-save nil)
  => nil


■autoload
[       type]: Function
[  arguments]: autoload FN FILE &optional COMMANDP MACROP
[    package]: lisp
[    seealso]: mc-autoload , autoload-function-p , 各種ロード関係の関数の違い
[       file]: misc.l
[    section]: 関数
[description]: 
関数が呼び出された時点でファイルをロードするよう宣言します。

  FN       : 関数シンボルを指定します。
  FILE     : ロードするファイルを指定します。
  COMMANDP : 実行するときに interactive に実行するかどうかを指定します。
  MACROP   : マクロかどうかを指定します。

FN が既に関数として定義されている場合はなにもしません。
定義されていない場合は新たに関数を作って FN の一時的な定義とします。この
関数は初めて FN が呼ばれたときに実行され、指定されたファイル FILE から本
来呼び出されるべき FN の定義をロードします。もし FILE 中に FN の定義が存
在しなければエラーとなります。

関数を呼び出す側からは、元々そのファイルがロードされていたかのように実行
を続けます。めったに使わない関数を autoload で宣言しておくとメモリ消費
量を節約できます。また、起動時にファイルをロードしないので起動が速くなり
ます。

使用例：
  ;;; defs.lより
  (autoload 'search-dialog "dialogs" t)
  (autoload 'replace-dialog "dialogs" t)
  (autoload 'count-matches-dialog "dialogs" t)
  (autoload 'goto-line-dialog "dialogs" t)
  (autoload 'open-file-dialog "dialogs" t)


■autoload-function-p
[       type]: Function
[  arguments]: autoload-function-p DEF
[    package]: lisp
[    seealso]: autoload
[       file]: misc.l
[    section]: 関数
[description]: 
指定された関数がautoloadされたか否かを返します。
  nil 指定された関数がautoload済み
      もしくはautoloadしない関数の場合
  t   指定された関数がautoload前の場合

使用例：
  (export 'lisp-info-F1)
  (autoload 'lisp-info-F1 "info-modoki" t)
  (autoload-function-p 'lisp-info-F1)
  => t
  (lisp-info-F1)
  (autoload-function-p 'lisp-info-F1)
  => nil


■back-to-indentation
[       type]: Function
[  arguments]: back-to-indentation
[    package]: editor
[    seealso]: beginning-of-line
[       file]: cmds.l
[    section]: ポジション
[description]: 
カーソルをインデントの末尾（行の最初の空白でない文字）へ移動します。
[ESC m]


■backward-char
[       type]: Function
[  arguments]: backward-char &optional (N 1)
[    package]: editor
[    seealso]: forward-char
[   referred]: backward-word
[       file]: cmds.l
[    section]: ポジション
[description]: 
指定された文字数だけ後方に移動します。行頭ならば前行の終端に位置します。
[C-b], [Left]

互換性：
   Emacsではバッファの先頭ではエラーが発生します。xyzzyではエラーは発生
  しません。その代わり、動けたときは t、動けなければ nil を返します。


■backward-delete-char-untabify
[       type]: Function
[  arguments]: backward-delete-char-untabify &optional (ARG 1)
[    package]: editor
[    seealso]: delete-backward-char , backward-delete-char-untabify-or-selection , untabify
[       file]: cmds.l
[    section]: テキスト
[description]: 
カーソル後方の文字を指定文字数分だけ削除します。タブ文字を削除する際は、
適当な数の半角スペースに置き換えられてから削除されます。


■backward-delete-char-untabify-or-selection
[       type]: Function
[  arguments]: backward-delete-char-untabify-or-selection &optional (N 1)
[    package]: editor
[    seealso]: delete-backward-char , backward-delete-char-untabify
[       file]: cmds.l
[    section]: テキスト
[description]: 
セレクションで選択中ならばセレクション全体を、そうでなければカーソルの
後方の文字を指定文字数分だけ削除します。タブ文字を削除する際は、適当な
数の半角スペースに置き換えられてから削除されます。


■backward-kill-paragraph
[       type]: Function
[  arguments]: backward-kill-paragraph &optional (ARG 1)
[    package]: editor
[    seealso]: kill-paragraph , kill-region
[       file]: paragrph.l
[    section]: リージョン
[description]: 
現在のパラグラフの先頭までkillします。


■backward-kill-word
[       type]: Function
[  arguments]: backward-kill-word &optional (ARG 1)
[    package]: editor
[    seealso]: kill-word
[       file]: cmds.l
[    section]: リージョン
[description]: 
カーソル位置から後方の単語の先頭までを切り取り、キルリングに追加します。
[ESC C-h]
カーソルが単語の途中にある場合は、カーソル位置からその単語の先頭までが、
対象となります。


■backward-line
[       type]: Function
[  arguments]: backward-line &optional (N 1)
[    package]: editor
[    seealso]: forward-line
[       file]: cmds.l
[    section]: ポジション
[description]: 
N 行後方へ移動します。
移動の前後で goal-column を保存しません。

(backward-line n) と (forward-line (- n)) は同じです。


■backward-page
[       type]: Function
[  arguments]: backward-page &optional (ARG 1)
[    package]: editor
[    seealso]: forward-page
[   referred]: mark-page
[       file]: page.l
[    section]: ポジション
[description]: 
後方の改ページまで移動します。[C-x ]]
改ページが無い場合はバッファの先頭に移動します。
一般には制御文字のform feedが単独である行で改ページを表します。

  ARG : ページ数を指定します。デフォルトは 1 です。
        負の値の場合、逆向きに移動します。


■backward-paragraph
[       type]: Function
[  arguments]: backward-paragraph &optional (ARG 1)
[    package]: editor
[    seealso]: forward-paragraph
[       file]: paragrph.l
[    section]: ポジション
[description]: 
カーソルを段落の先頭に移動します。[ESC {]


■backward-sexp
[       type]: Function
[  arguments]: backward-sexp &optional (ARG 1) NOERROR
[    package]: editor
[    seealso]: forward-sexp , down-list
[       file]: sexp.l
[    section]: バッファ
[description]: 
lisp-modeでS式を1つ戻します。[ESC C-b]

使用例：
  (backward-sexp)


■backward-virtual-line
[       type]: Function
[  arguments]: backward-virtual-line &optional (N 1)
[    package]: editor
[    seealso]: forward-virtual-line
[       file]: cmds.l
[    section]: ポジション
[description]: 
表示行で N 行後方へ移動します。


■backward-word
[       type]: Function
[  arguments]: backward-word &optional (N 1)
[    package]: editor
[    seealso]: forward-word , backward-char
[   referred]: previous-word
[       file]: cmds.l
[    section]: ポジション
[description]: 
カーソルを後方の単語に移動します。[ESC b]


■base64-decode-region
[       type]: Function
[  arguments]: base64-decode-region FROM TO
[    package]: editor
[    seealso]: si:base64-encode , base64-decode-region-to-file
[       file]: encdec.l
[    section]: リージョン
[description]: 
リージョンをBase64デコードします。


■base64-decode-region-to-file
[       type]: Function
[  arguments]: base64-decode-region-to-file FILENAME FROM TO
[    package]: editor
[    seealso]: si:base64-decode , base64-decode-region
[       file]: encdec.l
[    section]: リージョン
[description]: 
リージョンをBase64デコードしてファイルに保存します。


■beginning-of-buffer
[       type]: Function
[  arguments]: beginning-of-buffer
[    package]: editor
[    seealso]: end-of-buffer , set-mark-command , selection-beginning-of-buffer
[       file]: cmds.l
[    section]: ポジション
[description]: 
カーソルをバッファの先頭に移動します。[ESC <]
元あったカーソル位置にはマークを設定します。

マークを変更しないためには
(goto-char (point-min))を使います。


■beginning-of-defun
[       type]: Function
[  arguments]: beginning-of-defun &optional (ARG 1)
[    package]: editor
[    seealso]: end-of-defun
[       file]: sexp.l
[    section]: 関数
[description]: 
カーソルを関数定義の先頭に移動します。[ESC C-a]


■beginning-of-line
[       type]: Function
[  arguments]: beginning-of-line
[    package]: editor
[    seealso]: end-of-line , back-to-indentation
[   referred]: selection-beginning-of-line
[       file]: cmds.l
[    section]: ポジション
[description]: 
行頭に移動します。goto-bolのinteractive版です。[C-a], [C-Left]


■beginning-of-virtual-line
[       type]: Function
[  arguments]: beginning-of-virtual-line
[    package]: editor
[    seealso]: goto-virtual-bol
[   referred]: selection-beginning-of-virtual-line
[       file]: cmds.l
[    section]: ポジション
[description]: 
表示行の行頭に移動します。
goto-virtual-bol の interactive 版です。


■block
[       type]: Special Form
[  arguments]: block NAME {FORM}*
[    package]: lisp
[    seealso]: return-from
[       file]: builtin.l
[    section]: 制御構造
[description]: 
フォームを順番に評価して最後のフォームの結果を返します。 
ほとんどprognですがreturn-fromやreturnで戻り値が指定できるところが違います。
returnやreturn-fromにぶつかったときには残りの式は評価しません。


■bobp
[       type]: Function
[  arguments]: bobp
[    package]: editor
[    seealso]: eobp
[       file]: builtin.l
[    section]: ポジション
[description]: 
ポイントがバッファの先頭にあるか否かを返します。
  t    ポイントがバッファの先頭にある。
  nil  ポイントがバッファの先頭にはない。


■bolp
[       type]: Function
[  arguments]: bolp
[    package]: editor
[    seealso]: eolp
[       file]: builtin.l
[    section]: ポジション
[description]: 
カーソルが行頭にあればt、そうでなければnilを返します。


■both-case-p
[       type]: Function
[  arguments]: both-case-p CHAR
[    package]: lisp
[    seealso]: lower-case-p , upper-case-p , alpha-char-p
[       file]: builtin.l
[    section]: 文字
[description]: 
CHAR が大文字小文字のある文字なら t 、そうでなければ nil を返します。

使用例：  
  (both-case-p #\a)
  => t
  (both-case-p #\A)
  => t
  (both-case-p #\RET)
  => nil


■boundp
[       type]: Function
[  arguments]: boundp SYMBOL
[    package]: lisp
[    seealso]: fboundp , macro-function , makunbound
[       file]: builtin.l
[    section]: シンボル
[description]: 
シンボルに値が設定されているかどうかを返します。

使用例：
  (boundp 'test)          => nil
  (defvar test "string")  => test
  (boundp 'test)          => t


■broadcast-stream-streams
[       type]: Function
[  arguments]: broadcast-stream-streams BROADCAST-STREAM
[    package]: lisp
[    seealso]: make-broadcast-stream
[       file]: builtin.l
[    section]: 入出力
[description]: 
make-broadcast-streamで作られたBROADCAST-STREAMの出力先のストリームのリ
ストを返します。

使用例：
  ;;; hogeの出力先をリストで得る。
  (with-open-stream (foo (open "foo.txt" :direction :output))
    (with-open-stream (bar (open "bar.txt" :direction :output))
      (with-open-stream (hoge (make-broadcast-stream foo bar))
        (broadcast-stream-streams hoge))))
  => (#<file-output stream: C:/applications/xyzzy/foo.txt>
      #<file-output stream: C:/applications/xyzzy/bar.txt>)


■buffer-can-redo-p
[       type]: Function
[  arguments]: buffer-can-redo-p BUFFER
[    package]: editor
[    seealso]: redo
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファがredo可能な状態ならt、そうでなければnilを返します。


■buffer-can-undo-p
[       type]: Function
[  arguments]: buffer-can-undo-p BUFFER
[    package]: editor
[    seealso]: undo
[       file]: builtin.l
[    section]: バッファ
[description]: 
bufferがundo可能ならt、そうでなければnilを返します。


■buffer-eol-code
[       type]: Function
[  arguments]: buffer-eol-code &optional BUFFER
[    package]: editor
[    seealso]: set-buffer-eol-code , *default-eol-code*
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファの改行コードを返します。変更する場合はset-buffer-eol-codeを使用
します。

 BUFFER: 改行コードを返すバッファ
         指定が無ければ現在のバッファ

戻り値:
  0  *eol-lf*   LF
  1  *eol-cr*   CR
  2  *eol-crlf* CRLF


■buffer-fileio-encoding
[       type]: Function
[  arguments]: buffer-fileio-encoding &optional BUFFER
[    package]: editor
[    seealso]: set-buffer-fileio-encoding , *default-fileio-encoding*
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファの文字エンコーディングを返します。変更する場合には、
set-buffer-fileio-encodingを使用します。

使用例：
  (buffer-fileio-encoding)
  => #.(make-iso2022-encoding "jis" ... )

参照：
  kanji.l


■buffer-fold-width
[       type]: Function
[  arguments]: buffer-fold-width &optional BUFFER
[    package]: editor
[    seealso]: default-fold-width , set-buffer-fold-width
[       file]: builtin.l
[    section]: テキスト
[description]: 
折り返しの状態を返します。

  BUFFER : 状態を取得するバッファ

戻り値は以下のとおりです。

  t    ウィンドウ幅で折り返す
  nil  折り返しをしない
  数値 その幅で折り返しをします。

多値で返ってきている t の意味は不明です。


■buffer-lines
[       type]: Function
[  arguments]: buffer-lines &optional BUFFER
[    package]: editor
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファの物理行数を返します。

使用例：  
  (buffer-lines)
  => 5014


■buffer-list
[       type]: Function
[  arguments]: buffer-list &key :buffer-bar-order
[    package]: editor
[    seealso]: enum-buffers
[   referred]: get-next-buffer
[       file]: builtin.l
[    section]: バッファ
[description]: 
全バッファをリストで返します。

使用例:
  (buffer-list)
  =>(#<buffer:  *Minibuf0*> #<buffer: *grep*> #<buffer: *scratch*> #<buffer: *untitled*> #<buffer: addref.xml> #<buffer: reference.xml>)
  
  (buffer-list :buffer-bar-order t)
  =>(#<buffer: *scratch*> #<buffer: reference.xml> #<buffer: *untitled*> #<buffer: addref.xml> #<buffer: *grep*> #<buffer:  *Minibuf0*>)
  
  ;;ミニバッファの名前はスペースで始まる点に注意
  (mapcar #'buffer-name (buffer-list))
  =>(" *Minibuf0*" "*grep*" "*scratch*" "*untitled*" "addref.xml" "reference.xml")


■buffer-local-value
[       type]: Function
[  arguments]: buffer-local-value BUFFER SYMBOL
[    package]: editor
[    seealso]: symbol-value , make-local-variable , defvar-local
[       file]: builtin.l
[    section]: バッファ
[description]: 
指定されたバッファのローカル変数の値を返します。

  BUFFER : ローカルな値を取得したいバッファ
  SYMBOL : ローカル変数

使用例：
  (buffer-local-value (selected-buffer) 'mode-name)
  => "xmldoc"


■buffer-menu
[       type]: Function
[  arguments]: buffer-menu
[    package]: editor
[   referred]: select-buffer
[       file]: buf-menu.l
[    section]: バッファ
[description]: 
バッファ一覧を表示します。
一覧の中ではバッファの選択、削除などができます。


■buffer-mode
[       type]: BufferLocal
[    package]: editor
[    seealso]: mode-name
[    section]: バッファ
[description]: 
カレントバッファのモードを格納しています。

使用例：
  ;;; list-interaction-modeの場合
  buffer-mode
  => lisp-interaction-mode


■buffer-modified-count
[       type]: Function
[  arguments]: buffer-modified-count &optional BUFFER
[    package]: editor
[    seealso]: buffer-modified-p
[       file]: builtin.l
[    section]: バッファ
[description]: 
（バッファが修正されたカウント数？）


■buffer-modified-p
[       type]: Function
[  arguments]: buffer-modified-p &optional BUFFER
[    package]: editor
[    seealso]: set-buffer-modified-p , buffer-modified-count
[   referred]: save-buffer
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファ BUFFER が変更を加えられているかどうかを返します。
バッファが変更されていない時は nil を、変更されている時はバッファの編集
回数(buffer-modified-count の値)を返します。
BUFFER が指定されない、もしくは nil が指定された時はカレントバッファの結
果を返します。


■buffer-name
[       type]: Function
[  arguments]: buffer-name BUFFER
[    package]: editor
[    seealso]: create-new-buffer , get-buffer-create , rename-buffer , find-name-buffer
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファの名前を返します。

  BUFFER : 名前を返すバッファを指定します。

使用例：
  ;;; カレントバッファの名前を返します。
  (buffer-name (selected-buffer))
  => "reference.xml"


■buffer-process
[       type]: Function
[  arguments]: buffer-process BUFFER
[    package]: editor
[    seealso]: make-process
[   referred]: process-buffer
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファに結び付けられているプロセスを返します。
プロセスはmake-processで作成します。


■buffer-read-only
[       type]: BufferLocal
[    package]: editor
[    seealso]: toggle-read-only , setup-temp-buffer
[   referred]: ed::find-file-internal
[    section]: 変数と定数
[description]: 
バッファが読み取り専用かどうかを管理します。

  t     バッファは読み取り専用
  nil   バッファは読み書き可能


■buffer-selector
[       type]: Function
[  arguments]: buffer-selector
[    package]: editor
[    seealso]: select-buffer
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファ選択ウィンドウを表示します。
バッファ選択されればそのバッファを、そうでなければnilを返します。


■buffer-size
[       type]: Function
[  arguments]: buffer-size &optional BUFFER
[    package]: editor
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファのサイズを返します。2バイト文字があるので buffer-size の返す値と
ファイルサイズは一致しません。

使用例：
  (buffer-size)
  => 200170


■buffer-stream-buffer
[       type]: Function
[  arguments]: buffer-stream-buffer STREAM
[    package]: editor
[    seealso]: make-buffer-stream , buffer-stream-point , xyzzyで提供されているストリームの種類
[       file]: builtin.l
[    section]: 入出力
[description]: 
buffer-streamであるストリームが関連付けられているバッファを返します。

  STREAM : buffer-streamであるストリームを指定します。


■buffer-stream-p
[       type]: Function
[  arguments]: buffer-stream-p STREAM
[    package]: editor
[    seealso]: make-buffer-stream , xyzzyで提供されているストリームの種類
[       file]: builtin.l
[    section]: 入出力
[description]: 
ストリームがbuffer-streamかどうかを返します。

  STREAM : 判定するストリーム

  t   ストリームはbuffer-streamである。
  nil ストリームはbuffer-streamではない。


■buffer-stream-point
[       type]: Function
[  arguments]: buffer-stream-point STREAM
[    package]: editor
[    seealso]: buffer-stream-set-point , buffer-stream-buffer , file-position , make-buffer-stream , read , xyzzyで提供されているストリームの種類
[       file]: builtin.l
[    section]: 入出力
[description]: 
buffer-streamであるストリームの入出力のポイントを返します。

  STREAM : buffer-streamであるストリームを指定します。


■buffer-stream-set-point
[       type]: Function
[  arguments]: buffer-stream-set-point STREAM POINT
[    package]: editor
[    seealso]: buffer-stream-point , xyzzyで提供されているストリームの種類
[   referred]: file-position , make-buffer-stream
[       file]: builtin.l
[    section]: 入出力
[description]: 
buffer-streamであるストリームの入出力のポイントを指定します。

  STREAM : buffer-streamであるストリームを指定します。
  POINT  : buffer-stream上の入出力のポイントを指定します。

参考：
  misc.lの with-output-to-buffer とか with-input-from-buffer


■buffer-substring
[       type]: Function
[  arguments]: buffer-substring FROM TO
[    package]: editor
[    seealso]: substring
[       file]: builtin.l
[    section]: 文字列
[description]: 
バッファの指定された範囲の文字列を返します。


■bufferp
[       type]: Function
[  arguments]: bufferp OBJECT
[    package]: editor
[       file]: builtin.l
[    section]: バッファ
[description]: 
OBJECTがバッファならばt、そうでないならnilを返します。


■bury-buffer
[       type]: Function
[  arguments]: bury-buffer &optional BUFFER
[    package]: editor
[    seealso]: other-buffer
[       file]: builtin.l
[    section]: バッファ
[description]: 
other-bufferの候補の最後にします。


■butlast
[       type]: Function
[  arguments]: butlast LIST &optional (N 1)
[    package]: lisp
[    seealso]: nbutlast , last , subseq
[       file]: list.l
[    section]: リスト
[description]: 
リストの最後のN要素分を除いたリストを返します。
引数 LIST は保存されます。

使用例：
  ;;; 最後の要素を取り除く。
  (butlast '(1 2 3))
  => (1 2) 
  ;;; 最後の2要素を取り除く。
  (butlast '(1 2 3) 2)
  => (1) 


■byte
[       type]: Function
[  arguments]: byte SIZE POSITION
[    package]: lisp
[    seealso]: dpb , ldb , byte-position , byte-size
[       file]: number.l
[    section]: 数値
[description]: 
byte specifier を作ります。
「0 を基底として POSITION ビット目から始まる SIZE ビット」
を表すオブジェクトを返します。

内部的には cons と同じです。


■byte-position
[       type]: Function
[  arguments]: byte-position BYTESPEC
[    package]: lisp
[    seealso]: byte
[       file]: number.l
[    section]: 数値
[description]: 
byte specifier の位置を返します。

内部的には cdr と同じです。


■byte-size
[       type]: Function
[  arguments]: byte-size BYTESPEC
[    package]: lisp
[    seealso]: byte
[       file]: number.l
[    section]: 数値
[description]: 
byte specifier のサイズを返します。

内部的には car と同じです。


■caaaar
[       type]: Function
[  arguments]: caaaar X
[    package]: lisp
[    seealso]: car
[       file]: list.l
[    section]: リスト
[description]: 
caaaar を返します。

  (caaaar X) = (car (car (car (car X))))


■caaadr
[       type]: Function
[  arguments]: caaadr X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
caaadr を返します。

  (caaadr X) = (car (car (car (cdr X))))


■caaar
[       type]: Function
[  arguments]: caaar X
[    package]: lisp
[    seealso]: car
[       file]: list.l
[    section]: リスト
[description]: 
caaar を返します。

  (caaar X) = (car (car (car X)))


■caadar
[       type]: Function
[  arguments]: caadar X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
caadar を返します。

  (caadar X) = (car (car (cdr (car X))))


■caaddr
[       type]: Function
[  arguments]: caaddr X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
caaddr を返します。

  (caaddr X) = (car (car (cdr (cdr X))))


■caadr
[       type]: Function
[  arguments]: caadr X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
caadr を返します。

  (caadr X) = (car (car (cdr X)))


■caar
[       type]: Function
[  arguments]: caar X
[    package]: lisp
[    seealso]: car
[       file]: list.l
[    section]: リスト
[description]: 
caar を返します。

  (caar X) = (car (car X))


■cadaar
[       type]: Function
[  arguments]: cadaar X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
cadaar を返します。

  (cadaar X) = (car (cdr (car (car X))))


■cadadr
[       type]: Function
[  arguments]: cadadr X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
cadadr を返します。

  (cadadr X) = (car (cdr (car (cdr X))))


■cadar
[       type]: Function
[  arguments]: cadar X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
cadar を返します。

  (cadar X) = (car (cdr (car X)))


■caddar
[       type]: Function
[  arguments]: caddar X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
caddar を返します。

  (caddar X) = (car (cdr (cdr (car X))))


■cadddr
[       type]: Function
[  arguments]: cadddr X
[    package]: lisp
[    seealso]: car , cdr , fourth
[       file]: list.l
[    section]: リスト
[description]: 
cadddr を返します。

  (cadddr X) = (car (cdr (cdr (cdr X))))


■caddr
[       type]: Function
[  arguments]: caddr X
[    package]: lisp
[    seealso]: car , cdr , third
[       file]: list.l
[    section]: リスト
[description]: 
caddr を返します。

  (caddr X) = (car (cdr (cdr X)))


■cadr
[       type]: Function
[  arguments]: cadr X
[    package]: lisp
[    seealso]: car , cdr , second
[       file]: list.l
[    section]: リスト
[description]: 
cadr を返します。

  (cadr X) = (car (cdr X))


■calendar
[       type]: Function
[  arguments]: calendar &optional YEAR
[    package]: editor
[       file]: calendar.l
[    section]: 日付・時間
[description]: 
YEARにより指定された年のカレンダーを表示します。当日には下線が、
祝祭日には色が付いています。マウスをこれらの上に移動すると、休日
の内容がポップアップ表示されます。


■call-arguments-limit
[       type]: Variable
[    package]: lisp
[    seealso]: lambda-parameters-limit
[    section]: 変数と定数
[description]: 
関数に与えることのできる引数の個数の限界値

参照例： 
  call-arguments-limit
  => 536870911


■call-interactively
[       type]: Function
[  arguments]: call-interactively COMMAND &optional HOOK
[    package]: editor
[    seealso]: command-execute
[       file]: misc.l
[    section]: 評価
[description]: 
指定された関数をinteractiveに呼び出したかのごとく実行します。

  COMMAND : interactiveに呼び出す関数を指定します。
            (interactive ...)として宣言された関数でなければなりません。

使用例：
  ;;; find-fileを無引数で呼び出してもエラーになる。
  (find-file)
  => 引数が少なすぎます: (find-file)

  ;;; interactiveに呼び出すと大丈夫
  (call-interactively 'find-file)
  => Find file: C:/applications/xyzzy/


■call-last-kbd-macro
[       type]: Function
[  arguments]: call-last-kbd-macro &optional (ARG 1)
[    package]: editor
[    seealso]: command-execute
[       file]: kbdmacro.l
[    section]: マクロ
[description]: 
start-kbd-macro/end-kbd-macroで登録したキーボードマクロを実行します。
[C-x e]
[ツール(T)]-[キーボードマクロおまけ(O)]-[保存]したキーボードマクロは、
[ツール(T)]-[キーボードマクロおまけ(O)]-[読み込み]で後から選択することが可能です。


■call-menu
[       type]: Function
[  arguments]: call-menu N
[    package]: editor
[       file]: builtin.l
[    section]: メニュー
[description]: 
「ファイル(F)」「編集(E)」といったメニューの N 番目の項目を開きます。
N には 0 オリジンで位置を指定します。
すなわち 0 を指定したときは通常「ファイル(F)」のメニューを開きます。


■call-process
[       type]: Function
[  arguments]: call-process COMMAND-LINE &key :environ :no-std-handles :input :output :error :exec-directory :show :wait
[    package]: editor
[    seealso]: execute-shell-command , make-process
[   referred]: filter-region
[       file]: builtin.l
[    section]: プロセス
[description]: 
外部プログラムを実行します。完全にxyzzyの外部でプログラムを実行します。

  COMMAND-LINE    : 実行するコマンドをオプション付で指定します。
  :environ        : 設定する環境変数を連想リスト形式で渡します。
                    (("HOME" . "C:/applications/xyzzy/")
                     ("TOPDIR" . "C:/spool/"))
  :no-std-handles : t の場合， :input :output :error の指定を無視します．
  :input          : 標準入力を使用する外部プログラムであれば入力ファイル名
                    を指定します。
  :output         : 標準出力を使用する外部プログラムであれば出力ファイル名
                    を指定します。
  :error          : 標準エラー出力を使用する外部プログラムであれば出力ファ
                    イル名を指定します．指定しないときは，標準出力に出力し
                    ます．
  :exec-directory : 実行するディレクトリを指定します。
  :show           : 外部プログラムの実行時の表示を指定します。
                    :show      通常のウィンドウ
                    :no-active 非アクティブ
                    :minimize  最小化
                    :maximize  最大化
                    :hide      非表示
                    上記以外   通常のウィンドウ
  :wait           : 外部プログラムが終了するのを待ち合わせます。

実行したプロセスを取得したいときは make-process を使います．

使用例：
  ;;; notepad.exeの終了を待ち合わせてみる。
  (call-process "notepad" :wait t)


■capitalize-region
[       type]: Function
[  arguments]: capitalize-region FROM TO
[    package]: editor
[    seealso]: downcase-region , upcase-region
[   referred]: capitalize-word
[       file]: builtin.l
[    section]: リージョン
[description]: 
リージョン内の単語をcapitalizeします。
つまり、単語の先頭を大文字に、それ以外を小文字にします。


■capitalize-word
[       type]: Function
[  arguments]: capitalize-word &optional (ARG 1)
[    package]: editor
[    seealso]: upcase-word , downcase-word , capitalize-region , capitalize-selection , forward-word
[       file]: cmds.l
[    section]: 文字列
[description]: 
前方の単語の先頭の文字を大文字に、それ以外の文字を小文字に変換します。
[ESC c]
カーソルが単語の途中にある場合は、カーソル位置の文字を大文字に、それ以
降の文字を小文字に変換します。


■car
[       type]: Function
[  arguments]: car LIST
[    package]: lisp
[    seealso]: first , safe-car
[   referred]: caaaar , caaadr , caaar , caadar , caaddr , caadr , caar , cadaar , cadadr , cadar , caddar , cadddr , caddr , cadr , cdaaar , cdaadr , cdaar , cdadar , cdaddr , cdadr , cdar , cddaar , cddadr , cddar , cdddar
[       file]: builtin.l
[    section]: リスト
[description]: 
リストの最初の要素を返します。

コンスセル LIST の最初のポインタを返します。 LIST が nil の場合 car は 
nil を返すよう、定義されています。引数がリストでない場合、エラーになります
引数がリスト以外でもエラーになって欲しくない場合には、safe-car を使用します。

使用例：
  (car '(a b c))
  => a
  (car '())
  => nil
  (car "string")
  => 不正なデータ型です: "string": cons


■case
[       type]: Macro
[  arguments]: case KEYFORM &rest FORMS
[    package]: lisp
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
C言語のswitch文みたいなのです。

(case <キー>
  (<リスト1> <式>〜<式>)
  (<リスト2> <式>〜<式>)
       ...
  (<リストn> <式>〜<式>))

まず<キー>を評価し，それが<リスト>のどれかの要素と一致すれば，
その<リスト>に続く式を順に評価して，最後の式の値をcaseの値として返
す。どの<リスト>のどの要素にも一致しなければcaseの値はnilである。
ただし例外として，最後のリスト(<リストn>)がtであれば，「どれにも一
致しなければ」を意味する。

<リスト1>〜<リストn>までは，それぞれデータのリストで，これら
は評価されない。すなわち値がリストになる式ではなく，リストそのものがここ
に入る。要素が一つだけの場合は，リストの代わりに要素がここにきてもいい。

使用例：
  ;;; 4を入力して場合分けさせる
  (setq x 4)
  => 4
  (case x
    (1 'one)
    (2 'two)
    (3 'three)
    ((4 5) 'four_or_five)
    (t 'large))
  => four_or_five


■catch
[       type]: Special Form
[  arguments]: catch TAG {FORM}*
[    package]: lisp
[    seealso]: throw
[       file]: builtin.l
[    section]: 制御構造
[description]: 
throwを投げるためのラベルを設定します。
C++のtryに相当します。

  C++  : try    throw
  Lisp : catch  throw

参考：
  エラー処理関連


■cd
[       type]: Function
[  arguments]: cd DIRECTORY
[    package]: editor
[    seealso]: set-default-directory
[       file]: misc.l
[    section]: ファイルシステム
[description]: 
バッファが作業しているディレクトリをインタラクティブに変更します。


■cdaaar
[       type]: Function
[  arguments]: cdaaar X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
cdaaar を返します。

  (cdaaar X) = (cdr (car (car (car X))))


■cdaadr
[       type]: Function
[  arguments]: cdaadr X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
cdaadr を返します。

  (cdaadr X) = (cdr (car (car (cdr X))))


■cdaar
[       type]: Function
[  arguments]: cdaar X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
cdaar を返します。

  (cdaar X) = (cdr (car (car X)))


■cdadar
[       type]: Function
[  arguments]: cdadar X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
cdadar を返します。

  (cdadar X) = (cdr (car (cdr (car X))))


■cdaddr
[       type]: Function
[  arguments]: cdaddr X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
cdaddr を返します。

  (cdaddr X) = (cdr (car (cdr (cdr X))))


■cdadr
[       type]: Function
[  arguments]: cdadr X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
cdadr を返します。

  (cdadr X) = (cdr (car (cdr X)))


■cdar
[       type]: Function
[  arguments]: cdar X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
cdar を返します。

  (cdar X) = (cdr (car X))


■cddaar
[       type]: Function
[  arguments]: cddaar X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
cddaar を返します。

  (cddaar X) = (cdr (cdr (car (car X))))


■cddadr
[       type]: Function
[  arguments]: cddadr X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
cddadr を返します。

  (cddadr X) = (cdr (cdr (car (cdr X))))


■cddar
[       type]: Function
[  arguments]: cddar X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
cddar を返します。

  (cddar X) = (cdr (cdr (car X)))


■cdddar
[       type]: Function
[  arguments]: cdddar X
[    package]: lisp
[    seealso]: car , cdr
[       file]: list.l
[    section]: リスト
[description]: 
cdddar を返します。

  (cdddar X) = (cdr (cdr (cdr (car X))))


■cddddr
[       type]: Function
[  arguments]: cddddr X
[    package]: lisp
[    seealso]: cdr
[       file]: list.l
[    section]: リスト
[description]: 
cddddr を返します。

  (cddddr X) = (cdr (cdr (cdr (cdr X))))


■cdddr
[       type]: Function
[  arguments]: cdddr X
[    package]: lisp
[    seealso]: cdr
[       file]: list.l
[    section]: リスト
[description]: 
cdddr を返します。

  (cdddr X) = (cdr (cdr (cdr X)))


■cddr
[       type]: Function
[  arguments]: cddr X
[    package]: lisp
[    seealso]: cdr
[       file]: list.l
[    section]: リスト
[description]: 
cddr を返します。

  (cddr X) = (cdr (cdr X))


■cdr
[       type]: Function
[  arguments]: cdr LIST
[    package]: lisp
[   referred]: caaadr , caadar , caaddr , caadr , cadaar , cadadr , cadar , caddar , cadddr , caddr , cadr , cdaaar , cdaadr , cdaar , cdadar , cdaddr , cdadr , cdar , cddaar , cddadr , cddar , cdddar , cddddr , cdddr , cddr , rest , safe-cdr
[       file]: builtin.l
[    section]: リスト
[description]: 
リストの二番目以降をリストで返します。

コンスセル LIST の 2 番目のポインタを返します。 LIST が nil の場合 cdr 
は nil を返すよう、定義されています。引数がリストでない場合、エラーにな
ります。引数がリスト以外でもエラーになって欲しくない場合には、safe-cdrを
使用します。

使用例：
  (cdr '(a b c))
  => (b c)
  (cdr '())
  => nil
  (cdr "string")
  => 不正なデータ型です: "string": cons


■ceiling
[       type]: Function
[  arguments]: NUMBER &optional DIVISOR
[    package]: lisp
[    seealso]: floor , truncate , round , fceiling
[       file]: builtin.l
[    section]: 数値
[description]: 
NUMBERを正の無限大方向に丸めます。
DIVISORを省略した場合にはNUMBER以上の最小の整数になります。

使用例：  
  (ceiling 2.2)
  => 3
  (ceiling 2.8)
  => 3
  (ceiling -2.2)
  => -2  
  (multiple-value-list (ceiling 2.2))
  => (3 -0.8)


■char
[       type]: Function
[  arguments]: char STRING INDEX
[    package]: lisp
[    seealso]: schar
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRINGのINDEX番目の文字を返します。
INDEXは0を基底とします。

使用例：
  ;;; 先頭から最後まで取得する。
  (char "foo" -1) => 範囲外の値です: -1
  (char "foo" 0)  => #\f
  (char "foo" 1)  => #\o
  (char "foo" 2)  => #\o
  (char "foo" 3)  => 範囲外の値です: 3


■char-after
[       type]: Function
[  arguments]: char-after POINT &optional NOT-USED
[    package]: editor
[    seealso]: following-char , char-before
[       file]: builtin.l
[    section]: 文字
[description]: 
カレントバッファの POINT 位置の文字を返します。
(point-min)以下の値が指定された場合(point-min)の文字を返す。
(point-max)以上の値が指定された場合 #\NUL を返す。

  POINT    : INTEGER か MARKER でポイントを指定
  NOT-USED : 不使用

戻り値：
  文字

使用例：
  ;;; ポイント c の位置で ESC ESC (char-after (point)) した場合
  abcdefg
    ^ このポイントで ESC ESC (char-after (point)) => #\c


■char-before
[       type]: Function
[  arguments]: char-before POINT &optional NOT-USED
[    package]: editor
[    seealso]: char-after , preceding-char
[       file]: builtin.l
[    section]: 文字
[description]: 
カレントバッファの POINT の前の位置の文字を返します。
(point-max)以上の値が指定された場合(point-max)の前の位置の文字を返す。
(point-min)以下の値が指定された場合 #\NUL を返す。

  POINT    : INTEGER か MARKER でポイントを指定
  NOT-USED : 不使用

戻り値:
  文字

使用例：
  ;;; ポイント c の位置で ESC ESC (char-before (point)) した場合
  abcdefg
    ^ このポイントで ESC ESC (char-before (point)) => #\b


■char-code
[       type]: Function
[  arguments]: char-code CHAR
[    package]: lisp
[    seealso]: code-char , char-unicode , unicode-char , iso-code-char
[       file]: builtin.l
[    section]: 文字
[description]: 
CHAR の文字コードを返します。
文字コードとキャラクタの間の相互変換には、code-charを使います。

使用例：
  (char-code #\a)
  => 97
  (code-char (char-code #\a))
  => #\a


■char-code-limit
[       type]: Variable
[    package]: lisp
[    seealso]: *character-name-hash-table* , make-character-name-hash-table
[    section]: 変数と定数
[description]: 
文字コードの限界値を定めている定数(65536)です。
*character-name-hash-table* を設定する
(make-character-name-hash-table) 関数の定義中でのみ使用されています。
xyzzy ソース内で定義されています。


■char-columns
[       type]: Function
[  arguments]: char-columns CHAR
[    package]: editor
[    seealso]: count-column , current-line-columns , *unicode-to-half-width*
[       file]: builtin.l
[    section]: 文字
[description]: 
文字 CHAR の文字幅を返します。

使用例：
  (char-columns #\a)        => 1
  (char-columns #\あ)       => 2
  (char-columns #\asterisk) => 1
  ;;; UNICODE 半角表示時
  (setq *unicode-to-half-width* t)   => t
  (char-columns (unicode-char 180))  => 1
  ;;; UNICODE 全角表示時
  (setq *unicode-to-half-width* nil) => nil
  (char-columns (unicode-char 180))  => 2


■char-downcase
[       type]: Function
[  arguments]: char-downcase CHAR
[    package]: lisp
[    seealso]: char-upcase , lower-case-p , string-downcase
[       file]: builtin.l
[    section]: 文字
[description]: 
CHARを小文字にして返します。

使用例：  
  (char-downcase #\A)
  => #\a


■char-equal
[       type]: Function
[  arguments]: char-equal CHARACTER &rest MORE-CHARACTERS
[    package]: lisp
[    seealso]: equalp , char=
[       file]: builtin.l
[    section]: 文字
[description]: 
引数がすべて大文字小文字関係なく等しければt、そうでなければnilを返します。

使用例：  
  (char-equal #\A #\a)
  => t


■char-greaterp
[       type]: Function
[  arguments]: char-greaterp CHARACTER &rest MORE-CHARACTERS
[    package]: lisp
[    seealso]: char>
[       file]: builtin.l
[    section]: 文字
[description]: 
引数の文字が全て大文字小文字関係なく降順ならt、そうでなければnilを返します。

使用例：
  (char-greaterp #\c #\b #\a)
  => t
  (char-greaterp #\c #\b #\b)
  => nil
  (char-greaterp #\b #\A)
  => t
  (char-greaterp #\B #\a)
  => t


■char-lessp
[       type]: Function
[  arguments]: char-lessp CHARACTER &rest MORE-CHARACTERS
[    package]: lisp
[    seealso]: char<
[       file]: builtin.l
[    section]: 文字
[description]: 
引数の文字が全て大文字小文字関係なく昇順ならt、そうでなければnilを返します。

使用例：  
  (char-lessp #\a #\b #\c)
  => t
  (char-lessp #\a #\b #\b)
  => nil
  (char-lessp #\A #\b)
  => t
  (char-lessp #\a #\B)
  => t


■char-name
[       type]: Function
[  arguments]: char-name C
[    package]: editor
[       file]: misc.l
[    section]: 文字
[description]: 
文字の英字名称を返します。
この英字名称はどこで定義されたものなのでしょうか？

使用例：
  ;;; いろいろと英字名称を見てみる。
  (char-name #\x00)     => "null"
  (char-name #\x0a)     => "line_feed"
  (char-name #\x0d)     => "carriage_return"
  (char-name #\a)       => "latin_small_letter_a"
  (char-name #\が)      => "hiragana_letter_ga"
  (char-name #\ヲ)      => "katakana_letter_wo"
  (char-name #\漢)      => nil 


■char-not-equal
[       type]: Function
[  arguments]: char-not-equal CHARACTER &rest MORE-CHARACTERS
[    package]: lisp
[    seealso]: char/=
[       file]: builtin.l
[    section]: 文字
[description]: 
引数がすべて大文字小文字関係なく等しくなければt、そうでなければnilを返します。

使用例：
  (char-not-equal #\a #\b #\c)
  => t
  (char-not-equal #\a #\A)
  => nil


■char-not-greaterp
[       type]: Function
[  arguments]: char-not-greaterp CHARACTER &rest MORE-CHARACTERS
[    package]: lisp
[    seealso]: char<=
[       file]: builtin.l
[    section]: 文字
[description]: 
引数の文字が全て大文字小文字関係なく昇順か等しければt、そうでなければnil
を返します。

使用例：  
  (char-not-greaterp #\a #\B #\c)
  => t


■char-not-lessp
[       type]: Function
[  arguments]: char-not-lessp CHARACTER &rest MORE-CHARACTERS
[    package]: lisp
[    seealso]: char>=
[       file]: builtin.l
[    section]: 文字
[description]: 
引数の文字が全て大文字小文字関係なく降順か等しければt、そうでなければnil
を返します。

使用例：  
  (char-not-lessp #\c #\B #\a)
  => t


■char-unicode
[       type]: Function
[  arguments]: char-unicode CHAR
[    package]: editor
[    seealso]: unicode-char , char-code
[   referred]: code-char
[       file]: builtin.l
[    section]: 文字
[description]: 
文字のUNICODEのコード値を返します。

使用例：
  ;;; UNICODEのコード値を取得してみる。
  (char-unicode #\x00)  => 0
  (char-unicode #\a)    => 97
  (char-unicode #\漢)   => 28450


■char-upcase
[       type]: Function
[  arguments]: char-upcase CHAR
[    package]: lisp
[    seealso]: char-downcase , upper-case-p , string-upcase
[       file]: builtin.l
[    section]: 文字
[description]: 
CHARを大文字にして返します。

使用例：  
  (char-upcase #\x)
  => #\X


■char/=
[       type]: Function
[  arguments]: char/= CHARACTER &rest MORE-CHARACTERS
[    package]: lisp
[    seealso]: char-not-equal
[       file]: builtin.l
[    section]: 文字
[description]: 
引数の文字が全て等しくなければt、そうでなければnilを返します。

使用例：  
  (char/= #\a #\b #\c)
  => t
  (char/= #\a #\b #\a)
  => nil
  (char/= #\a #\A)
  => t


■char<
[       type]: Function
[  arguments]: char< CHARACTER &rest MORE-CHARACTERS
[    package]: lisp
[    seealso]: char-lessp
[       file]: builtin.l
[    section]: 文字
[description]: 
引数の文字が全て昇順ならt、そうでなければnilを返します。

使用例：  
  (char< #\a #\b #\c)
  => t
  (char< #\a #\b #\b)
  => nil
  (char< #\A #\b)
  => t
  (char< #\a #\B)
  => nil


■char<=
[       type]: Function
[  arguments]: char<= CHARACTER &rest MORE-CHARACTERS
[    package]: lisp
[    seealso]: char-not-greaterp
[       file]: builtin.l
[    section]: 文字
[description]: 
隣り合った引数の関係がすべて昇順か等しければt、そうでなければnilを返します。

使用例：  
  (char<= #\a #\b #\b #\c)
  => t
  (char<= #\a #\b #\c #\b)
  => nil


■char=
[       type]: Function
[  arguments]: char= CHARACTER &rest MORE-CHARACTERS
[    package]: lisp
[    seealso]: eql , equal , char-equal
[       file]: builtin.l
[    section]: 文字
[description]: 
引数の文字がすべて等しければt、そうでなければnilを返します。

使用例：  
  (char= #\a #\a #\a)
  => t
  (char= #\a #\d)
  => nil
  (char= #\a #\A)
  => nil

参考：
  case-sensitive        case-insensitive
  ----                  ----
  char=                 char-equal
  char/=                char-not-equal
  char<                 char-lessp
  char>                 char-greaterp
  char<=                char-not-greaterp
  char>=                char-not-lessp


■char>
[       type]: Function
[  arguments]: char> CHARACTER &rest MORE-CHARACTERS
[    package]: lisp
[    seealso]: char-greaterp
[       file]: builtin.l
[    section]: 文字
[description]: 
引数の文字が全て降順ならt、そうでなければnilを返します。

使用例：  
  (char> #\c #\b #\a)
  => t
  (char> #\c #\b #\d)
  => nil
  (char> #\b #\A)
  => t
  (char> #\a #\B)
  => t


■char>=
[       type]: Function
[  arguments]: char>= CHARACTER &rest MORE-CHARACTERS
[    package]: lisp
[    seealso]: char-not-lessp
[       file]: builtin.l
[    section]: 文字
[description]: 
隣り合った引数の関係がすべて降順か等しければt、そうでなければnilを返します。

使用例：  
  (char>= #\c #\b #\b #\a)
  => t
  (char>= #\c #\b #\d)
  => nil


■character
[       type]: Function
[  arguments]: character OBJECT
[    package]: lisp
[    seealso]: coerce
[       file]: builtin.l
[    section]: 文字
[description]: 
OBJECTを可能ならばcharacterに変換して返します。

  (character 'x) == (coerce 'x 'character)

使用例：
  (character 'x)        => #\x
  (character "A")       => #\A
  (character "1")       => #\1
  (character "10")      => 文字への変換はサポートされていません: "10"


■characterp
[       type]: Function
[  arguments]: characterp OBJECT
[    package]: lisp
[    seealso]: alpha-char-p , alphanumericp , digit-char-p , kana-char-p , kanji-char-p , standard-char-p , extended-alphabet-char-p , word-char-p
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECT が character なら t 、それ以外なら nil を返します。


■check-type
[       type]: Macro
[  arguments]: check-type PLACE TYPESPEC &optional STRING
[    package]: lisp
[       file]: condition.l
[    section]: データ型
[description]: 
（詳細不明）

使用例：
  ;;; nの型チェックをしてみる。
  (check-type n integer)


■check-valid-pathname
[       type]: Function
[  arguments]: check-valid-pathname PATHNAME
[    package]: lisp
[    seealso]: file-exist-p , valid-path-p
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
PATHNAMEが存在すればt、そうでなければnilを返します。

使用例：
  ;;; 存在するC:/xyzzy/と存在しないC:/xyzzzy/を比べてみる。
  (check-valid-pathname "C:/xyzzy/")
  => t
  (check-valid-pathname "C:/xyzzzy/")
  => nil


■cis
[       type]: Function
[  arguments]: cis Z
[    package]: lisp
[       file]: number.l
[    section]: 数値
[description]: 
偏角が Z で絶対値が 1 の複素数を返します。

  (cis Z) == (complex (cos Z) (sin Z))


■clear-all-text-attributes
[       type]: Function
[  arguments]: clear-all-text-attributes
[    package]: editor
[    seealso]: delete-text-attributes , delete-text-attribute-point , set-text-attribute
[       file]: builtin.l
[    section]: テキスト
[description]: 
set-text-attribute で設定した属性を全部消します


■clear-all-text-colors
[       type]: Function
[  arguments]: clear-all-text-colors
[    package]: editor
[    seealso]: delete-text-attributes , set-text-color
[       file]: cmds.l
[    section]: テキスト
[description]: 
set-text-color で付けた属性を消します。

補足:
  この関数は Version 0.0.0.92 にて set-text-color とともに obsolete と
  なりました。


■clear-input
[       type]: Function
[  arguments]: clear-input &optional INPUT-STREAM
[    package]: lisp
[    seealso]: open
[       file]: builtin.l
[    section]: 入出力
[description]: 
入力ストリームにバッファリングされている入力をクリアします。


■clear-message
[       type]: Function
[  arguments]: clear-message
[    package]: editor
[    seealso]: message
[       file]: misc.l
[    section]: 入出力
[description]: 
ステータスバーのメッセージを消去します。


■clear-minibuffer-message
[       type]: Function
[  arguments]: clear-minibuffer-message
[    package]: editor
[    seealso]: minibuffer-message , minibuffer-prompt
[       file]: misc.l
[    section]: ミニバッファ
[description]: 
ミニバッファに表示された文字列を消去します。


■clear-rectangle
[       type]: Function
[  arguments]: clear-rectangle P1 P2
[    package]: editor
[    seealso]: open-rectangle , clear-rectangle-selection , operate-on-rectangle
[       file]: rectangl.l
[    section]: リージョン
[description]: 
P1 と P2 で指定される矩形領域を #\SPC で上書きします。


■clear-rectangle-selection
[       type]: Function
[  arguments]: clear-rectangle-selection
[    package]: editor
[    seealso]: open-rectangle-selection , clear-rectangle , operate-on-rectangle-selection
[       file]: select.l
[    section]: リージョン
[description]: 
矩形選択されたセレクションの領域を #\SPC で上書きします。


■clear-reverse-region
[       type]: Function
[  arguments]: clear-reverse-region
[    package]: editor
[    seealso]: reverse-region
[       file]: builtin.l
[    section]: リージョン
[description]: 
reverse-regionで反転表示した部分を元に戻します。


■clear-undo-boundary
[       type]: Function
[  arguments]: clear-undo-boundary &optional BUFFER
[    package]: editor
[    seealso]: undo , undo-boundary , kept-undo-information
[       file]: builtin.l
[    section]: バッファ
[description]: 
UNDO情報から直近の境界を削除します。

使用例：
  (defun self-insert-space (&optional (arg 1))
    (interactive "*")
    (when (eq *last-command* 'self-insert-space)
      (clear-undo-boundary))
    (self-insert-command arg))
  (define-key ed::*lisp-mode-map* #\SPC 'self-insert-space)


■close
[       type]: Function
[  arguments]: close STREAM &key :abort
[    package]: lisp
[    seealso]: open
[       file]: builtin.l
[    section]: 入出力
[description]: 
指定されたストリームをクローズします。

  STREAM : クローズするストリームを指定します。
  :abort : 異常終了時に指定します。
        t       ストリームに対する副作用を取り消そうとします。
        nil     ストリーム普通に終了します。


■close-session
[       type]: Function
[  arguments]: close-session &optional NOASK (CREATE-NEW t) (FN #'write-file)
[    package]: editor
[    seealso]: ed::auto-save-session-file
[   referred]: close-session-dialog , ed::*auto-save-session-file* , toggle-session-auto-save
[       file]: session.l
[    section]: バッファ
[description]: 
すべてのフレームと *scratch* を除くすべてのバッファを削除します。
保存していないバッファがあれば保存します。 [C-x 6 k]

ed::*auto-save-session-file* が non-nil であり、現在セッションを開いて
いるならば同時にセッションファイルを上書きします。

  NOASK      : nil の場合ファイルごとに保存するかどうか確認
  CREATE-NEW : non-nil であれば最後に新しいフレームをひとつ作る
  FN         : ファイルの保存に使われる関数


■close-session-dialog
[       type]: Function
[  arguments]: close-session-dialog &optional NOASK
[    package]: editor
[    seealso]: close-session
[       file]: session.l
[    section]: バッファ
[description]: 
close-session とほぼ同じですが、変更されたバッファを保存する際に
ダイアログを表示して保存先を指定します。 [C-x 6 K]

  NOASK      : nil の場合ファイルごとに保存するかどうか確認


■clrhash
[       type]: Function
[  arguments]: clrhash HASH-TABLE
[    package]: lisp
[    seealso]: make-hash-table
[       file]: builtin.l
[    section]: ハッシュ
[description]: 
ハッシュテーブルの全要素を削除します。

  HASH-TABLE : ハッシュテーブルを指定します。


■code-char
[       type]: Function
[  arguments]: code-char CODE
[    package]: lisp
[    seealso]: char-code , unicode-char , iso-char-code , char-unicode
[       file]: builtin.l
[    section]: 文字
[description]: 
文字コードがCODEの文字を返します。
キャラクタと文字コードとの間の相互変換には、 char-code を使います。

使用例：  
  (code-char 110)
  => #\n


■coerce
[       type]: Function
[  arguments]: coerce OBJECT TYPE
[    package]: lisp
[    seealso]: type-of
[   referred]: character , string
[       file]: typespec.l
[    section]: データ型
[description]: 
OBJECT を TYPE 型に変換します。

TYPE はシンボルまたはリストで、それぞれ以下の型に変換されます。
  'list         ──→ リスト
  'array        ─┬→ 配列
  'simple-array ─┘
  'character    ──→ 文字
  'float        ─┬→ 単精度浮動小数点数
  'short-float  ─┤
  'single-float ─┘
  'double-float ─┬→ 倍精度浮動小数点数
  'long-float   ─┘
  'complex      ──→ 複素数
  'function     ──→ 関数
リストの場合、その最初の要素で型が決まります。
2番目以降の要素は、最初の要素が array、simple-array、complex の場合のみ
意味を持ち、それぞれ以下のように動作します。
  '(array ...)        ─┬→ make-sequence の TYPE と同じ
  '(simple-array ...) ─┘
  '(complex ...)      ──→ 実部、虚部を二番目の要素の型に変換
  
使用例:
  (coerce "abc" 'list)                         ; 文字列を文字のリストに
  => (#\a #\b #\c)
  (coerce #(1 2 3) 'list)                      ; 配列をリストに
  => (1 2 3)
  (coerce '(a b c) '(array t 1))               ; リストを配列に
  => #(a b c)
  (coerce "abc" '(array t 1))                  ; 文字列を文字の配列に
  => #(#\a #\b #\c)
  (coerce '(#\a #\b #\c) '(array character 1)) ; 文字のリストを文字列に
  => "abc"
  (coerce "abc" '(array character 1))          ; 意味なし
  => "abc"

  (coerce "a" 'character)                      ; 文字列を文字に
  => #\a
  
  (coerce 1 'float)
  => 1.0
  (coerce 1 'double-float)
  => 1.0d0
  (coerce 1.0 'complex)
  => #C(1.0 0.0)
  (coerce #C(1 2) '(complex float))            ; 単精度の複素数に
  => #C(1.0 2.0)
  
  (coerce 'let 'function)                      ; シンボル名の関数を返す
  => #<function: let>
  (coerce '(lambda (x) (* x 2)) 'function)     ; 関数を作ることも
  => #<lexical-closure: (anonymous)>
  (funcall (coerce '(lambda (x) (* x 2)) 'function) 12)
  => 24


■command-apropos
[       type]: Function
[  arguments]: command-apropos STRING
[    package]: editor
[    seealso]: apropos
[       file]: help.l
[    section]: シンボル
[description]: 
指定した正規表現に一致する interactive 宣言されている関数の一覧を表示し
ます。バインドされたキーがあれば、同時に表示します。


■command-execute
[       type]: Function
[  arguments]: command-execute COMMAND &optional HOOK
[    package]: editor
[    seealso]: call-interactively , interactive , execute-extended-command , call-last-kbd-macro , *prefix-args*
[       file]: builtin.l
[    section]: 評価
[description]: 
エディタのコマンドを実行します。
 
  COMMAND  : 文字列の場合，COMMAND をキーボードマクロとして実行します。
             シンボルの場合，COMMAND を interactive に実行します。
  HOOK     : COMMANDがシンボルの場合のみ使われます。
             HOOK には，2引数関数を指定し，第1引数はシンボル名，
             第2引数にはプレフィックスアーギュメントがある場合は 
             (list *prefix-value*) が，ない時は nil が入ります。
             コマンドを実行後，HOOKが実行されます。
             これ以上の詳細は不明です。

使用例：
  ;;; (command-execute "^X^F")と書いてfind-fileを実行してみます。
  (command-execute "^X^F")
 
  ;;; interactiveなコマンドを実行してみます。
  (command-execute 'next-line)

  ;;; interactiveでないコマンドを実行してみます。
  (command-execute 'goto-bol)
  =>不正なコマンドです: goto-bol

  ;;; HOOKを使ってみます。 
  (command-execute 'next-line #'(lambda (x y) (msgbox "~w\n~w" x y)))

  ;;; 各自，C-j や C-u C-j で上記のコマンドを実行してみください。


■command-keys
[       type]: Function
[  arguments]: command-keys COMMAND GLOBAL-KEYMAP LOCAL-KEYMAP &optional MINOR-MODE-KEYMAPS
[    package]: editor
[    seealso]: lookup-keymap
[       file]: builtin.l
[    section]: キーマップ
[description]: 
指定した関数にバインドされたキーのリストを返します。
MINOR-MODE-KEYMAPS LOCAL-KEYMAP GLOBAL-KEYMAPの順に優先されます。

使用例:
  (command-keys 'undo *global-keymap* (local-keymap) (minor-mode-map))
  => (#\C-\\ #\End)


■command-output-alternate-send-input
[       type]: Function
[  arguments]: command-output-alternate-send-input
[    package]: editor
[    seealso]: command-output-send-input
[   referred]: command-output-mode
[       file]: process.l
[    section]: プロセス
[description]: 
現在のバッファに関連付けられたプロセスに対して、マーカーと現在行の行末
の間の文字と \r をつなげて送ります。

マーカーは、プロセスが最後に出力したバッファの位置につけられています。


■command-output-mode
[       type]: Function
[  arguments]: command-output-mode
[    package]: editor
[    seealso]: command-output-send-input , command-output-alternate-send-input
[   referred]: execute-subprocess
[       file]: process.l
[    section]: プロセス
[description]: 
バッファを command-output-mode にします。
自動保存とundo情報を記録しなくなります。

また、以下のように設定された *command-output-mode-map* がキーマップ
として使われます。
  RET : command-output-send-input 
  C-j : command-output-alternate-send-input


■command-output-send-input
[       type]: Function
[  arguments]: command-output-send-input &optional EOL
[    package]: editor
[    seealso]: command-output-alternate-send-input , marker-point , process-send-string
[   referred]: command-output-mode
[       file]: process.l
[    section]: プロセス
[description]: 
現在のバッファに関連付けられたプロセスに対して、マーカーと現在行の行末
の間の文字と EOL をつなげて送ります。 EOL のデフォルトは \n です。

マーカーは、プロセスが最後に出力したバッファの位置につけられています。


■commandp
[       type]: Function
[  arguments]: commandp OBJECT
[    package]: editor
[    seealso]: interactive , interactive-p
[       file]: builtin.l
[    section]: 関数
[description]: 
関数が interactive 宣言されていれば tを返し、そうでなければnilを返します。


■compare-buffer-substrings
[       type]: Function
[  arguments]: compare-buffer-substrings BUFFER1 START1 END1 BUFFER2 START2 END2 &optional CASE-FOLD
[    package]: editor
[    seealso]: compare-windows
[       file]: builtin.l
[    section]: 文字列
[description]: 
BUFFER1 と BUFFER2 の指定された区間の内容が等しいか比べます。
両者の内容が与えられた区間のうち短い方の長さの間等しいとき、
戻り値の絶対値はその長さ + 1 です。
戻り値が 0 となる事はありません。

  CASE-FOLD : non-nil で、大文字・小文字を区別しません。


■compile-file-pathname
[       type]: Function
[  arguments]: compile-file-pathname PATHNAME
[    package]: lisp
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
xyzzy でバイトコンパイルした時の出力ファイル名を返します。


■compile-regexp
[       type]: Function
[  arguments]: compile-regexp REGEXP &optional CASE-FOLD
[    package]: editor
[    seealso]: compiled-regexp-source , compiled-regexp-case-fold-p , regexpp , compile-regexp すると一応高速化されるんでしょうか？
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
正規表現をコンパイルします。
随時正規表現の解析を行わない分、多少検索が早くなるようです。
第二引数にnil以外を指定すると(普通はtを指定します)大文字小文字を区別しません。

  REGEXP     : コンパイルする正規表現
  :case-fold : 大文字小文字を区別するか？
        t       大文字小文字は区別しない。
        nil     大文字小文字をする。

scan-bufferの引数にコンパイルされた正規表現を渡した場合には、
compile-regexpでの指定が有効になり,scan-bufferの引数にある:case-foldは無
視されます。

使用例：
  ;;; "単語.単語:"という正規表現をコンパイルしてみる。
  ;;; 真ん中の'.'は正規表現として扱って欲しくないので、regexp-quoteする。
  (compile-regexp (concat "\\w+" (regexp-quote ".") "\\w+:"))
  => #<compiled regular expression: \w+\.\w+:>


■compile-regexp すると一応高速化されるんでしょうか？
[       type]: Tips
[   referred]: compile-regexp
[    section]: 検索・正規表現
[description]: 
遅くはならないはずです(^^; ま、せいぜいこの程度ですが。

  (let ((tick (get-internal-real-time)))
    (dotimes (x 100000)
      (string-match "a" "a"))
    (- (get-internal-real-time) tick))
  => 3484
  
  (let ((tick (get-internal-real-time))
        (regexp (compile-regexp "a")))
    (dotimes (x 100000)
      (string-match regexp "a"))
    (- (get-internal-real-time) tick))
  => 2984


■compile-regexp-keyword-list
[       type]: Function
[  arguments]: compile-regexp-keyword-list LIST
[    package]: editor
[    seealso]: regexp-keyword-list
[       file]: re-kwd.l
[    section]: 検索・正規表現
[description]: 
regexp-keyword-list用に正規表現のコンパイルを行います。
指定するLISTの形式はregexp-keyword-listを参照して下さい。


■compiled-function-p
[       type]: Function
[  arguments]: compiled-function-p OBJECT
[    package]: lisp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTがcompiled code objectならt、それ以外ならnilを返します。

使用例：
  ;;; carの型を調べてみる。
  (type-of #'car)
  => compiled-function
  (compiled-function-p #'car)
  => t


■compiled-regexp-case-fold-p
[       type]: Function
[  arguments]: compiled-regexp-case-fold-p REGEXP
[    package]: editor
[    seealso]: compile-regexp
[   referred]: compiled-regexp-source
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
コンパイル済みの正規表現が、大文字小文字を区別するようになってい
るかどうかを判定します。

使用例：
  (setq a (compile-regexp "a+bc*d" t))
  => #<compiled regular expression: a+bc*d>
  (compiled-regexp-case-fold-p a)
  => t


■compiled-regexp-source
[       type]: Function
[  arguments]: compiled-regexp-source REGEXP
[    package]: editor
[    seealso]: compile-regexp , compiled-regexp-case-fold-p
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
コンパイル済みの正規表現から元の正規表現を抽出します。

使用例：
  (setq a (compile-regexp "a+bc*d" t))
  => #<compiled regular expression: a+bc*d>
  (compiled-regexp-source a)
  => "a+bc*d"


■complement
[       type]: Function
[  arguments]: complement FN
[    package]: lisp
[    seealso]: not
[       file]: sequence.l
[    section]: シーケンス
[description]: 
FN と逆の結果（not）を返す関数を作り、その関数を返します。

使用例:
  (funcall (complement 'oddp) 4)
  => t


■completing-read
[       type]: Function
[  arguments]: completing-read PROMPT COMPLETIONS &key :case-fold :default :history :must-match
[    package]: editor
[    seealso]: read-string , interactive
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
ミニバッファにプロンプトを表示してユーザーの入力を読み取ります。

  PROMPT      : 表示するプロンプト
  COMPLETIONS : 補完入力のためのリスト
  :case-fold  : non nilなら大文字小文字を区別しない
  :default    : 初期値の指定
  :history    : 履歴情報
                minibuffer-history-variableプロパティを持つシンボルを指定します
  :must-match : non nilならCOMPLETIONS以外受け付けない


■complex
[       type]: Function
[  arguments]: complex REALPART &optional IMAGPART
[    package]: lisp
[    seealso]: imagpart , realpart
[       file]: builtin.l
[    section]: 数値
[description]: 
指定された実数部(REALPART)と虚数部(IMAGPART)で複素数を表現します。

使用例：
  (setq a (complex 0 1))
  =>#C(0 1)

  (* a a)
  =>-1


■complexp
[       type]: Function
[  arguments]: complexp OBJECT
[    package]: lisp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECT が complex number なら t 、それ以外なら nil を返します。


■concat
[       type]: Function
[  arguments]: concat &rest SEQ
[    package]: editor
[    seealso]: concatenate
[       file]: misc.l
[    section]: 文字列
[description]: 
指定された文字列を連結します。

使用例：
  ;;; concatを使ってみる。
  (setq foo "It's ")            => "It's "
  (setq bar "show time!!!")     => "show time!!!"
  (concat foo bar)              => "It's show time!!!"
  (concat "It's " "show " "time!!!")
  =>"It's show time!!!"


■concatenate
[       type]: Function
[  arguments]: concatenate RESULT-TYPE &rest SEQUENCES
[    package]: lisp
[    seealso]: make-sequence , append , concat , vconcat
[   referred]: merge
[       file]: sequence.l
[    section]: シーケンス
[description]: 
SEQUENCES を結合して RESULT-TYPE のシーケンスを新しく作り、返します。

RESULT-TYPE には make-sequence と同様のものが使用できます。
RESULT-TYPE の値によって、大まかには以下の関数と同じ挙動をします。
  'list   <--> append
  'string <--> concat
  'vector <--> vconcat

なお SEQUENCES と RESULT-TYPE の型は必ずしも一致しなくてもかまいません。


■concatenated-stream-streams
[       type]: Function
[  arguments]: concatenated-stream-streams CONCATENATED-STREAM
[    package]: lisp
[    seealso]: make-concatenated-stream
[       file]: builtin.l
[    section]: 入出力
[description]: 
make-concatenated-streamで作られたCONCATENATED-STREAMの入力元のストリームのリ
ストを返します。

使用例：
  ;;; hogeの入力元をリストで得る。
  (with-open-stream (foo (make-string-input-stream "foo"))
    (with-open-stream (bar (make-string-input-stream "bar"))
      (with-open-stream (hoge (make-concatenated-stream foo bar))
        (concatenated-stream-streams hoge))))
  => (#<string-input stream 48042632>
      #<string-input stream 48042544>)


■cond
[       type]: Macro
[  arguments]: cond &rest FORMS
[    package]: lisp
[    seealso]: if
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
C 言語などの if ... else if ... のようなものです。

構文は以下のようになっています。

(cond (<テスト1> <式>〜<式>)
      (<テスト2> <式>〜<式>)
        ...
      (<テストn> <式>〜<式>))

テストが真になる最初の節の式を評価します。
上の式は次と等価です。

(if <テスト1>
     (progn <式>〜<式>)
   (if <テスト2>
        (progn <式>〜<式>)
      ...
      (if <テストn>
           (progn <式>〜<式>)
         nil)))

テストに t を指定するとデフォルトで実行される節を指定できます。

また特別な場合として、テストの後ろの式がない場合にはテストの結果が戻り値
となります。


■conjugate
[       type]: Function
[  arguments]: conjugate NUMBER
[    package]: lisp
[       file]: builtin.l
[    section]: 数値
[description]: 
共役複素数を返します。


■connect
[       type]: Function
[  arguments]: connect HOSTNAME SERVICE &key :encoding
[    package]: editor
[    seealso]: open-network-stream , xyzzyで提供されているストリームの種類
[   referred]: with-open-stream
[       file]: builtin.l
[    section]: 入出力
[description]: 
ホストのポートとのTCP接続を開きます。
成功すれば接続へのストリームを返します。

参考：
  ;;; http://www.yahoo.co.jp/を取得してみる。
  (with-open-stream (stream (connect "www.yahoo.co.jp" 80))
    (format stream "GET / HTTP/1.0\n\n")
    (while (setq in (read-line stream nil))
      (insert in "\n")))


■cons
[       type]: Function
[  arguments]: cons X Y
[    package]: lisp
[       file]: builtin.l
[    section]: リスト
[description]: 
新しいリストを返します。

主に、新しくリストを作る際に用いる関数です。これは X を car、 
Y を cdr として、コンスセルを新しく作り、この新しいコンスセルへの
ポインタを返します。 (通常はリストですが) Y が特定のあるタイプでな
くてはならないという制限はありません。

使用例：
  (cons 1 '(2))
  => (1 2)
  (cons 1 '())
  => (1)
  (cons 1 2)
  => (1 . 2)


■consp
[       type]: Function
[  arguments]: consp OBJECT
[    package]: lisp
[    seealso]: atom
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTがconsならt、それ以外ならnilを返します。

  (consp x) == (typep x 'cons) == (not (typep x 'atom))

注意： (consp '()) は '() == nilなのでnil。


■constantp
[       type]: Function
[  arguments]: constantp OBJECT
[    package]: lisp
[    seealso]: defconstant
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
オブジェクトがconstantかどうかを返します。

  t     オブジェクトはconstant
  nil   オブジェクトはconstantでない

使用例：
  ;;; defvar/defconstantの違い
  (defvar foo 2)
  => foo
  (defconstant bar 3)
  => bar
  (constantp 'foo)
  => nil
  (constantp 'bar)
  => t


■continue-popup
[       type]: Function
[  arguments]: continue-popup
[    package]: editor
[    seealso]: popup-string
[       file]: builtin.l
[    section]: その他
[description]: 
popup-stringで前回表示した内容を再度表示します。


■convert-encoding-from-internal
[       type]: Function
[  arguments]: convert-encoding-from-internal ENCODING INPUT-STRING-OR-STREAM &optional OUTPUT-STREAM
[    package]: editor
[    seealso]: convert-encoding-to-internal , detect-char-encoding
[       file]: builtin.l
[    section]: その他
[description]: 
与えられた文字列やストリームを内部コードからENCODINGに変換します。

　ENCODING               : 出力ストリームのエンコーディング
                           encoding.lに大量に定義してある*encoding-euc-jp*など
  INPUT-STRING-OR-STREAM : 変換する文字列またはストリーム
  OUTPUT-STREAM          : 出力するストリーム

戻り値は以下の通りです。

  文字列 OUTPUT-STREAMがnilの時(指定しないときもnilとみなされます)
  t      ストリームに出力したとき


■convert-encoding-to-internal
[       type]: Function
[  arguments]: convert-encoding-to-internal ENCODING INPUT-STRING-OR-STREAM &optional OUTPUT-STREAM
[    package]: editor
[    seealso]: convert-encoding-from-internal , detect-char-encoding
[       file]: builtin.l
[    section]: その他
[description]: 
与えられた文字列やストリームをENCODINGから内部コードに変換します。

　ENCODING               : 入力ストリームのエンコーディング
                           encoding.lに大量に定義してある
                           *encoding-euc-jp*などやdetect-char-encodingの
                           戻り値を利用するのも良いでしょう
  INPUT-STRING-OR-STREAM : 変換する文字列またはストリーム
  OUTPUT-STREAM          : 出力するストリーム

戻り値は以下の通りです。

  文字列 OUTPUT-STREAMがnilの時(指定しないときもnilとみなされます)
  t      ストリームに出力したとき


■copy-alist
[       type]: Function
[  arguments]: copy-alist LIST
[    package]: lisp
[       file]: builtin.l
[    section]: リスト
[description]: 
連想リストのコピーを返します。例えばこんな連想リストをコピーした場合に、
オリジナルと同じものを指している部分に下線を引いています。copy-listでは
最上位の要素そのものがオリジナルと共有しているのに対し、copy-alistは第二
階層の要素を共有しています。

オリジナル：
  '(((1 2) . #\a) ((3 4) . #\b))

copy-list ：
  '(((1 2) . #\a) ((3 4) . #\b))
    ~~~~~~~~~~~~~ ~~~~~~~~~~~~~
copy-alist：
  '(((1 2) . #\a) ((3 4) . #\b))
     ~~~~~   ~~~   ~~~~~   ~~~

GNU Emacs Lisp Reference Manualによると、コピー元の連想リストとは独立し
て連想リストの修正を行えるようにするためとか。下の例でも示しているとおり、
copy-listでは元のリストまで変わってしまいます。

使用例：
  ;;; copy-listとcopy-alistの違いを見てみる。
  (setq a '((1 . #\a) (2 . #\b)))       => ((1 . #\a) (2 . #\b))
  (setq b (copy-list a))                => ((1 . #\a) (2 . #\b))
  (setq c (copy-alist a))               => ((1 . #\a) (2 . #\b))
  (rplacd (assoc 2 a) #\c)              => (2 . #\c)
  a                                     => ((1 . #\a) (2 . #\c))
  b                                     => ((1 . #\a) (2 . #\c))
  c                                     => ((1 . #\a) (2 . #\b))


■copy-file
[       type]: Function
[  arguments]: copy-file FILE NEW-FILE &key :if-exists :copy-attributes :if-access-denied
[    package]: lisp
[    seealso]: rename-file
[   referred]: delete-file
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
ファイルをコピーします。

  FILE             : コピー元のファイル名を指定します。
  NEW-FILE         : コピー先のファイル名を指定します。
  :copy-attributes : コピーするときの属性を指定します。
                     指定できる属性はget-file-infoを参照して下さい。
  :if-exists       : ファイルが存在しない場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
        :overwrite      上書きします。
        :newer          新しければ上書きします。
  :if-access-denied : アクセスが拒否された場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
        :force          強制的にファイルのコピーを試みます。

使用例：
  ;;; ローカルのautoexec.batを マシン名 VENUSの /work/autoexec.batにコピーする。
  (copy-file "c:/autoexec.bat" "//VENUS/work/autoexec.bat"
             :if-exists :overwrite)


■copy-keymap
[       type]: Function
[  arguments]: copy-keymap MAP
[    package]: editor
[       file]: keymap.l
[    section]: キーマップ
[description]: 
キーマップのコピーを返します。

使用例：
  ;;; gresreg.lより
  ;;; query-replaceのキーマップをコピーして
  ;;; query-gresregのキーマップを作って、ちょっと修正する。
  (unless *query-gresreg-map*
    (setq *query-gresreg-map* (copy-keymap *query-replace-map*))
    (define-key *query-gresreg-map* #\C-g '(throw . quit)))


■copy-list
[       type]: Function
[  arguments]: copy-list LIST
[    package]: lisp
[    seealso]: copy-tree , copy-seq
[       file]: builtin.l
[    section]: リスト
[description]: 
リストのコピーを返します。
コピーとオリジナルはequalですが、eqではありません。コピーとオリジナルは
同じ構造を持っており、一番上位のリストの要素は同じものを共有しています。
一方を変えると他方も変わります。オリジナルと同じものを指している部分に下
線を引いています。

オリジナル：
  '(((1 2) . #\a) ((3 4) . #\b))

copy-list ：
  '(((1 2) . #\a) ((3 4) . #\b))
    ~~~~~~~~~~~~~ ~~~~~~~~~~~~~
使用例：
  ;;; [A] eqではないことを示してみます。
  (setq a '((1 2 3) (4 5 6)))   => ((1 2 3) (4 5 6))
  (setq b (copy-list a))        => ((1 2 3) (4 5 6))
  (eq a b)                      => nil
  (equal a b)                   => t
  ;;; [B] car同士はeqです。
  (eq (car a) (car b))          => t
  ;;; [C] caarを変えると変わるけど、carを変えても変わらない。
  (progn (setf (caar a) 7) a)   => ((7 2 3) (4 5 6))
  b                             => ((7 2 3) (4 5 6))
  (progn (setf (car a) 8) a)    => (8 (4 5 6))
  b                             => ((7 2 3) (4 5 6))


■copy-menu-items
[       type]: Function
[  arguments]: copy-menu-items OLD-MENU NEW-MENU
[    package]: editor
[   referred]: define-menu
[       file]: builtin.l
[    section]: メニュー
[description]: 
old-menuの構造をnew-menuにトップレベルでコピーします。

亀井さん談：
  ちなみにバグってます。old-menuとnew-menuが同じ場合のことを何も考えていません。


■copy-readtable
[       type]: Function
[  arguments]: copy-readtable &optional FROM-READTABLE TO-READTABLE
[    package]: lisp
[    seealso]: *readtable*
[       file]: builtin.l
[    section]: 入出力
[description]: 
リードテーブルをコピーします。

  FROM-READTABLE : コピー元 (デフォルトは *readtable*)
                   nil を明示的に与えるとデフォルトのリードテーブルをコピー。
  TO-READTABLE   : コピー先。省略時は新しく作成。


■copy-rectangle
[       type]: Function
[  arguments]: copy-rectangle P1 P2
[    package]: editor
[    seealso]: kill-rectangle , copy-rectangle-selection
[   referred]: *rectangle-kill-buffer* , copy-rectangle-to-register
[       file]: rectangl.l
[    section]: リージョン
[description]: 
P1とP2で指定される矩形領域をコピーします。コピーした矩形領域のyankには、
yank-rectangleを使います。


■copy-rectangle-selection
[       type]: Function
[  arguments]: copy-rectangle-selection
[    package]: editor
[    seealso]: kill-rectangle-selection , copy-rectangle , operate-on-rectangle-selection
[   referred]: copy-rectangle-selection-to-clipboard
[       file]: select.l
[    section]: リージョン
[description]: 
マウスで矩形選択されたセレクションの領域をコピーします。yankには
yank-rectangle-selectionを使いますが、yank-rectangleでも行けそうです。
コピーした内容は*kill-ring*ともクリップボードとも違う領域に格納されてい
るようです。


■copy-rectangle-selection-to-clipboard
[       type]: Function
[  arguments]: copy-rectangle-selection-to-clipboard
[    package]: editor
[    seealso]: kill-rectangle-selection-to-clipboard , copy-rectangle-selection , copy-to-clipboard
[       file]: select.l
[    section]: リージョン
[description]: 
マウスで矩形選択されたセレクションの領域をクリップボードにコピーします。


■copy-rectangle-to-register
[       type]: Function
[  arguments]: copy-rectangle-to-register R START END &optional DELETE
[    package]: editor
[    seealso]: copy-rectangle , kill-rectangle , insert-register
[       file]: register.l
[    section]: リージョン
[description]: 
START と END で指定される矩形領域をレジスタ R へコピーします。[C-x r r]
DELETE が non-nil ならば同時に領域を削除します。
コピーした矩形領域の yank には、 insert-register を使います。 


■copy-region-as-kill
[       type]: Function
[  arguments]: copy-region-as-kill FROM TO
[    package]: editor
[    seealso]: kill-region
[       file]: region.l
[    section]: リージョン
[description]: 
リージョンをコピーして、キルリングに追加します。[ESC w]


■copy-region-to-clipboard
[       type]: Function
[  arguments]: copy-region-to-clipboard FROM TO
[    package]: editor
[    seealso]: copy-to-clipboard
[       file]: region.l
[    section]: リージョン
[description]: 
指定されたリージョンをクリップボードにコピーします。

  FROM : リージョンの開始位置を指定します。
  TO   : リージョンの終了位置を指定します。


■copy-selection
[       type]: Function
[  arguments]: copy-selection
[    package]: editor
[    seealso]: yank-selection , kill-selection
[   referred]: *selection-ring*
[       file]: select.l
[    section]: リージョン
[description]: 
選択された領域をコピーして、*selection-ring*の先頭に追加します。 [F8]
追加した内容はyank-selectionで貼り付けられます。


■copy-selection-to-clipboard
[       type]: Function
[  arguments]: copy-selection-to-clipboard
[    package]: editor
[    seealso]: copy-to-clipboard
[       file]: select.l
[    section]: リージョン
[description]: 
選択範囲をクリップボードに転送します。[C-Insert]

使用例：
  ;;; 1. いったんJISに変換して保存
  ;;; 2. [ファイル]-[開く]で文字エンコーディングを[シフトJIS]にして開く
  ;;;    （またはメモ帳などで開く？）
  ;;; 3. 選択してコピー
  (defun tojiscopy ()
    (interactive)
    (let ((ocode *kanji-expected-code*)
          (tempfile (concat (default-directory) "tempfile.txt")))
      (save-excursion
        (set-buffer-kanji-fileio-code 1)
        (write-region (point-min) (point-max) tempfile nil)
        (switch-to-buffer "*JIS*"))
      (pop-to-buffer "*JIS*")
      (setq *kanji-expected-code* 0)
      (find-file tempfile)
      (setq *kanji-expected-code* ocode)
      (selection-whole-buffer)
      (copy-selection-to-clipboard)))


■copy-seq
[       type]: Function
[  arguments]: copy-seq SEQUENCE
[    package]: lisp
[    seealso]: copy-list , copy-string , make-vector
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCEのコピーを作成して返します。元のSEQUENCEとはequalpだがeqではありません。

  (copy-seq x) == (subseq x 0)


■copy-string
[       type]: Function
[  arguments]: copy-string STRING
[    package]: lisp
[    seealso]: substring , copy-seq
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRINGのコピーを返します。

使用例：
  ;;; 単にsetqしただけでは同じオブジェクトになっている。
  (setq foo "abc")              => "abc"
  (setq bar foo)                => "abc"
  (eq foo bar)                  => t

  ;;; コピーすると別のオブジェクトになる。
  (setq bar (copy-string foo))  => "abc"
  (eq foo bar)                  => nil


■copy-symbol
[       type]: Function
[  arguments]: copy-symbol SYMBOL &optional COPY-PROPS
[    package]: lisp
[    seealso]: uninterned
[       file]: builtin.l
[    section]: シンボル
[description]: 
同じ名前を持つuninternedなSYMBOLのコピーを返します。
COPY-PROPSがnon-nilなら、初期定義値、プロパティリストもコピーされます。


■copy-syntax-table
[       type]: Function
[  arguments]: copy-syntax-table FROM-SYNTAX-TABLE TO-SYNTAX-TABLE
[    package]: editor
[    seealso]: make-syntax-table
[       file]: builtin.l
[    section]: シンタックス
[description]: 
FROM-SYNTAX-TABLE を TO-SYNTAX-TABLE へコピーします。


■copy-to-clipboard
[       type]: Function
[  arguments]: copy-to-clipboard STRING
[    package]: editor
[    seealso]: get-clipboard-data , copy-region-to-clipboard , copy-selection-to-clipboard , copy-rectangle-selection-to-clipboard , kill-region-to-clipboard , kill-selection-to-clipboard , kill-rectangle-selection-to-clipboard , yank-to-clipboard , paste-from-clipboard , paste-rectangle-from-clipboard
[       file]: builtin.l
[    section]: システム
[description]: 
指定された文字列をクリップボードにコピーします。

  STRING : クリップボードにコピーする文字列を指定します。


■copy-to-register
[       type]: Function
[  arguments]: copy-to-register R START END &optional DELETE
[    package]: editor
[    seealso]: insert-register , append-to-register
[       file]: register.l
[    section]: リージョン
[description]: 
START と END で指定されるリージョンをレジスタ R へコピーします。[C-x r s]
DELETE が non-nil ならば同時にリージョンをを削除します。

コピーしたテキストの yank には、 insert-register を使います。 


■cos
[       type]: Function
[  arguments]: cos RADIANS
[    package]: lisp
[       file]: builtin.l
[    section]: 数値
[description]: 
余弦関数の値を返します。


■cosh
[       type]: Function
[  arguments]: cosh Z
[    package]: lisp
[       file]: number.l
[    section]: 数値
[description]: 
双曲線余弦関数を計算します。 


■count
[       type]: Function
[  arguments]: count ITEM SEQUENCE &key :from-end :test :test-not :start :end :key
[    package]: lisp
[    seealso]: count-if , count-if-not , si:*tree-count
[       file]: sequence.l
[    section]: シーケンス
[description]: 
ITEMとのテストを満足するSEQUENCE中の要素数を返します。結果は非負の整数です。

  :from-end : 他の関数との互換性のために用意されたもので、結果に影響しません。
  :test     : テストを行う2項演算子
  :start    : テストする開始位置
  :end      : テストの終了位置


■count-buffers
[       type]: Function
[  arguments]: count-buffers &optional ALL
[    package]: editor
[    seealso]: count-modified-buffers
[       file]: builtin.l
[    section]: バッファ
[description]: 
全バッファの数を返します。

  ALL : " *Completion*"や" *Minibuf0*"等の先頭が空白のバッファも数えるか？
        t       先頭が空白のバッファも数える。
        nil     先頭が空白のバッファは数えない。

使用例：
  ;;; バッファの数を数えてみる。
  (count-buffers)
  => 20
  (count-buffers t)
  => 23


■count-column
[       type]: Function
[  arguments]: count-column STRING &optional START BUFFER
[    package]: editor
[    seealso]: char-columns , current-column
[       file]: builtin.l
[    section]: ポジション
[description]: 
文字列 STRING を出力した場合の出力後の桁位置を返します。
START と BUFFER はタブ文字の幅の計算に影響を与えます。

  STRING : 対象文字列
  START  : 出力開始とする桁位置
        nil      桁位置 0 からの出力
        INTEGER  桁位置 INTEGER からの出力 (0 未満の場合 range-error)
  BUFFER : 出力バッファ
        nil      タブ幅として (tab-column) の値を用います。
                 (tab-column (selected-buffer)) の値ではありません。
        BUFFER   タブ幅として (tab-column BUFFER) の値を用います。

戻り値：
  INTEGER   文字列 STRING 出力後の桁位置

補足：
  改行文字 "\n" は桁位置の初期化としては働かず、幅 2 として扱われます。


■count-if
[       type]: Function
[  arguments]: count-if TEST SEQUENCE &key :from-end :start :end :key
[    package]: lisp
[    seealso]: count , count-if-not
[       file]: sequence.l
[    section]: シーケンス
[description]: 
TESTを満足するSEQUENCE中の要素数を返します。結果は非負の整数です。

  :from-end : 他の関数との互換性のために用意されたもので、結果に影響しません。
  :test     : テストを行う2項演算子
  :start    : テストする開始位置
  :end      : テストの終了位置


■count-if-not
[       type]: Function
[  arguments]: count-if-not TEST SEQUENCE &key :from-end :start :end :key
[    package]: lisp
[    seealso]: count , count-if
[       file]: sequence.l
[    section]: シーケンス
[description]: 
TESTを満足しないSEQUENCE中の要素数を返します。結果は非負の整数です。

  :from-end : 他の関数との互換性のために用意されたもので、結果に影響しません。
  :test     : テストを行う2項演算子
  :start    : テストする開始位置
  :end      : テストの終了位置


■count-windows
[       type]: Function
[  arguments]: count-windows &optional MINIBUF
[    package]: editor
[   referred]: other-window
[       file]: window.l
[    section]: ウィンドウ
[description]: 
ウィンドウの数を返します。

  MINIBUF : フラグはミニバッファウィンドウを数えるかどうかです。
        t       ミニバッファを数える。
        nil     ミニバッファを数えない。


■count-xyzzy-instance
[       type]: Function
[  arguments]: count-xyzzy-instance
[    package]: editor
[       file]: builtin.l
[    section]: プロセス
[description]: 
現在起動中のxyzzyの数を返します。


■create-archive
[       type]: Function
[  arguments]: create-archive ARCHIVE-FILE FILES BASE-DIRECTORY
[    package]: editor
[    seealso]: extract-archive , delete-file-in-archive
[   referred]: list-archive
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
アーカイブを作成します。

  ARCHIVE-FILE   : 作成/追加する書庫ファイル名を指定します。指定したファ
                   イルが存在すれば追加、なければ新規作成します。書庫フ
                   ァイルを作成するディレクトリを指定する場合は、フルパ
                   スで指定します。
  FILES          : アーカイブするファイルのリストを指定します。フルパス
                   で指定する必要があります。
  BASE-DIRECTORY : 基準となるディレクトリを指定します。

使用例：
  ;;; foo.lzh に c:/tmp/a.c, c:/tmp/b.c を追加します。
  (create-archive "foo.lzh"
                  '("c:/tmp/a.c" "c:/tmp/b.c")
                  "c:/tmp")


■create-directory
[       type]: Function
[  arguments]: create-directory DIRNAME &key :if-exists
[    package]: lisp
[    seealso]: delete-directory
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
ディレクトリを作成します。

  DIRNAME    : 作成対象のディレクトリ
  :if-exists : ディレクトリが存在していたときの動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、t を返します。

戻り値は作成できたかどうかによります。

  t   ディレクトリの作成に成功
  nil ディレクトリの作成に失敗

使用例：
  (create-directory "C:/xyzzy/testdir")
  => t


■create-file-buffer
[       type]: Function
[  arguments]: create-file-buffer FILENAME
[    package]: editor
[    seealso]: get-file-buffer , create-new-buffer
[       file]: builtin.l
[    section]: バッファ
[description]: 
ファイルを参照するバッファを作成して返します。


■create-menu
[       type]: Function
[  arguments]: create-menu &optional TAG
[    package]: editor
[    seealso]: create-popup-menu , define-menu , set-menu , use-local-menu
[   referred]: add-menu-item
[       file]: builtin.l
[    section]: メニュー
[description]: 
新たに作成した空のメニューを返します。

  TAG : 識別用のタグを指定します。

メニューの中身は空なので、以下の関数で登録必要があります。
中身を動的に作る必要が無ければ、 define-menu を使用した方が良いです。

  add-menu-item         : 項目を追加します。
  add-menu-separator    : セパレータを追加します。
  add-popup-menu        : ポップアップメニューを追加します。
  insert-menu-item      : 項目を挿入します。
  insert-menu-separator : セパレータを挿入します。
  insert-popup-menu     : ポップアップメニューを挿入します。

作成したメニューは以下の関数で使います。

  set-menu       : 標準のメニューとして設定します。
  use-local-menu : バッファにローカルなメニューとして設定します。


■create-new-buffer
[       type]: Function
[  arguments]: create-new-buffer NAME
[    package]: editor
[    seealso]: create-file-buffer , get-buffer-create , *create-buffer-hook* , find-buffer , バッファの内部構造
[   referred]: buffer-name , find-name-buffer , new-file
[       file]: builtin.l
[    section]: バッファ
[description]: 
名前がNAMEのバッファを作成して返します。もしその名前のバッファが存在すれ
ば、name<1>, name<2>...と番号を付けた名前になります。

使用例：
  (create-new-buffer "test")
  => #<buffer: test>
  (create-new-buffer "test")
  => #<buffer: test<2>>


■create-popup-menu
[       type]: Function
[  arguments]: create-popup-menu &optional TAG
[    package]: editor
[    seealso]: define-popup-menu , track-popup-menu , create-menu
[       file]: builtin.l
[    section]: メニュー
[description]: 
新たに作成したポップアップメニューを返します。ポップアップメニューとして
使えることを除けば、create-menuで作成されたメニューを同じです。

  TAG : 識別用のタグを指定します。

メニューの中身は空なので、create-menuと同じように登録する必要があります。
中身を動的に作る必要が無ければ、define-popup-menuを使用した方が良いです。

作成したポップアップメニューは以下の関数で使います。

  insert-popup-menu  : 既存のメニューにポップアップメニューを追加します。
  track-popup-menu   : ポップアップメニューをその場で表示します。


■create-shortcut
[       type]: Function
[  arguments]: create-shortcut SRC DEST &rest REST
[    package]: editor
[    seealso]: resolve-shortcut
[   referred]: create-shortcut-to-desktop
[       file]: files.l
[    section]: ファイルシステム
[description]: 
ショートカットを作成します。

  SRC  : ショートカットが指すパスを指定します。
  DEST : ショートカットを作成するパスを指定します。
  REST : 作成するショートカットへのパラメータを与えることが出来ます。
     :description        ドラッグオーバの時やプロパティ表示時に見られる説明
     :arguments          コマンドライン引数
     :working-directory  作業ディレクトリ
     :show               ウィンドウの状態の指定
                            :show      標準のサイズで起動
                            :maximize  最大化状態で起動
                            :minimize  最小化状態で起動

使用例：
  ;;; スタートメニューにショートカットを作成する。
  (create-shortcut (merge-pathnames "xyzzy.exe" (si:system-root)) (get-special-folder-location :start-menu))
  => t
  (delete-file (merge-pathnames "xyzzy.exe.lnk" (get-special-folder-location :start-menu)))
  => t

  ;;; 送るメニューにxyzzyを登録する。
  (create-shortcut (merge-pathnames "xyzzy.exe" (si:system-root)) (get-special-folder-location :send-to))
  => t
  (delete-file (merge-pathnames "xyzzy.exe.lnk" (get-special-folder-location :send-to)))
  => t


■create-shortcut-to-desktop
[       type]: Function
[  arguments]: create-shortcut-to-desktop PATH &rest REST
[    package]: editor
[    seealso]: create-shortcut
[       file]: files.l
[    section]: ファイルシステム
[description]: 
デスクトップに PATH へのショートカットを作ります。


■create-tab-bar
[       type]: Function
[  arguments]: create-tab-bar BAR CALLBACK
[    package]: editor
[    seealso]: tab-bar-add-item , tab-bar-list-items , tab-bar-modify-item , tab-bar-select-item
[   referred]: create-tool-bar , tab-bar-delete-item , tab-bar-find-item
[       file]: builtin.l
[    section]: メニュー
[description]: 
タブバーの識別子BARと、タブが選択されたとき実行するコールバック関数
CALLBACKを指定して、タブバーを作成します。CALLBACKは、各タブの作成時に設
定したシンボルが渡されます。

使用例：
  (progn
    (defun a-func (a) (msgbox "~A ~A" a (type-of a)))
    (define-command-bar 'a-bar "a bar")
    (create-tab-bar 'a-bar 'a-func)
    (show-command-bar 'a-bar)
    (tab-bar-add-item 'a-bar '1st "- 1st -" "1st item")
    (tab-bar-add-item 'a-bar '2nd "- 2nd -" "2nd item"))
  => t  
  (progn
    (tab-bar-delete-item 'a-bar '1st)
    (tab-bar-delete-item 'a-bar '2nd)
    (delete-tool-bar 'a-bar)
    (delete-command-bar 'a-bar))
  => t


■create-tool-bar
[       type]: Function
[  arguments]: create-tool-bar NAME BITMAP ITEMS
[    package]: editor
[    seealso]: define-command-bar , create-tab-bar
[   referred]: delete-tool-bar
[       link]: lisp/cmdbar.l
[       file]: builtin.l
[    section]: メニュー
[description]: 
ツールバーNAMEを作成します。ツールバーに表示するビットマップファイルのフ
ルパスBITMAPと、ツールバーの項目ITEMSを指定します。ITEMSは以下の形式で記
述します。項目の替わりに:sepを指定するとセパレータを表示できます。

形式：
  ((ツールチップ1 アイコンの番号1 実行する関数1 状態制御用1)
   (ツールチップ2 アイコンの番号2 実行する関数2 状態制御用2)
    ...
   (ツールチップN アイコンの番号N 実行する関数N 状態制御用N))

補足：
  アイコンの番号：
        16x16の領域をひとつのアイコンとみなして、ビットマップファイルの
        左から0ベースの番号で指定します。
  状態制御用：
        ボタンの状態が何に依存して変更するかを指定します。
        :modified              編集されていたら 
        :selection             行モード選択、文字モード選択をしていたら
        :modify-selection      編集可能なバッファで行モード選択
                               文字モード選択をしていたら
        :rectangle             矩形選択していたら
        :modify-rectangle      編集可能なバッファで矩形選択をしていたら
        :any-selection         選択していたら
        :modify-any-selection  編集可能なバッファで選択していたら
        :clipboard             編集可能なバッファでクリップボードに値が入っていたら
        :undo                  UNDOできる状態なら
        :redo                  リドゥできる状態なら
        関数 (function)        関数が返す値による
            :disable           ボタンを押せない状態 
            :check             ボタンを押してへこんだ状態 
            上記以外           普通の押せる状態 
        上記以外               指定しないとの同じで無条件に押せる状態 
        ※OHKUBO Hiroshiさんのサイトより
          http://ohkubo.s53.xrea.com/xyzzy/memo.html

使用例：
(create-tool-bar 'abc-tool-bar
 (merge-pathnames "toolbar.bmp" (etc-path))
 '(("line-number" 0 toggle-line-number)
   ("vscroll-bar" 1 toggle-vscroll-bar)
   ("mode-line" 2 toggle-mode-line)
   :sep
   ("function-bar" 3 toggle-function-bar)
   ("fold-line" 4 toggle-fold-line)
   ("read-only" 5 toggle-read-only)))


■ctl-x-4-map
[       type]: Variable
[    package]: editor
[    seealso]: ctl-x-4-prefix
[       file]: keymap.l
[    section]: キーマップ
[description]: 
C-x 4 に続くキーシーケンスのバインディングを格納するキーマップです。


■ctl-x-4-prefix
[       type]: Function
[  arguments]: ctl-x-4-prefix
[    package]: editor
[    seealso]: ctl-x-4-map
[       file]: keymap.l
[    section]: キーマップ
[description]: 
C-x 4 プレフィックスです。 [C-x 4]
デフォルトでは
  C-x 4 b      switch-to-buffer-other-window
  C-x 4 f      find-file-other-window
の二つが設定されています。

ctl-x-4-prefix の関数セルは普通のコマンドではなく ctl-x-4-map というキ
ーマップを保持しています。


■ctl-x-6-map
[       type]: Variable
[    package]: editor
[    seealso]: ctl-x-6-prefix
[       file]: pframe.l
[    section]: キーマップ
[description]: 
C-x 6 に続くキーシーケンスのバインディングを格納するキーマップです。


■ctl-x-6-prefix
[       type]: Function
[  arguments]: ctl-x-6-prefix
[    package]: editor
[    seealso]: ctl-x-6-map
[       file]: pframe.l
[    section]: キーマップ
[description]: 
C-x 6 プレフィックスです。 [C-x 6]
デフォルトではフレーム関係のコマンドが登録されています。

ctl-x-6-prefix の関数セルは普通のコマンドではなく ctl-x-6-map というキ
ーマップを保持しています。


■ctl-x-map
[       type]: Variable
[    package]: editor
[    seealso]: ctl-x-prefix
[       file]: keymap.l
[    section]: キーマップ
[description]: 
C-x に続くキーシーケンスのバインディングを格納するキーマップです。


■ctl-x-prefix
[       type]: Function
[  arguments]: ctl-x-prefix
[    package]: editor
[    seealso]: ctl-x-map
[       file]: keymap.l
[    section]: キーマップ
[description]: 
C-x プレフィックスです。 [C-x]

ctl-x-prefix の関数セルは普通のコマンドではなく ctl-x-map というキーマ
ップを保持しています。

参考:
  ;;; keymap.l
  (defvar ctl-x-map (make-keymap))
  (setf (symbol-function 'ctl-x-prefix) ctl-x-map)


■current-column
[       type]: Function
[  arguments]: current-column
[    package]: editor
[    seealso]: current-virtual-column , goto-column
[   referred]: count-column , current-line-columns , what-cursor-position
[       file]: builtin.l
[    section]: ポジション
[description]: 
現在の桁位置を返します。


■current-line-columns
[       type]: Function
[  arguments]: current-line-columns
[    package]: editor
[    seealso]: current-column , char-columns , goto-column
[       file]: builtin.l
[    section]: ポジション
[description]: 
現在の表示行の桁数を返します。
改行文字 (#\LFD) は 2 桁と扱われます。


■current-line-number
[       type]: Function
[  arguments]: current-line-number
[    package]: editor
[    seealso]: current-virtual-line-number
[   referred]: get-window-start-line
[       file]: builtin.l
[    section]: ポジション
[description]: 
現在の物理行の行番号を返します。


■current-menu
[       type]: Function
[  arguments]: current-menu &optional BUFFER
[    package]: editor
[   referred]: get-menu , use-local-menu
[       file]: builtin.l
[    section]: メニュー
[description]: 
現在表示されているメニューを返します。use-local-menuを使用してい
るバッファは*app-menu*とは違うものが取得されます。


■current-virtual-column
[       type]: Function
[  arguments]: current-virtual-column
[    package]: editor
[    seealso]: current-column , goto-virtual-column
[   referred]: goto-column
[       file]: builtin.l
[    section]: ポジション
[description]: 
カーソル位置の表示桁を返します。
※実際の表示が表示行／物理行には依存しません。
(current-virtual-column)


■current-virtual-line-number
[       type]: Function
[  arguments]: current-virtual-line-number
[    package]: editor
[    seealso]: current-line-number , goto-virtual-line
[   referred]: get-window-start-line
[       file]: builtin.l
[    section]: ポジション
[description]: 
現在のポイントが表示行で何行目かを返します。


■current-window-configuration
[       type]: Function
[  arguments]: current-window-configuration
[    package]: editor
[    seealso]: set-window-configuration
[   referred]: save-window-configuration-to-register
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
現在のウィンドウの状態を返します。
ここでいうウィンドウの状態とは、画面の分割状態、表示されているバッファを
指します。ウィンドウの状態はset-window-configurationで設定することが出来
ます。

使用例：
  ;;; 画面の状態を元に戻す。
  (split-window)
  => t
  (setq winconf (current-window-configuration))
  => (window-configuration #<window> ......  
  (delete-other-windows)
  => t
  (set-window-configuration winconf)


■cwd
[       type]: Function
[  arguments]: cwd
[    package]: editor
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
xyzzy.exeの作業ディレクトリを返します。プロパティの作業フォルダ(S)の
ディレクトリが返されるのだと思います。

使用例： 
  (cwd)
  =>"D:/WINNT/"


■dabbrev-expand
[       type]: Function
[  arguments]: dabbrev-expand &optional ARG
[    package]: editor
[    seealso]: dabbrev-popup
[   referred]: *dabbrev-search-this-buffer-only* , *dabbrevs-no-undo*
[       file]: dabbrev.l
[    section]: テキスト
[description]: 
動的略称展開により候補を順番に表示します。[C-x /]


■dabbrev-popup
[       type]: Function
[  arguments]: dabbrev-popup
[    package]: editor
[    seealso]: dabbrev-expand , popup-list
[       file]: dabbrev.l
[    section]: テキスト
[description]: 
dabbrev-expandのポップアップリスト版です。[C-x \]


■dde-execute
[       type]: Function
[  arguments]: dde-execute CHAN DATA
[    package]: editor
[    seealso]: dde-poke , dde-request , dde-terminate
[   referred]: dde-initiate
[       file]: builtin.l
[    section]: システム
[description]: 
DDE EXECUTE を実行します。引数 CHAN は DDE チャンネル、DATA は相手にくら
わすコマンド文字列です。コマンドの内容は、相手のマニュアルに従ってくださ
い。dde-execute は t を返します。

  CHAN : チャンネルを指定します。
  DATA : データを指定します。

なお、DDE 関数では以下の例外が発生する可能性があります。必要であれば例外
を処理してください。

  dde-timeout        タイムアウトしました。
  dde-busy           DDE サーバが BUSY です。
  dde-low-memory     サーバ先行状態です
  dde-no-conv        DDE 対話が確立できません
  dde-not-processed  トランザクションの実行に失敗しました
  dde-server-died    サーバーが終了しました
  storage-error      メモリがありません
  dde-error          よくわかんないけど、とにかくエラーです


■dde-initiate
[       type]: Function
[  arguments]: dde-initiate SERVICE TOPIC
[    package]: editor
[    seealso]: dde-execute , dde-poke , dde-terminate
[       file]: builtin.l
[    section]: システム
[description]: 
DDE 対話を確立します。引数 SERVICE はサービス名、 TOPIC はトピックで、
それぞれ文字列型です。なにを指定するかは通信する相手のマニュアルを
参照してください。正常に終了した場合、DDE チャンネルを返します。
以降の通信ではこのDDE チャンネルを使用してください。


■dde-poke
[       type]: Function
[  arguments]: dde-poke CHAN ITEM DATA
[    package]: editor
[    seealso]: dde-execute , dde-request , dde-terminate
[   referred]: dde-initiate
[       file]: builtin.l
[    section]: システム
[description]: 
DDE POKE を実行します。

  CHAN : チャンネルを指定します。
  ITEM : （詳細不明）
  DATA : データを文字列で指定します。

引数 CHAN は DDE チャンネル、DATA は相手にくらわす文字列です。文字列の内
容は、相手のマニュアルに従ってください。dde-poke は t を返します。


■dde-request
[       type]: Function
[  arguments]: dde-request CHAN DATA RESULT-TYPE
[    package]: editor
[    seealso]: dde-execute , dde-poke , dde-terminate
[       file]: builtin.l
[    section]: システム
[description]: 
DDE REQUEST を実行します。

  CHAN        : チャンネルを指定します。
  DATA        : データを指定します。
  RESULT-TYPE : 戻り値の型を指定します。

引数 CHAN は DDE チャンネル、DATA は相手にくらわす文字列です。文字列の内
容は、相手のマニュアルに従ってください。戻り値は DDE の相手が返したもの
を返しますが、RESULT-TYPE の指定によってデータの解釈を以下のようにおこな
います。

  :text   : 通常の文字列を返します。
  :binary : 漢字などを無視して返ってきたデータをそのまま文字列で返します。
  :int8
  :int16
  :int32  : データをそれぞれ 8, 16, 32 ビット整数の配列とみなして整数のリ
            ストで返します。配列の要素が 1 のときは整数値を返します。

戻り値型の指定は、もじらの DDE で遊ぼうと思って作っただけなので、通常は
指定しなくて構いません。


■dde-terminate
[       type]: Function
[  arguments]: dde-terminate CHAN
[    package]: editor
[   referred]: dde-execute , dde-initiate , dde-poke , dde-request
[       file]: builtin.l
[    section]: システム
[description]: 
DDE 対話を終了します。引数 CHAN は DDE チャンネルです。正常に終了した場
合は t、すでに対話が終了していた場合は nil を返します。

  CHAN : チャンネルを指定します。


■decf
[       type]: Macro
[  arguments]: decf PLACE &optional (DELTA 1)
[    package]: lisp
[    seealso]: incf
[       file]: setf.l
[    section]: 数値
[description]: 
変数をデクリメントする

使用例：
  ;;; 変数xの値をデクリメントする。
  (setq x 1)    => 1
  (decf x)      => 0
  x             => 0


■declaim
[       type]: Macro
[  arguments]: declaim &rest DECL-SPECS
[    package]: lisp
[    seealso]: declare , proclaim
[       file]: typespec.l
[    section]: 変数と定数
[description]: 
変数をスペシャル変数にします。proclaim のマクロ版です。


■declare
[       type]: Misc
[    package]: lisp
[    seealso]: special
[   referred]: declaim , proclaim
[    section]: 変数と定数
[description]: 
Common Lispの機能で、「変数を動的に bind しろ」と宣言する事です。
Emacs Lispではそもそも動的にしか bind できないので存在しません。

  (declare (special 変数名))

違いを図示します。

  ;;; 大域変数 x          ┏大域変数━━━━━━┓    Common Lisp/xyzzy lisp：
  (setq x 0)              ┃x │0             ←╂─┐大域変数のxを参照する。
                          ┠─┴────────┨  │(+ 0 12)となる
  ;;; 関数 bar            ┃                    ┃  │
  (defun bar (x)          ┃┏(bar 34)━━━━┓┃  │    Emacs Lisp：
    (foo 12))             ┃┃x │34        ←╂╂─│─┐呼び出しスタックの
                          ┃┠─┴──────┨┃  │  │深いところのxを参照する。
  ;;; 関数 foo            ┃┃                ┃┃  │  │(+ 34 12)となる。
  (defun foo (y)          ┃┃┏(foo 12)━━┓┃┃  │  │
     (+ x y))    ... ※   ┃┃┃y │12      ┃┃┃  │  │
                          ┃┃┠─┴────┨┃┃  │  │
                          ┃┃┃(+ x y)   ─╂╂╂─┴─┘

とあったときに(bar 34)と呼び出すと、古いLispでは(Emacs Lispを含む）
※の時点で x = 34, y = 12と見えます。ところが、Common Lispやxyzzy lispでは
※の時点で x = 0,  y = 12と見えます。

昔Lispはインタープリタだったので、動的バインディングでもよかったんだけど、
コンパイラを作る時に、効率上なにかと問題があってCommon Lisp
では、静的バインディングに変更になりました。

でも、そうすると、古いコードを移植するのが大変になるので、

                          ┏大域変数━━━━━━┓    
                          ┃x │0               ┃
                          ┠─┴────────┨
  ;;; 関数 bar            ┃                    ┃    
  (defun bar (x)          ┃┏(bar 34)━━━━┓┃    Common Lisp/xyzzy lisp：
    (declare (special x)) ┃┃x │34        ←╂╂─┐大域変数ではなく
    (foo 12))             ┃┠─┴──────┨┃  │スタック上のxを参照する。
                          ┃┃                ┃┃  │(+ 34 12)となる。
                          ┃┃┏(foo 12)━━┓┃┃  │
                          ┃┃┃y │12      ┃┃┃  │
                          ┃┃┠─┴────┨┃┃  │
                          ┃┃┃(+ x y)   ─╂╂╂─┘

と書いてやると古いLisp(Emacs Lisp)のように動くという訳。


■decode-escape-sequence
[       type]: Function
[  arguments]: decode-escape-sequence STRING REGEXPP
[    package]: editor
[       link]: [xyzzy:04201]
[       file]: builtin.l
[    section]: 文字列
[description]: 
エスケープシーケンスをデコードします。

  STRING ：デコードするエスケープシーケンス
  REGEXPP：STRING が正規表現か否かを指定します。

使用できるエスケープシーケンスは以下の通りです。
  \t     タブ
  \n     改行
  \r     復帰
  \f     改頁
  \v     垂直タブ
  \xNN   2桁までの16進数
  \XNNNN 4桁までの16進数

使用例：
  ;;; [\thoge]という6文字をデコードして5文字にする。
  "\\thoge"
  => "\\thoge"
  (decode-escape-sequence "\\thoge" nil)
  => "  hoge"
  (length "\\thoge")
  => 6
  (length (decode-escape-sequence "\\thoge" nil))
  => 5


■decode-mime-header
[       type]: Function
[  arguments]: decode-mime-header
[    package]: editor
[       file]: encdec.l
[    section]: その他
[description]: 
現在行から下にRFC822ヘッダを探してMIMEデコードします。


■decode-universal-time
[       type]: Function
[  arguments]: decode-universal-time UNIVERSAL-TIME &optional TIME-ZONE
[    package]: lisp
[    seealso]: format-date-string , encode-universal-time
[   referred]: file-write-time , format-date , get-decoded-time , get-universal-time , set-file-write-time
[       file]: builtin.l
[    section]: 日付・時間
[description]: 
ユニバーサルタイム形式の時間から日時に変換します。

  UNIVERSAL-TIME : ユニバーサルタイム形式の時間を指定します。
  TIME-ZONE      : タイムゾーンを指定します。

変換された日時は多値で返されます。multiple-value-***系のマクロで受け取り
ましょう。日時からユニバーサルタイム形式の時間に変換するには、
encode-universal-timeを使用します。

使用例：
  ;;; .xyzzyの最終更新日(2003/3/30 9:34:25)を取得する。
  (multiple-value-list
   (decode-universal-time
    (file-write-time ".xyzzy")))
  => (25 34 9 30 3 2003 6 nil -9)

参照：
  timestmp.l


■default-directory
[       type]: Function
[  arguments]: default-directory &optional BUFFER
[    package]: editor
[    seealso]: set-default-directory
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
バッファが作業しているディレクトリを返します。

  BUFFER : バッファを指定します。
           指定がなければカレントバッファになります。

そのバッファでfind-file するときに最初に表示されるディレクトリのことです。
このディレクトリは M-x: cd や set-default-directoryで変更することができ
ます。

使用例：
  ;;; デフォルトディレクトリを移動してみる。
  (default-directory)
  => "C:/applications/xyzzy/site-lisp/"
  (cd "../..")
  => t
  (default-directory)
  => "C:/applications/"


■default-value
[       type]: Function
[  arguments]: default-value SYMBOL
[    package]: lisp
[    seealso]: symbol-value , setq-default
[       file]: builtin.l
[    section]: シンボル
[description]: 
シンボルのデフォルトの値を返します。
シンボルがバッファローカルでないならば、symbol-valueと同じ値を返します。
シンボルがバッファローカルの時にデフォルトの値を持たない場合には、エラー
になります。デフォルトの値はsetq-defaultで指定します。

使用例：
  ;;; シンボルがデフォルトの値を持たない場合
  (make-local-variable 'foo)    => t
  (setq foo 123)                => 123
  (default-value 'foo)          => 変数が定義されていません: foo

  ;;; バッファローカルなシンボルの場合
  (defvar-local bar 234)        => bar
  (setq bar 345)                => 345
  (default-value 'bar)          => 234


■defconstant
[       type]: Macro
[  arguments]: defconstant NAME VALUE &optional DOC
[    package]: lisp
[    seealso]: constantp , defvar
[       file]: evalmacs.l
[    section]: 変数と定数
[description]: 
定数を宣言します。

使用例：
  ;;; encoding.lの中より
  (defconstant *eol-crlf* 1)
  => *eol-crlf*


■define-abbrev-table
[       type]: Function
[  arguments]: define-abbrev-table TABNAME &optional DEFS
[    package]: editor
[    seealso]: *abbrev-table-name-list* , *local-abbrev-table* , *global-abbrev-table*
[       file]: abbrev.l
[    section]: テキスト
[description]: 
abbrev-tableを定義します。

  TABNAME : abbrev-tableの名前にあたるシンボル
  DEFS    : 静的略称展開の定義のリスト

また、TABNAMEが*abbrev-table-name-list*に登録され、編集やファイル出力と
いった操作が可能になります。

使用例:
  ;;; c-mode.lの定義
 (defvar *c-mode-abbrev-table* nil)
 (unless *c-mode-abbrev-table*
   (define-abbrev-table '*c-mode-abbrev-table*))


■define-command-bar
[       type]: Function
[  arguments]: define-command-bar SYM NAME &optional EDGE X Y W
[    package]: editor
[    seealso]: delete-command-bar
[   referred]: create-tool-bar
[       file]: cmdbar.l
[    section]: メニュー
[description]: 
※以下は私見です。

ツールバーやタブバーを総称してツールバーと呼ぶようです。作成するときやツ
ールバーのリストを操作するときは全てtool-bar系の関数を使います。単に表示
するだけならば、show-tool-barを使えば可能です。

ただし、メニューの[表示]-[ツールバー]の一覧に追加する場合には、
command-bar系の関数を使います。define-command-barで登録したツールバーは、
[表示]-[ツールバー]から表示を制御することが可能です。予め、
define-command-barで定義したSYMに対応する、ツールバー・タブバーを作って
おく必要があります。

以下はタブバーを操作する場合の例です。

  (progn
    (defun a-func (a) (msgbox "~A ~A" a (type-of a)))
    (define-command-bar 'a-bar "a bar")
    (create-tab-bar 'a-bar 'a-func)
    (show-command-bar 'a-bar)
    (tab-bar-add-item 'a-bar '1st "- 1st -" "1st item")
    (tab-bar-add-item 'a-bar '2nd "- 2nd -" "2nd item"))

  (progn
    (tab-bar-delete-item 'a-bar '1st)
    (tab-bar-delete-item 'a-bar '2nd)
    (delete-tool-bar 'a-bar)
    (delete-command-bar 'a-bar))

また、ユーザのツールバーなどを作成する場合には、delete-command-barで削除
する手順を考慮することをおすすめします。コマンドバーは（シンボル名だけ）
ヒストリ変数に格納されます。その実体（ツールバーやタブバー）がなくとも、
ずっと[表示]-[ツールバー]に残ってしまいます。そのようなときは、手動で削
除する必要があります。

似たような話で、コマンドバーには関数名だけを指定しておいて、後から本体を
読み込みたい場合には、autoloadで出来ます。本体の初期化に時間が掛かる場合
には、このように分離するほうが良いと思います。

使用例：
  ------------------------------------------------
  ;;; .xyzzy
  (progn
    (define-command-bar 'a-bar "a bar")
    (autoload 'a-bar "a-bar.l"))
  ------------------------------------------------

  ------------------------------------------------
  ;;; a-bar.l
  (progn
    (create-tab-bar 'a-bar 'a-func)
    (show-command-bar 'a-bar)
    (tab-bar-add-item 'a-bar '1st "- 1st -" "1st item")
    (tab-bar-add-item 'a-bar '2nd "- 2nd -" "2nd item"))
  ------------------------------------------------


■define-condition
[       type]: Macro
[  arguments]: define-condition NAME (PARENT-TYPE) &rest BODY
[    package]: lisp
[    seealso]: handler-case , error , エラー処理関係 , make-condition
[       file]: condition.l
[    section]: エラー
[description]: 
新しいコンディションを定義します。
新しく定義したコンディションは error で投げたり
handler-case で処理したりできます。

コンディションは構造体からできています。
親となるコンディションにスロットが定義されている場合、
新しいコンディションにもそれらのスロットが引き継がれます。

  NAME        : コンディションの名前
  PARENT-TYPE : 親となるコンディション
  BODY
    第一要素  コンディションに追加するスロットの名前のリスト
    それ以降  以下のどれか一つを car として持つリスト
      :documentation  コンディションの説明を設定します。
      :report         エラー報告用の関数を指定します。
      :important      important な構造体になる？（詳細不明）

使用例:
  ;; lisp/condition.l より
  (define-condition check-type-error (type-error)
    (string place)
    (:report (lambda (c s)
               (format s "`~A'の値`~S'は~:[~S~;~:*~A~]ではありません"
                       (check-type-error-place c)
                       (check-type-error-datum c)
                       (check-type-error-string c)
                       (check-type-error-expected-type c)))))

  ;; 自分で定義してみる
  (define-condition my-error (error)
    (string) ; 新しいスロット :string を追加
    (:documentation "自分で定義したコンディション")
    (:report (lambda (c s) ; c はコンディション、s は出力ストリーム
               (format s "エラーです: ~A"
                       (my-error-string c))))
    (:important t))
  => t
  (error 'my-error :string "test")
  => エラーです: test
  (documentation 'my-error 'type)
  => "自分で定義したコンディション"


■define-history-variable
[       type]: Macro
[  arguments]: define-history-variable NAME &optional (INITIAL-VALUE nil sv) DOC
[    package]: editor
[    seealso]: register-history-variable , unregister-history-variable
[       file]: history.l
[    section]: 変数と定数
[description]: 
ヒストリ変数を定義します。

  NAME          : ヒストリ変数名を指定します。
  INITIAL-VALUE : 初期値を設定します。
  DOC           : 変数の説明を指定します。

ヒストリ変数とは、次回のxyzzyの立ち上げまで値を保持してくれる(lispを書く
人には)便利な変数です。ヒストリ変数がないと各マクロごとに独自の保存方法
をとらないといけませんが、ヒストリ変数のおかげで宣言するだけで変数の状態
を保存することが可能な優れものです。

ただし、一旦作成したヒストリ変数はいつまでも残ってしまうので、
不要になったらed::*history-variable-list*を確認した上で、
unregister-history-variableで削除して下さい。

使用例：
  ;;; grepd.lより
  (define-history-variable *grep-directory-history* nil)
  (define-history-variable *grep-file-history* nil)


■define-key
[       type]: Function
[  arguments]: define-key KEYMAP KEY COMMAND
[    package]: editor
[    seealso]: undefine-key , global-set-key , local-set-key , substitute-key-definition , make-keymap , キー表現使用可能文字 , 各種言語キーマップ
[   referred]: use-keymap
[       file]: builtin.l
[    section]: キーマップ
[description]: 
キーマップのキーにコマンドを割り当てます。

  KEYMAP  : キーマップ
  KEY     : 登録するキー
  COMMAND : 実行するコマンド

使用例：
  ;;; Ctrl-X fのキー割り当てを変える
  (define-key ctl-x-map #\f 'my-find-file)
  => t 
  ;;; Esc-f のキー割り当てを変える
  (define-key esc-map #\f 'my-find-file)
  => t
  ;;; Ctrl-C aのキー割り当てを変える
  (define-key spec-map #\a 'my-find-file)
  => t


■define-menu
[       type]: Macro
[  arguments]: define-menu &body BODY
[    package]: editor
[    seealso]: create-menu , add-menu-item , insert-menu-item , add-menu-separator , insert-menu-separator , copy-menu-items , delete-menu , get-menu , set-menu , use-local-menu , define-popup-menu
[   referred]: get-menu-position
[       file]: menu.l
[    section]: メニュー
[description]: 
固定的なメニューを定義します。
定義方法は define-popup-menu を参照して下さい。動的にメニューを生成した場
合には create-menu を参照して下さい。 define-menu で生成したメニューも
add-menu-item や insert-menu-item などで項目を追加することも可能です。


■define-popup-menu
[       type]: Macro
[  arguments]: define-popup-menu &body BODY
[    package]: editor
[    seealso]: create-popup-menu , track-popup-menu , add-popup-menu , insert-popup-menu , define-menu
[   referred]: add-menu-separator , insert-menu-separator
[       file]: menu.l
[    section]: メニュー
[description]: 
固定的なポップアップメニューを定義します。

  BODY : メニューの定義を記述します。

BODYをインチキなBNFで書くと以下の様になります。

  POPUP-DEF : {MENU-ITEM}*

  MENU-ITEM : :sep
            : (:sep [TAG])
            | (:separator [TAG])
            | (:popup tag name {POPUP-DEF}*)
            | (:item tag name [COMMAND [INIT]])

  TAG       : メニュー項目を識別する任意のオブジェクトです。
              タグ同士はeqで比較されます

  COMMAND   : メニュー項目が選択されたときに実行されるコマンドです。

  INIT      : メニューが開く直前に評価され、返される値によってメニューの
              状態が設定されます。任意のS式が指定できますが、あまり無茶
              なことはしないでください。式の値として意味のある値には以下
              のものがあります。

        :modified     カレントバッファが変更されていなければ灰色表示
        :undo         undo不可能であれば灰色表示
        :redo         redo不可能であれば灰色表示
        :selection    カレントバッファのテキストが未選択であるか矩形選択
                      であれば灰色表示
        :rectangle    カレントバッファのテキストが未選択であるか矩形以外
                      の選択であれば灰色表示
        :clipboard    クリップボードが空であれば灰色表示
        :check        チェック
        :disable      灰色表示
        その他        使用可能

使用例：
  ;;; niftylog.l
  (define-popup-menu
    (:item nil "メッセージを読んだことにする(&R)"
     'log-read-article)
    (:item nil "メッセージを読んでないことにする(&N)"
     'log-unread-article)
    (:item nil "スレッドを読んだことにする(&T)"
     'log-read-thread)
    (:item nil "スレッドを読んでないことにする(&H)"
     'log-unread-thread)
    (:item nil "ニュースグループを読んだことにする(&G)")
    (:item nil "ニュースグループを読んでないことにする(&P)"))
  => #<menu 48698340>


■defmacro
[       type]: Macro
[  arguments]: defmacro NAME (&rest LAMBDA-LIST) &body BODY
[    package]: lisp
[    seealso]: macroexpand , ``'(backquote)
[   referred]: macrolet
[       file]: evalmacs.l
[    section]: マクロ
[description]: 
マクロを定義します。

使用例：
  ;;; cadrをマクロで定義し直した場合
  (defmacro cadr (x)
    (list 'car (list 'cdr x)))
  => cadr
  (macroexpand '(cadr y))
  => (car (cdr y))

参考：
  --- 亀井さんの説明 [xyzzy:03975] ---
  
  マクロは 2 回評価される関数みたいなものと思っていれば
  間違いないでしょう(ただし 1 回目の評価のときには引数の
  評価はされない)。ごく簡単な例をあげると、
  
    (defmacro foo ()
      '(+ 1 2))
  
  このように定義して (foo) を評価すると、1 回目の評価で
  (+ 1 2) が返り、それをさらに評価して 3 が返る、となり
  ます。引数がある場合も同様に、
  
    (defmacro bar (n)
      (list '+ 1 n))
  
    (bar 3)
    -> (+ 1 3)
    => 4
  
  となります。
  
  | (M (any1) (any2) (any3)) と呼び出すと、
  |     (progn
  |       (m-setup)
  |       (any1)
  |       (any2)
  |       (any3)
  |       (m-cleanup))
  | と呼ばれるのと同じよう動作するものはどうしたら良いですか？
  
  この場合、引数が 3 つなので、こうなります。
  
    (defmacro M (a b c)
      (list 'progn '(m-setup) a b c '(m-cleanup)))
  
    (M (any1) (any2) (any3))
    -> (progn (m-setup) (any1) (any2) (any3) (m-cleanup))
    => ?
  
  ふつ〜、引数は何個でもありだろうってなときは、通常の関
  数と同様に &rest で受けてやればいいわけですね。
  
    (defmacro M2 (&rest args)
      (append '(progn) '((m-setup)) args '((m-cleanup))))
  
    (M2 (any1) (any2) (any3))
    -> (progn (m-setup) (any1) (any2) (any3) (m-cleanup))
    => ?
  
  ちなみに、1 回目がどのように評価されているか(マクロの
  展開)を見るには macroexpand を使います。
  
    (macroexpand '(M2 (any1) (any2) (any3)))
    => (progn (m-setup) (any1) (any2) (any3) (m-cleanup))
  
  複雑なマクロ定義だと、list やら append やら cons やら 
  quote やらをごちゃごちゃ書くのがめんどくせ〜、というわ
  けでテンプレートを使うことができます。詳しい説明は面倒
  なのでしませんが(^^; 上の例をテンプレートを使って書く
  とこのようになります。
  
    (defmacro M (a b c)
      `(progn
         (m-setup)
         ,a ,b ,c
         (m-cleanup)))
  
    (defmacro M2 (&rest args)
      `(progn
         (m-setup)
         ,@args
         (m-cleanup)))


■defpackage
[       type]: Macro
[  arguments]: defpackage PACKAGE-NAME &rest OPTIONS
[    package]: lisp
[    seealso]: make-package , find-package , use-package , delete-package , in-package , package-name , package-nicknames , パッケージ
[   referred]: *package* , list-all-packages
[       file]: package.l
[    section]: パッケージ
[description]: 
新しくパッケージを作ります。

  :internal-size  内部シンボルのハッシュサイズ
  :external-size  外部シンボルのハッシュサイズ

:internal-size 及び :external-size の大きさは、だいたい登録するシンボル
数の1/3ぐらいの値でいいでしょう。この値が足らないからといって、新しいシ
ンボルが登録できない訳ではないので、たいして気にする必要はないでしょう。
ハッシューがチェーンされて、検索(intern時のみ）がちょっと遅くなるだけで
す。こだわる方は素数を選ぶでしょう。

使用例：

  ;;; henmiというパッケージを作る。
  ;;; lisp, editorをuseしています。
  (defpackage "henmi"
     (:use "lisp" "editor")
     (:internal-size 200)
     (:external-size 10))

互換性:
  :internal-size, :external-size はcommonにはない。


■defparameter
[       type]: Macro
[  arguments]: defparameter NAME VALUE &optional DOC
[    package]: lisp
[    seealso]: defvar
[       file]: evalmacs.l
[    section]: 変数と定数
[description]: 
グローバルなスペシャル変数を宣言し、指定した値に設定します。
defvar に似ていますが、VALUE は省略できません。
また NAME がすでに値を持つ場合でも VALUE が評価され、結果が変数値として
設定されます。


■defstruct
[       type]: Macro
[  arguments]: defstruct NAME-AND-OPTIONS &rest REST
[    package]: lisp
[       file]: struct.l
[    section]: 変数と定数
[description]: 
構造体を定義します。C言語のstruct文に相当します。
オプションとして以下のものを指定できます。
以下、xxxx の部分には構造体名が入ります。

  :conc-name         通常、xxxx-スロット名 という名前を持つ関数で変数に
                     アクセスしますが、この名前を変更します。xxxx- 
                     の部分に相当する名前を指定します。
  :constructor       指定したコンストラクタを生成します。
                     複数の :constructor 宣言することができます。 引数には
                       コンストラクタ名 (変数名1 変数名2 ... 変数名n)
                     の様に指定します。&key や &optionalを使用したり、
                     スロットのデフォルト値とは異なるデフォルト値を指定できま
                     す。
                     コンストラクタを明示的に生成しても、xyzzyの場合、暗黙的な
                     コンストラクタが生成されてしまいますが、この動作はCLtL2の
                     示す動作と異なります。
                     これ以上の詳細は不明です。
  :copier            コピー関数名を指定したものに変更します。異なる動作をする
                     関数を指定できるわけではありません。
                     コピー関数は、新しい構造体オブジェクトを作ってスロットを
                     コピーします。新旧の構造体で各スロットは、同じオブジェク
                     トを共有します。
  :predicate         指定された構造体であるか否かを調べる関数名を指定します。
                     この名前を持つ述語をシステムが生成します。
                     デフォルトは、 xxxx-p です。
  :include           他の構造体名を指定することで、構造体を継承します。
                     継承した構造体にある変数の宣言が、この構造体でも宣言され
                     ているものとして扱われます。
                     これ以上の詳細は不明です。
  :print-function    オブジェクトを print する時に使われる関数を指定します。
                     format関数の ~A などでオブジェクトをプリントする時に呼び出
                     される関数が変わります。指定する関数は3つの引数をとり、
                     順にオブジェクト、ストリーム、（詳細不明）をとります。
                     第3引数は、pretty printに関する値が来ます。
                     :print-function が指定されない場合、 #S 構文でプリントさ
                     れます。
  :type              （詳細不明）
  :named             （詳細不明）
  :initial-offset    （詳細不明）

引数:
  NAME-AND-OPTIONS   オプションを指定しないときは構造体名、オプションを指定する
                     ときは、
                       (構造体名 (オプション名1 値1) (オプション名2 値2) ... )
                     の様に指定します。
  REST               構造体のスロットを指定します。スロット名のみを書くか、
                       (スロット名 デフォルト値 :type タイプ名 :read-only フラグ) 
                     の様に書いてひとつのスロットを定義します。 
                     :type と :read-only は、逆順にしても片方のみでも構いません。
                     リスト形式で書いた場合、後ろから順に省略できます。
                     タイプ名は、この構造体のオブジェクトであるかどうかを調べる
                     述語の生成に使うことができますが、xyzzy では使われていない
                     ようです。

特にオプション指定しないと make-xxxx, copy-xxxx, xxxx-p, xxxx-変数名 という関数
が作られるようです。 

  make-xxxx     デフォルトのコンストラクタ
  copy-xxxx     デフォルトのコピー関数
  xxxx-p        指定された構造体であるか否かを調べる関数
  xxxx-変数名   変数へのアクセス関数

定義：
  ;;; struct.lの定義
  (defmacro defstruct (name-and-options &rest rest)
    (eval-when (:compile-toplevel :load-toplevel :execute)
      (defstruct-helper name-and-options rest)))

使用例：
  ;;; FTPサーバを表す構造体の場合
  ;;; 初期値を予め指定することも可能
  (defstruct ftpsvr 
     anonymous hostname (port 80))
  => #<structure-definition: ftpsvr>
  (setq f1 (make-ftpsvr))
  => #S(ftpsvr anonymous nil hostname nil port 80)
  (setq f2 (make-ftpsvr  :anonymous t :hostname "ftp.world.com"))
  => #S(ftpsvr anonymous t hostname "ftp.world.com" port 80)
  (setq f3 #S(ftpsvr anonymous nil hostname "localhost"))
  => #S(ftpsvr anonymous nil hostname "localhost" port 80)

  ;;; 人を表す構造体の場合
  (defstruct person
     (name nil :type string)
     age
     (bloodtype "A"))
  => #<structure-definition: person>
  (setq p1 (make-person :name "Mike" :age 19))
  => #S(person name "Mike" age 19 bloodtype "A")
  (person-name p1)
  => "Mike"
  (setq p2 (copy-person p1))
  => #S(person name "Mike" age 19 bloodtype "A")
  (setf (person-bloodtype p1) "O")
  => "O"
  (person-bloodtype p1)
  => "O"
  (person-bloodtype p2)
  => "A"

  ;;; 患者を表す構造体の場合
  (defstruct (patient
             (:conc-name p-)
             (:print-function
              (lambda (o s p)
                (format s "<patient ~A ~D ~A>" (p-name o) (p-age o) (p-sicks o))))
              (:include person))
     (sicks nil :type (or nil list))
     id)
  => #<structure-definition: patient>
  (setq p3 (make-patient :name "Lucy" :age 18 :sicks '("かぜ")))
  => #S(patient name "Lucy" age 18 bloodtype "A" sicks ("かぜ") id nil)
  (format nil "~A" p3)
  => "<patient Lucy 18 (かぜ)>"


■deftype
[       type]: Macro
[  arguments]: deftype NAME (&rest LAMBDA-LIST) &rest BODY
[    package]: lisp
[    seealso]: si:canonicalize-type , subtypep , typep , 型一覧
[       file]: typespec.l
[    section]: データ型
[description]: 
NAME と言う名前のデータ型を定義します。
定義したデータ型は typep や subtypep などで使うことができます。
ただし typep で使う場合には、使用前に si:canonicalize-type で
処理することが必要なようです。

使用例:
  ;; lisp/typespec.l より
  ;; mod という型を定義
  (deftype mod (n)
    `(integer 0 ,(1- n))) ; 0 以上 n 未満の整数
  (typep 3 (si:canonicalize-type '(mod 5)))
  => t

  ;; 奇数型を作ってみる
  (deftype odd ()
    `(and integer
          (satisfies oddp)))
  (typep 3 (si:canonicalize-type 'odd))
  => t
  (subtypep 'odd 'integer)
  => t
  => t


■defun
[       type]: Macro
[  arguments]: defun NAME (&rest LAMBDA-LIST) &body BODY
[    package]: lisp
[    seealso]: lambda
[       file]: evalmacs.l
[    section]: 関数
[description]: 
関数を定義します。NAME がすでに関数定義を持つ場合は上書きされます。
BODY の先頭に documentation 文字列や interactive 宣言を含めることができます。


■defvar
[       type]: Macro
[  arguments]: defvar NAME &optional (INITIAL-VALUE () SV) DOC
[    package]: lisp
[    seealso]: defparameter , defvar-local , defconstant
[       file]: evalmacs.l
[    section]: 変数と定数
[description]: 
グローバルなスペシャル変数を宣言します。
宣言された変数はダイナミックなスコープを持つようになります。
INITIAL-VALUE が与えられた場合、NAME が変数としての値を持たなければ
INITIAL-VALUE を評価し、その結果を変数値として設定します。


■defvar-local
[       type]: Macro
[  arguments]: defvar-local NAME INITIAL-VALUE &optional DOC
[    package]: editor
[    seealso]: make-local-variable , setq-default , local-variable-p , buffer-local-value , defvar
[       file]: misc.l
[    section]: 変数と定数
[description]: 
変数NAMEがバッファ毎に異なる値を持つようにします。関連する関数として、
defvar/make-local-variable等がありますが、それぞれ機能が異なります。
defvar-localはdefvarと異なり、スペシャル変数とはならないので注意が必要です。

  defvar              : スペシャル変数を作る。
  defvar-local        : 全バッファで変数が独自の値を持つようにする。
  make-local-variable : 特定のバッファで変数が独自の値を持つようにする。

また、defvar-localだけではその変数はローカル変数にはならないようです。バ
ッファでsetqをして初めてローカルになる（local-variable-pがtになる）よう
です。

使用例：
  ;;; defvarとdefvar-localを使ってダイナミックかレキシカルかを確認する。
  (defvar var 3)
  => var  
  (defvar-local var-local 3)
  => var-local
  
  (defun foo () (let ((var 4) (var-local 4)) (bar)))
  => foo
  (defun bar () (format nil "var : ~S, var-local : ~S" var var-local))
  => bar
  
  (foo)
  => "var : 4, var-local : 3"
(defvar-local *dabbrevs-case-fold* nil)


■delete
[       type]: Function
[  arguments]: delete ITEM SEQUENCE &key :from-end :test :test-not :start :end :count :key
[    package]: lisp
[    seealso]: remove , delete-if , delete-if-not , delete-duplicates
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCEの中でITEMと一致するものを削除したシーケンスを返します。
引数 SEQUENCE は破壊されます。

  :count    : 削除する文字数を制限します。
  :from-end : :countが指定された場合にのみ意味を持ちます。
         nil    SEQUENCEの先頭から削除します。
         t      SEQUENCEの後尾から削除します。

使用例：
  ;;; removeとdeleteを使ってみる。
  (setq foo "abcabcdef")        => "abcabcdef"
  (remove #\b foo)              => "acacdef"
  foo                           => "abcabcdef"
  (delete #\b foo)              => "acacdef"
  foo                           => "acacdef"


■delete-all-pseudo-frames
[       type]: Function
[  arguments]: delete-all-pseudo-frames &optional (CREATE-NEW t)
[    package]: editor
[    seealso]: delete-pseudo-frame
[       file]: pframe.l
[    section]: ウィンドウ
[description]: 
フレームをすべて削除します。

  CREATE-NEW : すべて削除した後に、新しいフレームを作るかどうか
        t        作る
        nil      作らない

各フレームごとにスロット deleted-fn に登録された関数が実行されます。


■delete-backward-char
[       type]: Function
[  arguments]: delete-backward-char &optional (N 1)
[    package]: editor
[    seealso]: delete-backward-char-or-selection , delete-char
[   referred]: backward-delete-char-untabify , backward-delete-char-untabify-or-selection
[       file]: cmds.l
[    section]: テキスト
[description]: 
カーソル後方の文字を指定文字数分だけ削除します。


■delete-backward-char-or-selection
[       type]: Function
[  arguments]: delete-backward-char-or-selection &optional (N 1)
[    package]: editor
[    seealso]: delete-char-or-selection
[   referred]: delete-backward-char
[       file]: cmds.l
[    section]: テキスト
[description]: 
セレクションがあればセレクション全体を、そうでなければカーソルの後方の
文字を削除します。[C-h]


■delete-blank-lines
[       type]: Function
[  arguments]: delete-blank-lines
[    package]: editor
[       file]: cmds.l
[    section]: テキスト
[description]: 
カーソルのある行またはその次の行の前後に続く空行を削除します。[C-x C-o]
複数の空行が続く場合は改行文字を一つだけ残します。

なお空行とは半角スペースおよびタブのみからなる行のことです。


■delete-buffer
[       type]: Function
[  arguments]: delete-buffer BUFFER
[    package]: editor
[    seealso]: *before-delete-buffer-hook* , *delete-buffer-hook* , kill-buffer , deleted-buffer-p
[   referred]: delete-window
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファを削除しますが、kill-bufferと違い対話的に削除するかどうかは聞き
ません。kill-bufferも内部的にはdelete-bufferを使っています。

delete-bufferでは以下の二つのフックが順番に実行されます。

  *before-delete-buffer-hook*
        delete-bufferを継続するかどうかを制御します。登録された関数が一
        つでもnilを返すとdelete-bufferを中止します。

  *delete-buffer-hook*
        delete-bufferされるバッファで何か処理を行う場合に使用します。


■delete-char
[       type]: Function
[  arguments]: delete-char &optional (N 1)
[    package]: editor
[    seealso]: delete-char-or-selection , delete-backward-char
[       file]: cmds.l
[    section]: テキスト
[description]: 
指定文字数分だけ削除します。


■delete-char-or-selection
[       type]: Function
[  arguments]: delete-char-or-selection &optional (N 1)
[    package]: editor
[    seealso]: delete-char , delete-selection
[   referred]: delete-backward-char-or-selection
[       file]: cmds.l
[    section]: テキスト
[description]: 
セレクションで選択中ならばセレクション全体を、そうでなければカーソルの位
置の文字を削除します。delete-charとはセレクション時の動作が異なります。
[C-d], [Delete]


■delete-command-bar
[       type]: Function
[  arguments]: delete-command-bar SYM
[    package]: editor
[    seealso]: define-command-bar
[       file]: cmdbar.l
[    section]: メニュー
[description]: 
ツールバーを削除します。


■delete-directory
[       type]: Function
[  arguments]: delete-directory DIRNAME &key :if-does-not-exist :if-access-denied
[    package]: lisp
[    seealso]: delete-file , create-directory
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
ディレクトリを削除します。

  DIRNAME            : 削除するディレクトリ名を指定します。
  :if-does-not-exist : ディレクトリが存在しない場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
  :if-access-denied  : アクセスが拒否された場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
        :force          強制的に削除を試みます。

削除できたかどうかで戻り値が変わります。

  t   削除に成功
  nil 削除に失敗

使用例：
  (delete-directory "C:/xyzzy/testdir")
  => t


■delete-duplicates
[       type]: Function
[  arguments]: delete-duplicates SEQUENCE &key :from-end :test :test-not (:start 0) (:end (length SEQUENCE)) (:key #'identity)
[    package]: lisp
[    seealso]: delete , remove-duplicates
[       file]: sequence.l
[    section]: シーケンス
[description]: 
SEQUENCE の中から重複する要素を削除したシーケンスを返します。
delete 同様、引数 SEQUENCE は破壊されます。

 :from-end  non-nil ならシーケンスの終わりから重複する要素を削除していきます。


■delete-file
[       type]: Function
[  arguments]: delete-file FILE &key :if-does-not-exist :if-access-denied :recycle
[    package]: lisp
[    seealso]: delete-directory , rename-file , copy-file
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
ファイルを削除します。

  FILE               : 削除するファイル名を指定します。
  :if-does-not-exist : ファイルが存在しない場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
  :if-access-denied  : アクセスが拒否された場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
        :force          強制的に削除を試みます。

削除できたかどうかで戻り値が変わります。

  t   削除に成功
  nil 削除に失敗

使用例：  
  (delete-file "C:/xyzzy/test.txt")
  => t


■delete-file-in-archive
[       type]: Function
[  arguments]: delete-file-in-archive ARCHIVE-FILE &rest FILES
[    package]: editor
[    seealso]: create-archive , extract-archive
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
アーカイブから指定したファイルを削除します。

  ARCHIVE-FILE : アーカイブを指定します。
  FILES        : 削除するファイルを指定します。

使用例：
  ;;; c:/tmp/foo.lzh から xyz.c を削除します。
  (delete-file-in-archive "c:/tmp/foo.lzh" "xyz.c")


■delete-hook
[       type]: Function
[  arguments]: delete-hook HOOK FN
[    package]: editor
[    seealso]: add-hook
[       file]: misc.l
[    section]: モード
[description]: 
フック変数から関数を削除します。

  HOOK : フック変数のシンボルを指定します。
  FN   : 関数のシンボルを指定します。


■delete-horizontal-spaces
[       type]: Function
[  arguments]: delete-horizontal-spaces
[    package]: editor
[    seealso]: just-one-space
[       file]: cmds.l
[    section]: テキスト
[description]: 
同一行内のカーソル位置の前後の空白を削除します。[ESC \]


■delete-if
[       type]: Function
[  arguments]: delete-if PREDICATE SEQUENCE &key :from-end :start :end :count :key
[    package]: lisp
[    seealso]: remove-if , delete , delete-if-not
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCEの中でPREDICATEを満たすものを削除したシーケンスを返します。
引数 SEQUENCE は破壊されます。


■delete-if-not
[       type]: Function
[  arguments]: delete-if-not PREDICATE SEQUENCE &key :from-end :start :end :count :key
[    package]: lisp
[    seealso]: remove-if-not , delete , delete-if
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCEの中でPREDICATEを満たさないものを削除したシーケンスを返します。
引数 SEQUENCE は破壊されます。


■delete-indentation
[       type]: Function
[  arguments]: delete-indentation &optional ARG
[    package]: editor
[    seealso]: just-one-space , newline-and-indent
[       file]: cmds.l
[    section]: 文字列
[description]: 
インデントを削除し直前の行と連結します。[ESC ^]
連結する行とされる行は、半角スペースで区切られます。

  ARG : 連結する行を指定します。
        t   次行のインデントを削除し、現在の行に連結します。
        nil 現在の行のインデントを削除し、直前の行に連結します。


■delete-last-ime-composition
[       type]: Function
[  arguments]: delete-last-ime-composition
[    package]: editor
[       file]: kanji.l
[    section]: 文字列
[description]: 
IME 変換直後であれば、直前に変換した文字列を削除します。[C-c C-d]


■delete-marker
[       type]: Function
[  arguments]: delete-marker MARKER
[    package]: editor
[    seealso]: unset-marker
[   referred]: process-marker
[       file]: builtin.l
[    section]: ポジション
[description]: 
マーカーを削除します。
オブジェクトはマーカーとして使えなくなります。
成功した場合 t、すでに削除されていた場合は nil を返します。

使用例：
  (delete-marker m)
  => t
  m
  => #<deleted-marker 128914348>


■delete-menu
[       type]: Function
[  arguments]: delete-menu MENU TAG-OR-POSITION &optional TAG-OR-POSITION-P
[    package]: editor
[   referred]: define-menu
[       file]: builtin.l
[    section]: メニュー
[description]: 
メニューから項目等を削除します。

  MENU              : 削除するメニューを指定します。
  TAG-OR-POSITION   : タグもしくは位置を指定します。
  TAG-OR-POSITION-P : TAG-OR-POSITIONの引数をタグとして解釈するか位置と
                      して解釈するかを決めます。
           nil     TAG-OR-POSITIONはタグを表すシンボル
           non-nil TAG-OR-POSITIONは位置を表す整数値
  
タグを指定した場合にはメニューを再帰的に検索し最初に見つかった項目を削除
します。 タグが存在しない場合やメニュー項目数以上の位置を指定した場合に
は、削除に失敗します。

戻り値は以下のとおりです。

  t   削除に成功した。
  nil 削除に失敗した。


■delete-other-windows
[       type]: Function
[  arguments]: delete-other-windows
[    package]: editor
[    seealso]: delete-window
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
現在カーソルがあるウィンドウ以外のウィンドウを削除します。 [C-x 1]
ただし、現在カーソルがあるウィンドウがミニバッファウィンドウの場合は他の
ウィンドウを削除しません。

戻り値：
  t     ウィンドウの削除に関わらず t 固定


■delete-package
[       type]: Function
[  arguments]: delete-package PACKAGE
[    package]: lisp
[    seealso]: make-package , defpackage , パッケージ
[   referred]: find-package
[       file]: builtin.l
[    section]: パッケージ
[description]: 
パッケージを削除します。

使用例：
  ;;; test 用パッケージを作る
  (defpackage "test")
  => #<package: test>
  (find-package "test")
  => #<package: test>
  ;;; test パッケージを削除する
  (delete-package "test")
  => t
  (find-package "test")
  => nil


■delete-pseudo-frame
[       type]: Function
[  arguments]: delete-pseudo-frame &optional (FRAME ed::*current-pseudo-frame*)
[    package]: editor
[    seealso]: new-pseudo-frame , delete-all-pseudo-frames
[   referred]: ed::pseudo-frame
[       file]: pframe.l
[    section]: ウィンドウ
[description]: 
フレームを削除します。[C-x 6 0]
最後のひとつを削除した場合、即座に新しいフレームが作られます。

  FRAME : 削除するフレーム

FRAME のスロット deleted-fn に関数が設定されている場合、FRAME が削除される前に funcall されます。


■delete-rectangle
[       type]: Function
[  arguments]: delete-rectangle P1 P2
[    package]: editor
[    seealso]: kill-rectangle , delete-rectangle-selection , operate-on-rectangle
[       file]: rectangl.l
[    section]: リージョン
[description]: 
P1 と P2 で指定される矩形領域を削除します。


■delete-rectangle-selection
[       type]: Function
[  arguments]: delete-rectangle-selection
[    package]: editor
[    seealso]: kill-rectangle-selection , delete-rectangle , operate-on-rectangle-selection
[       file]: select.l
[    section]: リージョン
[description]: 
矩形選択されたセレクションの領域を削除します。


■delete-region
[       type]: Function
[  arguments]: delete-region FROM TO
[    package]: editor
[       file]: builtin.l
[    section]: リージョン
[description]: 
指定された範囲を削除します。


■delete-text-attribute-point
[       type]: Function
[  arguments]: delete-text-attribute-point POINT
[    package]: editor
[    seealso]: delete-text-attributes
[   referred]: clear-all-text-attributes , find-text-attribute-point
[       file]: builtin.l
[    section]: テキスト
[description]: 
POINT の位置のテキスト属性を削除します。
テキスト属性のうち POINT の位置を範囲に含むものを削除します。


■delete-text-attributes
[       type]: Function
[  arguments]: delete-text-attributes TAG &key :test :test-not :key
[    package]: editor
[    seealso]: delete-text-attribute-point , delete-text-attributes-if , clear-all-text-attributes , set-text-attribute
[   referred]: clear-all-text-colors , delete-text-attributes-if-not
[       file]: builtin.l
[    section]: テキスト
[description]: 
set-text-attributeで指定したタグの属性を消します


■delete-text-attributes-if
[       type]: Function
[  arguments]: delete-text-attributes-if TEST &key :key
[    package]: editor
[    seealso]: delete-text-attributes-if-not , delete-text-attributes
[       file]: builtin.l
[    section]: テキスト
[description]: 
テキスト属性のうち、タグが TEST を満たすものをすべて削除します。


■delete-text-attributes-if-not
[       type]: Function
[  arguments]: delete-text-attributes-if-not TEST &key :key
[    package]: editor
[    seealso]: delete-text-attributes-if , delete-text-attributes
[       file]: builtin.l
[    section]: テキスト
[description]: 
テキスト属性のうち、タグが TEST を満たさないものをすべて削除します。


■delete-tool-bar
[       type]: Function
[  arguments]: delete-tool-bar NAME
[    package]: editor
[    seealso]: create-tool-bar
[       file]: builtin.l
[    section]: メニュー
[description]: 
ツールバーNAMEを削除します。
コマンドバーとして登録していた場合には、[表示]-[ツールバー]に残骸が残っ
てしまいますので、delete-command-barで削除する必要があります。


■delete-trailing-spaces
[       type]: Function
[  arguments]: delete-trailing-spaces
[    package]: editor
[       file]: cmds.l
[    section]: テキスト
[description]: 
ポイント後方の連続するスペースを削除します。


■delete-window
[       type]: Function
[  arguments]: delete-window
[    package]: editor
[    seealso]: set-window , delete-other-windows , minibuffer-window-p , delete-buffer , deleted-buffer-p
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
現在カーソルがあるウィンドウを削除します。 [C-x 0]
ミニバッファウィンドウは削除できません。
また、ミニバッファウィンドウ以外のウィンドウが現在のウィンドウのみの場合
は simple-error を発生します。

ウィンドウ削除後は、以下の条件のうち、最も優先度の高い条件を満たすミニ
バッファウィンドウ以外のウィンドウの領域を広げ、そのウィンドウを
set-window します。
  1. 削除ウィンドウの左辺と、右辺が一致したウィンドウ
  2. 削除ウィンドウの右辺と、左辺が一致したウィンドウ
  3. 削除ウィンドウの上辺と、底辺が一致したウィンドウ
  4. 削除ウィンドウの底辺と、上辺が一致したウィンドウ

戻り値：
  t     ウィンドウ削除成功
  nil   ウィンドウ削除失敗

補足：
  xyzzy 0.2.2.233 では (delete-buffer X) に対して (deleted-buffer-p X)
  が存在しますが、(delete-window X) に対して (deleted-window-p X) は存在
  しません。
  ;;; deleted-buffer-p を模した deleted-window-p の定義
  (in-package "editor")
  (export '(deleted-window-p))
  (defun deleted-window-p (window)
    (unless (windowp window)
      (error 'lisp::type-error :datum window :expected-type 'window))
    (handler-case
        (progn
          (window-buffer window)
          t)
      (program-error (c)
        nil)))


■deleted-buffer-p
[       type]: Function
[  arguments]: deleted-buffer-p BUFFER
[    package]: editor
[    seealso]: delete-buffer
[   referred]: delete-window , kill-buffer
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファが削除されているかどうかを調べます。
BUFFERにはバッファ型のものしか指定できません。

  t   指定されたバッファは既に削除されています。
  nil 指定されたバッファは未だ削除されていません。


■denominator
[       type]: Function
[  arguments]: denominator RATIONAL
[    package]: lisp
[    seealso]: numerator , /
[       file]: builtin.l
[    section]: 数値
[description]: 
分数の分母を返します。


■deposit-field
[       type]: Function
[  arguments]: deposit-field NEWBYTE BYTESPEC INTEGER
[    package]: lisp
[    seealso]: ldb , dpb
[       file]: number.l
[    section]: 数値
[description]: 
指定されたフィールドを NEWBYTE の同じフィールドの内容で置き換えた値を返
します。

使用例：
  (format nil "~2,'0x" (deposit-field #x0f (byte 4 4) #xa7))
  =>"07"
  (format nil "~2,'0x" (deposit-field #xaa (byte 4 4) #x0f))
  =>"af"


■describe-bindings
[       type]: Function
[  arguments]: describe-bindings
[    package]: editor
[       file]: keymap.l
[    section]: キーマップ
[description]: 
カレントバッファのキー割り当て一覧を表示します。


■describe-function
[       type]: Function
[  arguments]: describe-function SYMBOL
[    package]: editor
[    seealso]: describe-variable
[       file]: help.l
[    section]: シンボル
[description]: 
指定された関数の引数と docstring を表示します。


■describe-key
[       type]: Function
[  arguments]: describe-key KEY
[    package]: editor
[    seealso]: describe-key-briefly
[       file]: help.l
[    section]: キーマップ
[description]: 
指定したキーにバインドされた関数と docstring を表示します。


■describe-key-briefly
[       type]: Function
[  arguments]: describe-key-briefly KEY &optional ARG
[    package]: editor
[    seealso]: describe-key
[       file]: help.l
[    section]: キーマップ
[description]: 
指定したキーにバインドされた関数を表示します。[C-x ?]

  KEY : 検索するキー
  ARG : 出力(表示)先をどこにするか
        nil     : ステータスバーに表示
        non-nil : バッファに「キー (関数名)」のフォーマットで文字列を出力


■describe-variable
[       type]: Function
[  arguments]: describe-variable SYMBOL
[    package]: editor
[    seealso]: describe-function
[       file]: help.l
[    section]: シンボル
[description]: 
指定された変数の現在の値、種類(constant or special)および docstring を表
示します。


■detect-char-encoding
[       type]: Function
[  arguments]: detect-char-encoding STRING-OR-STREAM
[    package]: editor
[    seealso]: set-stream-encoding , stream-encoding , convert-encoding-from-internal , convert-encoding-to-internal
[   referred]: map-char-encoding-region
[       file]: builtin.l
[    section]: テキスト
[description]: 
STRING-OR-STREAM の文字エンコーディングを判定します。


■dialog
[       type]: Function
[  arguments]: dialog X Y W H &rest CONTROLS
[    package]: lisp
[    seealso]: dialog-box
[    section]: ダイアログ
[description]: 
ダイアログを定義します。

  X Y      : ダイアログの表示位置を指定します。
  W H      : ダイアログの大きさを指定します。
  CONTROLS : コントロールを指定します。

コントロールをxyzzyで作成するのは面倒なので、VisualC++のリソース作成画面
で、部品を配置して変換する方法が用意されています。新しくバッファを作って 
*.rcファイルから必要な部分を持ってきた後で、

  M-x convert-dialog-template-buffer

バッファ名を選択するとlisp形式に変換されます。


■dialog-box
[       type]: Function
[  arguments]: dialog-box TEMPLATE INITIAL-VALUE CHECK-OR-DISABLE
[    package]: editor
[    seealso]: dialog , file-name-dialog , directory-name-dialog , drive-dialog
[       file]: builtin.l
[    section]: ダイアログ
[description]: 
ダイアログボックスを表示します。ダイアログはdialogで定義されたものを使います。

  TEMPLATE :
      lispの形式で記述されたダイアログテンプレートを指定します。
      詳細は、関数dialogを参照してください。

  INITIAL-VALUE :
      エディトボックス等に入れる、文字列などを指定します。
      特に指定しない場合はnilでもかまいません。

  CHECK-OR-DISABLE :
      チェックボックス等の初期選択状態を指定します。
      特に指定しない場合はnilでもかまいません。

戻り値は多値なので、 multiple-value-bind 等で受け取る必要があります。1番
目の戻り値は、cancelボタンが押されたらnil、okボタンが押されたらtが返ります。
  
使用例：
  ;;; テスト用のダイアログを定義します。
  (setq *test-dialog-template*
    `(dialog 0 0 300 100 
             (:caption "について")
             (:font 9 "ＭＳ Ｐゴシック")
             (:control
              (:static nil nil #x50020003 7 7 18 21)
              (:static nil ,(concat "XYZZY version "
                                    (software-version))
               #x50020000 34 7 92 8)
              (:static nil "Copyright (C) 1996, 97 T.Kamei"
               #x50020000 34 17 92 8)
              (:button IDOK "OK" #x50010001 52 35 36 14))))

  ;;; テスト用のダイアログを表示します。
  (defun test-dialog ()
    (interactive)
    (dialog-box *test-dialog-template* nil nil)
    t)


■digit-argument
[       type]: Function
[  arguments]: digit-argument RAW &optional ARG
[    package]: editor
[    seealso]: universal-argument , negative-argument
[       file]: cmds.l
[    section]: 関数
[description]: 
後に続くコマンドに前置引数を渡します。[ESC 0 ... ESC 9]


■digit-char
[       type]: Function
[  arguments]: digit-char WEIGHT &optional (RADIX 10)
[    package]: lisp
[    seealso]: digit-char-p
[       file]: builtin.l
[    section]: 文字
[description]: 
RADIX を基数とした場合の WEIGHT の表示上の文字を返します。
下の例ですと、 (digit-char 12 16) は16進表記した場合の12は、
#\C になります。WEIGHT が RADIX 以上になると nil が返ります。

使用例：
  (digit-char 7)
  => #\7
  (digit-char 12)
  => nil
  (digit-char 12 16)
  => #\C
  (digit-char 6 2)
  => nil
  (digit-char 1 2)
  => #\1


■digit-char-p
[       type]: Function
[  arguments]: digit-char-p CHAR &optional (RADIX 10)
[    package]: lisp
[    seealso]: digit-char , characterp
[       file]: builtin.l
[    section]: 文字
[description]: 
CHAR が数字ならその数字の10進表現での値を、そうでなければ nil を返します。

  RADIX : 基数

使用例：  
  (digit-char-p #\1)
  => 1
  (digit-char-p #\a)
  => nil
  (digit-char-p #\a 16)
  => 10
  (digit-char-p #\RET)
  => nil


■ding
[       type]: Function
[  arguments]: ding
[    package]: editor
[    seealso]: undefined
[       file]: builtin.l
[    section]: その他
[description]: 
音を鳴らします？（詳細不明）

使用例：
  ;;; 音を鳴らす。
  (ding)
  => nil


■directory
[       type]: Function
[  arguments]: directory PATHNAME &key :absolute :recursive :wild :depth :file-only :show-dots :count :directory-only :callback :file-info
[    package]: lisp
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
対象ディレクトリ下のファイル名をリストで得ます。

  PATHNAME        : 検索するディレクトリのパスです。
  :absolute       : 検索結果をフルパスで取得します。
  :recursive      : サブディレクトリも対象とするかを制御します。
        t               サブディレクトリの中まで検索
        nil             サブディレクトリの中までは検索しない
  :wild           : ワイルドカード指定です。リストでも可です。
  :depth          : :recursive 指定するときの再帰の深さです。
  :file-only      : ファイルしか検索しません。
  :show-dots      : ディレクトリとして"./"と"../"を加えます。
  :count          : 表示されるファイルの個数を制限します。
  :directory-only : ディレクトリしか検索しません。
  :callback       : 見つかったファイルを引数にして funcall します。
                    funcall した結果をリストにして返します。
  :file-info      : ファイルの属性を取得します。
                    get-file-info で取得できるものと同じです。

使用例：
  ;;;  "../"は出したいけど、"./"を出したくない場合
  (delete "./" (directory ... :show-dots t) :test #'string=)

  ;;; "C:/"の配下を一覧表示する。
  (directory "C:/" :callback #'(lambda (x) (print x)))

  ;;; ファイル名のソート（大文字小文字区別有り）
  (sort (directory ...) #'string<)

  ;;; ファイル名のソート（大文字小文字区別有り）
  (sort (directory ...) #'string-lessp)


■directory-name-dialog
[       type]: Function
[  arguments]: directory-name-dialog &key :title :default
[    package]: editor
[    seealso]: file-name-dialog , read-directory-name
[   referred]: dialog-box , drive-dialog
[       file]: builtin.l
[    section]: ダイアログ
[description]: 
ディレクトリを指定するダイアログを表示します。
ユーザーが指定したディレクトリを返します。
  
  :title   : ダイアログのタイトル
  :default : 初期表示するディレクトリ

使用例：
  ;;; ミニバッファからディレクトリ名を読み取る。
  (directory-name-dialog)
  => "C:/applications/xyzzy/site-lisp"


■directory-namestring
[       type]: Function
[  arguments]: directory-namestring PATHNAME
[    package]: lisp
[    seealso]: pathname-directory , file-namestring , remove-trail-slash
[   referred]: merge-pathnames
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
PATHNAMEのディレクトリ部分を返します。

使用例：  
  (directory-namestring "C:/xyzzy/xyzzy.exe")
  => "C:/xyzzy/"
  (directory-namestring "~/test.txt")
  => "C:/HOME/"
  (directory-namestring "/usr/local/bin")
  => "C:/usr/local/"


■display-first-tab-char
[       type]: Variable
[    package]: editor
[    seealso]: display-rest-tab-char
[       file]: defs.l
[    section]: 文字
[description]: 
タブの表示に使用する文字を設定します。最初の文字は
display-first-tab-charで設定し、以降の文字は
display-rest-tab-charで設定します。
xyzzy 0.2.2.215〜

使用例：
  (setq-default display-first-tab-char #\rightwards_arrow_to_bar)
  (setq-default display-rest-tab-char nil)


■display-newline-char
[       type]: Variable
[    package]: editor
[       file]: defs.l
[    section]: 文字
[description]: 
改行の表示に使用する文字を設定します。
  半角文字  指定した文字で表示
  nil       空白で表示
  上記以外  従来の文字で表示

使用例：
  (setq-default display-newline-char #\downwards_arrow_with_tip_leftwards)


■display-rest-tab-char
[       type]: Variable
[    package]: editor
[    seealso]: display-first-tab-char
[       file]: defs.l
[    section]: 文字
[description]: 
タブの表示に使用する文字を設定します。
詳しくは display-first-tab-char を参照してください。


■do
[       type]: Macro
[  arguments]: do (&rest VARLIST) (&optional END-TEST &rest RESULT) &body BODY
[    package]: lisp
[   referred]: do*
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
(do ((var1 init1 step1)
     (var2 init2 step2)
            ...
     (varm initm stepm))
    (end-test result1 result2 ... resultm) 
   declaration1
       ...
   declarationN)

(do ((<変数1> <初期値1> <ステップ1>)
     (<変数2> <初期値2> <ステップ2>)
              ...
     (<変数m> <初期値m> <ステップm>))
    (<<終了条件> <後式1> ... <後式p>) 
   <式1>
   ...
   <式n>)


<変数1>〜<変数m>までを局所変数とし，<終了条件>が真
になるまでdo式本体の<式1>〜<式n>を繰り返し実行する。<
変数1>〜<変数m>までは変数を表す記号で，do式の中で局所的に使
われる変数を指定する。do式が評価されるときは，まず<初期値1>〜
<初期値m>までが評価され，その値が各局所変数にバインドされる。そ
の後で，<終了条件>が評価され，もし値がnilであれば本体を実行する。
次に<ステップ1>〜<ステップm>までを評価してその値を各局所
変数に代入してから<終了条件>を評価する。これを<終了条件>
の値がnil以外になるまで繰り返す。<終了条件>の値がnil以外になっ
たら，<終了条件>に続く<後式1>〜<後式p>を評価し，そ
の最後の式の値をdo式の値とする。

do式の一般形は，

(block nil
  (let ((<変数1> <初期値1> <ステップ1>)
        (<変数2> <初期値2> <ステップ2>)
                 ...
        (<変数m> <初期値m> <ステップm>))
    (tagbody
      loop
      (when <終了条件>
        (return (progn <後式1> ... <後式p>)))
      <式1>
      ...
      <式n>
     (psetq <変数1> <ステップ1>
              ...
            <変数m> <ステップm>)
      (go loop))))

と同値である。(loop というタグは他では使われていないものとする)


■do*
[       type]: Macro
[  arguments]: do* (&rest VARLIST) (&optional END-TEST &rest RESULT) &body BODY
[    package]: lisp
[    seealso]: do , let , let*
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
doと同じようにループ処理を行う。
doとだいたい同じだけど、letとlet*の違いのように、局所変数の初期化と更
新の方法にある。doはletを使って局所変数を初期化しているため、全ての初
期値を計算してから局所変数をバインドするが，do*ではletの代わりにlet*
が使われている。またpsetqのかわりにsetqを使う。

do*式の一般形は、

(block nil
  (let* ((<変数1> <初期値1> <ステップ1>)
         (<変数2> <初期値2> <ステップ2>)
                  ...
         (<変数m> <初期値m> <ステップm>))
    (tagbody
      loop
      (when <終了条件>
        (return (progn <後式1> ... <後式p>)))
      <式1>
      ...
      <式n>
     (setq <変数1> <ステップ1>
              ...
           <変数m> <ステップm>)
      (go loop))))

と同値である。(loop というタグは他では使われていないものとする)


■do-all-symbols
[       type]: Macro
[  arguments]: do-all-symbols (VAR &optional RESULT-FORM) &body BODY
[    package]: lisp
[    seealso]: with-package-iterator
[   referred]: do-external-symbols , do-symbols
[       file]: package.l
[    section]: パッケージ
[description]: 
全シンボルを列挙します。

  VAR         : 列挙されたシンボルを格納する変数名を指定します。
  RESULT-FORM : （詳細不明）
  BODY        : 実行するフォームを指定します。

使用例：
  ;;; シンボルを列挙して変数・関数・マクロ・パッケージを出力してみる。
  (do-all-symbols (sym)
    (and (or (boundp sym)
             (fboundp sym))
         (format t "~:[ ~;V~]~:[ ~;F~]~:[ ~;M~] ~A ~S~%"
                 (boundp sym)
                 (fboundp sym)
                 (macro-function sym)
                 (package-name (symbol-package sym))
                 sym)))


■do-completion
[       type]: Function
[  arguments]: do-completion FROM TO TYPE &optional COMPL WORD LAST-CHAR (POPUP-P *POPUP-COMPLETION-LIST-DEFAULT*)
[    package]: editor
[       file]: complete.l
[    section]: テキスト
[description]: 
テキストの補完をします。
詳細は*do-completionを参照して下さい。

使用例：
  ;;; カーソルの直前のパスを補完します。
  (do-completion (point) 
                 (progn (skip-syntax-spec-backward "^ ") (point))
                 :file-name)


■do-events
[       type]: Function
[  arguments]: do-events
[    package]: lisp
[    seealso]: refresh-screen , sit-for , sleep-for
[       file]: builtin.l
[    section]: その他
[description]: 
長い処理の途中に、Windowsのイベントを処理してあげるおまじないらしい。

使用例：
  ;;; イベント処理をしてみる。
  (do-events)
  => nil


■do-external-symbols
[       type]: Macro
[  arguments]: do-external-symbols (VAR &optional (PACKAGE () SV) RESULT-FORM) &body BODY
[    package]: lisp
[    seealso]: do-all-symbols , do-symbols
[       file]: package.l
[    section]: 制御構造
[description]: 
do-symbols と似ていますが、外部シンボルのみに対して繰り返しを行います。


■do-symbols
[       type]: Macro
[  arguments]: do-symbols (VAR &optional (PACKAGE () SV) RESULT-FORM) &body BODY
[    package]: lisp
[    seealso]: do-external-symbols , do-all-symbols , dolist
[       file]: package.l
[    section]: 制御構造
[description]: 
シンボルすべてについて繰り返しを行います。
動作としては dolist に似ています。

do-all-symbols と違って特定のパッケージだけを探します。正確にはパッケ
ージの外部シンボル・内部シンボルおよび、そのパッケージが use している
他パッケージの外部シンボルが対象になります。

  VAR           : BODY 実行中に各シンボルに束縛される変数
  PACKAGE       : シンボルを探すパッケージ (デフォルトは *package*)
  RESULT-FORM   : do-symbols の戻り値
  BODY          : 繰り返しの本体


■dolist
[       type]: Macro
[  arguments]: dolist (VAR LISTFORM &optional (RESULTFORM ''())) &body BODY
[    package]: lisp
[   referred]: do-symbols
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
リストの長さ分だけ繰り返しを行います。

  (dolist (<変数> <リスト式> <値>)
    <式1> ... <式n>)

まず<リスト式>を評価する。その後リストの要素ごとに変数をその要素に
バインドして，本体の<式1>〜<式n>までを評価する。本体式の評価
が全ての要素に対して終わると，<値>を評価し，dolistの値として返す。
また<値>は省略でき，その場合はdolistの値はnilである。

dolist式の一般形は，
  
  (do* ((temp <リスト式> (cdr temp))
        (<変数> (car temp) (car temp)))
      ((endp temp) <値>)
    <式1>
    ...
    <式n>)
  
と同値である。

使用例：
  (let ((result nil))
    (dolist (item '("Lois" "Charley" "David") (nreverse result))
      (push (length item) result)))
  => (4 7 5)


■dotimes
[       type]: Macro
[  arguments]: dotimes (VAR COUNTFORM &optional (RESULTFORM ''())) &body BODY
[    package]: lisp
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
(dotimes (<変数> <整数式> <値>)
  <式1> ... <式n>)

指定された回数だけ繰り返しを行います。

まず<整数式>を評価します。その値をnとすると、0〜n-1までのそれぞれの
整数値に対して、<変数>をその整数値にバインドして、本体の<式1>〜<式n>
までを評価します。すなわち本体式はn回繰り返されます。本体式の評
価がn回繰り返されると、<値>を評価し、dotimesの値として返します。
また<値>は省略でき、その場合dotimesの戻り値はnilです。

dotimes式の一般形は、

(do* ((temp <整数式>)
      (<変数> 0 (1+ <変数>)))
    ((>= <変数> temp) <値>)
  <式1>
  ...
  <式n>)

と同値です。


■double-float-p
[       type]: Function
[  arguments]: double-float-p OBJECT
[    package]: lisp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECT が double-float なら t 、それ以外なら nil を返します。


■down-list
[       type]: Function
[  arguments]: down-list &optional ARG NO-ERRORS
[    package]: editor
[    seealso]: backward-sexp , backward-list , up-list
[       file]: builtin.l
[    section]: ポジション
[description]: 
カーソルを前方にある ARG 個内側の括弧の後ろに移します。[ESC C-d]

  (setq lst '(a b c)) ; ここから
       ^
  (setq lst '(a b c)) ; ここへ
              ^

前方に括弧が見つからなかった場合、
NO-ERRORS が nil の場合にはエラーを、 t の場合には nil を返します。
また、直近にある括弧しか見つけられないようです。

  (defun test () (setq lst '(a b c))) ; ここから ARG = 2 で down-list すると
     ^                                ; エラーになる


■downcase-region
[       type]: Function
[  arguments]: downcase-region FROM TO
[    package]: editor
[    seealso]: downcase-word , capitalize-region , upcase-region
[       file]: builtin.l
[    section]: リージョン
[description]: 
リージョン内の単語を小文字にします。[C-x C-l]


■downcase-word
[       type]: Function
[  arguments]: downcase-word &optional (ARG 1)
[    package]: editor
[    seealso]: upcase-word , capitalize-word , downcase-region , downcase-selection , string-downcase
[       file]: cmds.l
[    section]: 文字列
[description]: 
カーソル位置から単語の末尾までを小文字に変換します。[ESC l]


■dpb
[       type]: Function
[  arguments]: dpb NEWBYTE BYTESPEC INTEGER
[    package]: lisp
[    seealso]: ldb , deposit-field
[   referred]: byte
[       file]: number.l
[    section]: 数値
[description]: 
指定されたフィールドを NEWBYTE で置き換えた値を返します。

使用例：
  (format nil "~2,'0x" (dpb #x0f (byte 4 4) #xa7))
  =>"f7"
  (format nil "~2,'0x" (dpb #x0a (byte 4 4) #x0f))
  =>"af"


■drive-dialog
[       type]: Function
[  arguments]: drive-dialog &optional DRIVE
[    package]: editor
[    seealso]: file-name-dialog , directory-name-dialog
[   referred]: dialog-box
[       file]: builtin.l
[    section]: ダイアログ
[description]: 
ドライブ選択のダイアログを表示します。DRIVEで初期表示するドライブを選択
できます。選択したドライブのドライブ文字がキャラクタで返されます。

使用例：
  (drive-dialog)
  => #\R


■dump-xyzzy
[       type]: Function
[  arguments]: dump-xyzzy &optional FILENAME
[    package]: editor
[    seealso]: xyzzy-dumped-p , version-up-xyzzy
[   referred]: si:dump-image-path
[       file]: builtin.l
[    section]: システム
[description]: 
ダンプファイルをFILENAMEにして作成します。
既に作成されていても上書きします。
FILENAME省略時のファイル名は？（未確認）


■echo-stream-input-stream
[       type]: Function
[  arguments]: echo-stream-input-stream ECHO-STREAM
[    package]: lisp
[    seealso]: make-echo-stream
[       file]: builtin.l
[    section]: 入出力
[description]: 
make-echo-streamで作られたECHO-STREAMの入力元のストリームを返します。


■echo-stream-output-stream
[       type]: Function
[  arguments]: echo-stream-output-stream ECHO-STREAM
[    package]: lisp
[    seealso]: make-echo-stream
[       file]: builtin.l
[    section]: 入出力
[description]: 
make-echo-streamで作られたECHO-STREAMの出力先のストリームを返します。


■ed::*auto-save-session-file*
[       type]: Variable
[    package]: editor
[    seealso]: toggle-session-auto-save , close-session
[       file]: session.l
[    section]: バッファ
[description]: 
セッションの自動保存フラグです。

  nil     : 自動保存しない
  non-nil : 自動保存する


■ed::*last-search-regexp*
[       type]: Variable
[    package]: editor
[   referred]: re-search-backward-again , re-search-forward-again
[    section]: 検索・正規表現
[description]: 
前回の正規表現検索パターンが保存されています。


■ed::*last-search-string*
[       type]: Variable
[    package]: editor
[   referred]: search-backward-again , search-forward-again
[       file]: search.l
[    section]: 検索・正規表現
[description]: 
前回の検索語が保存されています。


■ed::*register-alist*
[       type]: Variable
[    package]: editor
[    seealso]: ed::get-register , ed::set-register
[       file]: register.l
[    section]: 変数と定数
[description]: 
レジスタに格納されている値を保持する変数。
中身は (name . datum) の形の連想リストです。
emacs と違い name にはどんな文字でも入るようです。

datum としては(通常は)以下のものが使用できます。
  マーカー
  文字列
  矩形領域(文字列のリスト)
  window configuration


■ed::build-summary-function
[       type]: BufferLocal
[    package]: editor
[    seealso]: list-function
[    section]: 関数
[description]: 
バッファ中の関数の一覧を取得します。行及び関数名を要素に持つリス
トで得られます。list-functionで使用されています。

使用例：
  ; listfn.lで評価
  (funcall ed::build-summary-function)
  => ((10 "lisp-build-summary-of-functions") (39 "lisp-maketags"))


■ed::find-file-internal
[       type]: Function
[  arguments]: find-file-internal FILENAME &optional NOWARN (KANJI-CODE nil SVAR) NEWLINE-CODE NOMSG
[    package]: editor
[    seealso]: find-file , *find-file-hooks* , *before-find-file-hook* , *find-file-file-not-found-hook* , *find-file-auto-mode-function* , buffer-read-only
[       file]: files.l
[    section]: ファイルシステム
[description]: 
ファイルを開きます。find-fileはfind-file-internalを用いて実装されています。
find-fileは複数のファイルを開く機能がありますが、一つのファイルを開くの
であれば、こちらの方が高速です。

  FILENAME : ファイル名


■ed::get-register
[       type]: Function
[  arguments]: get-register R
[    package]: editor
[    seealso]: ed::set-register , view-register
[   referred]: ed::*register-alist*
[       file]: register.l
[    section]: その他
[description]: 
レジスタ R の値を返します。何も入ってない場合の戻り値は nil です。


■ed::get-selection-start-end
[       type]: Function
[  arguments]: get-selection-start-end
[    package]: editor
[   referred]: selection-start-end
[       file]: select.l
[    section]: ポジション
[description]: 
セレクションの開始位置と終了位置を多値で返します。
ただし、矩形選択状態ではnilを返します。


■ed::map-selection
[       type]: Function
[  arguments]: map-selection FN
[    package]: editor
[       file]: select.l
[    section]: ポジション
[description]: 
セレクションの開始位置と終了位置を引数にして関数を呼び出します。

  FN : 呼び出す関数を指定します。呼び出し時には開始位置と終了位置を渡し
       ますので、そのような関数のI/Fにしておかなければなりません。

使用例：
  ;;;
  (defun map-test ()
    (interactive)
    (ed::map-selection #'(lambda (start end) (message (format nil "~s ~s" start end)))))

補足：
  editorパッケージからエクスポートされてないので、ed::をつける必要があります。
  選択の開始位置と終了位置を正確に渡すので、前後関係に注意して下さい。


■ed::pseudo-frame
[       type]: Struct
[    package]: editor
[    seealso]: new-pseudo-frame , select-pseudo-frame , delete-pseudo-frame , *select-pseudo-frame-hook*
[       link]: http://xyzzy.s53.xrea.com/qanda/wiki.cgi?p=e1d59f7af8a5ebd071340560b6ed41a2 , http://xyzzy.s53.xrea.com/wiki/index.php?QuickTour%2Fframe
[       file]: pframe.l
[    section]: ウィンドウ
[description]: 
フレームは pseudo-frame という構造体として、pframe.l 内で定義されています。
この構造体は以下のようなスロットを持っています。
  name        : フレームの名前
  winconf     : このフレームにおけるウィンドウの状態
  save-p      : セッション保存時にこのフレームを保存するかどうか
  selected-fn : このフレームを選択したときに実行される関数
  deleted-fn  : このフレームを削除するときに実行される関数

フレームを新しく作成するには new-pseudo-frame を使えばよく、
winconf 以外のスロットは new-pseudo-frame の引数として指定できます。
winconf はフレーム作成時や移動時に自動的に設定されます。

selected-fn および delete-fn に設定された関数は funcall によって呼び出されます。
*select-pseudo-frame-hook* と異なり、フレームごとに異なる関数を割り当てることができます。
また、selected-fn の関数は *select-pseudo-frame-hook* より先に実行されます。


■ed::set-register
[       type]: Function
[  arguments]: set-register R VALUE
[    package]: editor
[    seealso]: ed::get-register , view-register
[   referred]: ed::*register-alist*
[       file]: register.l
[    section]: その他
[description]: 
レジスタ R に値 VALUE を格納します。


■ed::toggle-mode
[       type]: Function
[  arguments]: toggle-mode VAR ARG SV
[    package]: editor
[   referred]: toggle-trace-on-error
[       file]: cmds.l
[    section]: モード
[description]: 
マイナーモードの状態を表す変数VARを設定します。
SVがnilならば状態は反転します。
ARGが負数もしくはnilならば無効になります。
ARGが非負数値もしくはnon-nilならば有効になります。


■eighth
[       type]: Function
[  arguments]: eighth X
[    package]: lisp
[    seealso]: nth
[       file]: list.l
[    section]: リスト
[description]: 
list の 8 番目の要素を返します。

  (eighth X) = (nth 7 X)

使用例：
  (eighth '(1 2 3 4 5 6 7 8 9 0))
  => 8


■eject-media
[       type]: Function
[  arguments]: eject-media DRIVE
[    package]: editor
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
DRIVEに指定したドライブをイジェクトします。
DRIVEはキャラクタで指定します。
使用例：
  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =>"C:/Applications/xyzzy/xyzzy.exe"
  
  (eject-media (svref a 0)) ; イジェクト不可能なドライブ
  =>指定されたデバイス名は無効です。 

  (eject-media #\P)
  =>t
(svref (default-directory) 0))


■elt
[       type]: Function
[  arguments]: elt SEQUENCE INDEX
[    package]: lisp
[    seealso]: nth
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCEのINDEX番目の要素を返します。
INDEXは0を基底とします。なければnilを返します。


■emacs-write-file
[       type]: Function
[  arguments]: emacs-write-file FILENAME
[    package]: editor
[    seealso]: save-buffer , write-file
[   referred]: *default-write-file-directory*
[       file]: files.l
[    section]: ファイルシステム
[description]: 
バッファの内容を FILENAME に書き込みます。
同時にバッファ名およびバッファに関連付けられたファイルも変更します。


■enable-post-buffer-modified-hook
[       type]: Function
[  arguments]: enable-post-buffer-modified-hook ENABLE &optional BUFFER
[    package]: editor
[    seealso]: post-buffer-modified-hook-enabled-p , post-buffer-modified-hook
[       link]: [xyzzy:06354]
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
post-buffer-modified-hookを有効・無効にします。
カレントバッファの値のみ変更します。

  ENABLE  : non-nil 有効にします
            nil     無効にします
  BUFFER  : 有効にするバッファを指定します。
            省略時やnilを与えた場合はカレントバッファを指定したとみなします。


■encode-universal-time
[       type]: Function
[  arguments]: encode-universal-time SECOND MINUTE HOUR DAY MONTH YEAR &optional TIME-ZONE
[    package]: lisp
[    seealso]: decode-universal-time , format-date-string
[       file]: builtin.l
[    section]: 日付・時間
[description]: 
日時からユニバーサルタイム形式の時間に変換します「1900年1月1日0時0分0秒
から指定された日時まで秒数」をユニバーサルタイム形式の時間と呼びます。

  SECOND    : 秒数
  MINUTE    : 分
  HOUR      : 時
  DAY       : 日
  MONTH     : 月
  YEAR      : 年
  TIME-ZONE : タイムゾーンを指定します。GMTからの差分の時間を指定するようです。
              省略すると選択しているタイムゾーンとの差分が使用されます。
              普通はGMTとJSTとの差分の-9(時間)となります。

ユニバーサルタイム形式の時間から日時への変換はdecode-universal-timeを使用します。

使用例：
  (encode-universal-time 0 0 0 1 1 1900)    => -32400
  (encode-universal-time 0 0 0 1 1 1900 0)  => 0
  (encode-universal-time 0 0 0 1 1 1900 -9) => -32400
  (encode-universal-time 0 30 18 24 4 2003) => 3260165400

参照：
  timestmp.l


■end-of-buffer
[       type]: Function
[  arguments]: end-of-buffer
[    package]: editor
[    seealso]: beginning-of-buffer , set-mark-command , selection-end-of-buffer
[       file]: cmds.l
[    section]: ポジション
[description]: 
カーソルをバッファの末尾に移動します。[ESC >]
元あったカーソル位置にはマークを設定します。

マークを変更しないためには
(goto-char (point-max))を使います。


■end-of-defun
[       type]: Function
[  arguments]: end-of-defun &optional (ARG 1)
[    package]: editor
[    seealso]: beginning-of-defun
[       file]: sexp.l
[    section]: 関数
[description]: 
カーソルを関数定義の末尾に移動します。[ESC C-e]


■end-of-line
[       type]: Function
[  arguments]: end-of-line
[    package]: editor
[    seealso]: beginning-of-line
[   referred]: selection-end-of-line
[       file]: cmds.l
[    section]: ポジション
[description]: 
現在行の終りに移動します。[C-e], [C-Right]


■end-of-virtual-line
[       type]: Function
[  arguments]: end-of-virtual-line
[    package]: editor
[    seealso]: goto-virtual-eol
[   referred]: selection-end-of-virtual-line
[       file]: cmds.l
[    section]: ポジション
[description]: 
表示行の行末に移動します。
goto-virtual-eol の interactive 版です。


■endp
[       type]: Function
[  arguments]: endp OBJECT
[    package]: lisp
[    seealso]: null
[       file]: builtin.l
[    section]: リスト
[description]: 
OBJECT が空かどうかを返します。
リストの終わりを判定するのに使用されます。 null と異なり、
例えば文字列を指定するとエラーを発生します。

  空リストもしくはnil   t
  空でないリスト        nil
  それ以外              エラー

使用例：
  ;;; nullとの違いを見てみる。
  (endp "foo")  => 不正なデータ型です: t: list
  (endp nil)    => t
  (null "foo")  =>nil
  (null nil)    => t


■enlarge-window
[       type]: Function
[  arguments]: enlarge-window &optional EXTEND VERTICAL
[    package]: editor
[    seealso]: shrink-window , enlarge-window-horizontally
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
ウィンドウの行数・桁数を変更します。[C-x z], [C-x ^]
VERTICALを指定しない場合には行数を変更します。

  EXTEND   : 大きくする行数・桁数を指定します。負数を指定すると小さくなります。
  VERTICAL : 桁・行のどちらを設定するか指定します。
        t       桁数を変更する。
        nil     行数を変更する。

使用例：
  ;;; ウィンドウを変更してみる。
  (enlarge-window 2 t)  => t
  (enlarge-window 100)  => 変更できません 


■enlarge-window-horizontally
[       type]: Function
[  arguments]: enlarge-window-horizontally &optional (ARG 1)
[    package]: editor
[    seealso]: shrink-window-horizontally , enlarge-window
[       file]: window.l
[    section]: ウィンドウ
[description]: 
カーソルのあるウィンドウの幅を大きくします。[C-x }]

使用例：
  ;;; listerのマージンからウィンドウの幅を引く場合
  (enlarge-window-horizontally (- *lister-margin* (window-width)))


■enum-buffers
[       type]: Function
[  arguments]: enum-buffers FN
[    package]: editor
[    seealso]: buffer-list
[       file]: builtin.l
[    section]: バッファ
[description]: 
関数がnil以外を返すまでバッファを列挙し続けます。

使用例：
  ;;; バッファを列挙し続ける。
  (enum-buffers #'(lambda (x) (and (yes-or-no-p "~S" x) x)))
  => #<buffer:  *Completion*>


■eobp
[       type]: Function
[  arguments]: eobp
[    package]: editor
[    seealso]: bobp
[       file]: builtin.l
[    section]: ポジション
[description]: 
ポイントがバッファの最後にあるかどうか調べます。

使用例：
  ;;; バッファの最後までカーソルをひとつひとつ進める？
  (while (not (eobp))
    (forward-char))


■eolp
[       type]: Function
[  arguments]: eolp
[    package]: editor
[    seealso]: bolp
[       file]: builtin.l
[    section]: ポジション
[description]: 
カーソルが行末にあるかどうか調べます。

  t     カーソルが行末にある
  nil   カーソルは行末にはない


■eq
[       type]: Function
[  arguments]: eq X Y
[    package]: lisp
[    seealso]: eql , equal , equalp
[       file]: builtin.l
[    section]: データ型
[description]: 
X と Y が同一オブジェクトならt、そうでないならnilを返します。数値や文字
列に対しては見かけ上同じでもtとなる保証はありません。xyzzyでは、数値はt
となるが文字列ではnilとなるように実装されているようです。

使用例：
  ;;; eqで比較してみる。
  (eq 'foo 'foo)        => t    ; 仕様
  (eq 2 2)              => t    ; 処理系依存
  (eq "foo" "foo")      => nil  ; 処理系依存
  (eq '(1 2) '(1 2))    => nil  ; 処理系依存


■eql
[       type]: Function
[  arguments]: eql X Y
[    package]: lisp
[    seealso]: eq , equal , equalp , char=
[   referred]: make-hash-table
[       file]: builtin.l
[    section]: データ型
[description]: 
X と Y が同一オブジェクトか、同じ型の数値または文字型で値が等しいかを返
します。等しければtを、そうでなければnilを返します。eqとは異なり、値とし
て等しいかを判断します。ただし、中身までは見ないので文字列は対象外となり
ます。

使用例：
  ;;; eqlで比較してみる。
  (eql 'foo 'foo)       => t    ; 仕様
  (eql 2 2)             => t    ; 仕様
  (eql "foo" "foo")     => nil  ; 処理系依存
  (eql '(1 2) '(1 2))   => nil  ; 処理系依存


■equal
[       type]: Function
[  arguments]: equal X Y
[    package]: lisp
[    seealso]: eq , eql , equalp , = , char= , string=
[       file]: builtin.l
[    section]: データ型
[description]: 
X と Y が同じ構造を持っていればtを、そうでなければnilを返します。

使用例：
  ;;; equalで比較してみる。
  (equal 'foo 'foo)     => t    ; 仕様
  (equal 2 2)           => t    ; 仕様
  (equal "foo" "foo")   => t    ; 仕様
  (equal '(1 2) '(1 2)) => t    ; 仕様


■equalp
[       type]: Function
[  arguments]: equalp X Y
[    package]: lisp
[    seealso]: eq , eql , equal , = , char-equal , string-equal
[       file]: builtin.l
[    section]: データ型
[description]: 
equalと同じように X と Y を比較します。
ただし、一部の差異を許容します。
例えば文字・文字列の比較では大文字と小文字を区別しません。

使用例：
  ;;; equalpで比較してみる。
  (equalp "Foo" "foo")  => t


■erase-buffer
[       type]: Function
[  arguments]: erase-buffer BUFFER
[    package]: editor
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファの内容を削除します。
以下の内容がクリアされます。
  ・バッファ上のテキスト
  ・変更フラグ
  ・修正日付
  ・restriction
  ・UNDO情報


■error
[       type]: Function
[  arguments]: error DATUM &rest ARGS
[    package]: lisp
[    seealso]: handler-case , ignore-errors , unwind-protect , エラー処理関係 , stack-trace , make-condition , si:*condition-string , si:*throw-error
[   referred]: define-condition , quit
[       file]: handler.l
[    section]: エラー
[description]: 
例外を発生します。

発生させた例外は上位の階層でハンドリングすることができます。
ハンドリングの方法はhandler-caseを参照して下さい。


■esc-map
[       type]: Variable
[    package]: editor
[    seealso]: meta-prefix
[       file]: keymap.l
[    section]: キーマップ
[description]: 
ESC に続くキーシーケンスのバインディングを格納するキーマップです。


■etc-path
[       type]: Function
[  arguments]: etc-path
[    package]: editor
[    seealso]: *etc-path*
[       file]: misc.l
[    section]: システム
[description]: 
*etc-path*を返します。


■eval
[       type]: Function
[  arguments]: eval FORM
[    package]: lisp
[       file]: builtin.l
[    section]: 評価
[description]: 
FORM を評価します。


■eval-buffer
[       type]: Function
[  arguments]: eval-buffer BUFFER
[    package]: editor
[    seealso]: eval-region
[       file]: lispmode.l
[    section]: 評価
[description]: 
バッファ全体を評価します。
eval-region を使って実装されています。


■eval-expression
[       type]: Function
[  arguments]: eval-expression X
[    package]: editor
[    seealso]: interactive
[       file]: cmds.l
[    section]: 評価
[description]: 
lisp 式 X を評価します。[ESC ESC]
対話的に呼び出された場合はミニバッファで入力された式を評価します。


■eval-region
[       type]: Function
[  arguments]: eval-region FROM TO &optional STREAM
[    package]: editor
[    seealso]: eval-buffer
[       file]: lispmode.l
[    section]: 評価
[description]: 
リージョン内に書かれたLispコードを評価します。

使用例：
  (eval-region from to (selected-buffer))


■eval-when
[       type]: Special Form
[  arguments]: eval-when ({SITUATION}*) {FORM}*
[    package]: lisp
[       file]: builtin.l
[    section]: 評価
[description]: 
ひとことで言うと、フォームをいつ評価するかってことです。

今回の例だと、define-dll-entry などのマクロはコンパイル時に展開
されなければならないのですが、define-dll-entry は foreign で定
義されているので、foreign がロードされていないとマクロであるこ
とが認識できません。(eval-when ...) がなく、単に (require 
"foreign") だけだと、コンパイル時には単なる関数コールだとみなさ
れてしまうため、マクロが展開されなくなってしまいます。そのため
に、eval-when でコンパイルするときも foreign をロードしろと指定
しているわけです。


          ソース                       ソース（左と同一）
            ↓  (eval)                   ↓  (compile)
      Lispインタープリタ           Lispコンパイラ
                                         ↓
                                        *.lc
                                         ↓   (load)
                                   Lispインタープリタ

C言語だと maxというのがマクロですよね。

#define max(a,b)   ((a>b)?a:b)

こんなん。

int foo(int x, int y)
{
   return max(x, y);
}
と書いたら、
int foo(int x, int y)
{
   return ((x> y) ? x : y);
}

こう書いたのと等価ですよね。
Ｃの入門書だとプリプロセッサがいったん展開してから、コンパイル
すると書かれていると思います。

lispだとこんなんになるんですが

----    test.l ---------

(defmacro macro-max (a b)
  `(if (> ,a ,b) ,a ,b))

(defun foo (x y)
  (macro-max x y))

------------------------

M-x byte-compile-fileってやったときに、
(defmacro macro-maxっていう文は、コンパイルするんでなくって
eval(インタープリタが評価する）しとかないといけない。

でないとfooのところで、コンパイル前にソースを展開できない。

だから eval-when (compile)なんです。
よくわからなかったら、３つ全部つけておけば大丈夫という説もある^^;

(eval-when (:compile-toplevel :load-toplevel :execute)

Common Lispの仕様書では、たしか eval, load, compile
だけ,だったと思います。

eval        --- インタープリタにロードするときeval
compile     --- compile時にeval
load        --- compileした*.lc をロードするときeval

(eval-when (:compile-toplevel :load-toplevel :execute)
って、今まで、xyzzyオリジナルかと思ってました。

でもallegloのhelpをみていたら、
(eval-when (:compile-toplevel :load-toplevel :execute)
ってありますね。^^;
知りませんでした。

| Common Lispの仕様書では、たしか eval, load, compile
| だけ,だったと思います。

CLtL1 ではそうだったんですが、CLtL2 で変わりました。


■evenp
[       type]: Function
[  arguments]: evenp INTEGER
[    package]: lisp
[    seealso]: oddp
[       file]: builtin.l
[    section]: 数値
[description]: 
INTEGERが偶数ならばt、そうでなければnilを返します。

使用例：  
  (evenp 2)
  => t
  (evenp 0)
  => t
  (evenp 1)
  => nil


■every
[       type]: Function
[  arguments]: every PREDICATE SEQUENCE &rest MORE-SEQUENCES
[    package]: lisp
[    seealso]: some , notevery
[       file]: sequence.l
[    section]: シーケンス
[description]: 
SEQUENCEの先頭の要素から順番にPREDICATEを適用していき、PREDICATEが
nil を返すと、nilをすぐに返します。
全ての要素がPREDICATEを満たす場合、 t を返します。

MORE-SEQUNCESが与えられた時、SEQUENCEの中で最も短いものの終わりまで実行されます。


■exchange-point-and-mark
[       type]: Function
[  arguments]: exchange-point-and-mark
[    package]: editor
[    seealso]: mark , goto-last-modified-line , goto-last-mouse-point
[       file]: cmds.l
[    section]: ポジション
[description]: 
カーソルとマークの位置を入れ替えます。[C-x C-x]


■execute-extended-command
[       type]: Function
[  arguments]: execute-extended-command COMMAND &optional RAW ARG
[    package]: editor
[    seealso]: command-execute , repeat-complex-command
[       file]: misc.l
[    section]: 評価
[description]: 
ミニバッファからコマンドを対話的に入力して実行します。[ESC x]


■execute-region
[       type]: Function
[  arguments]: execute-region FROM TO
[    package]: editor
[       file]: process.l
[    section]: プロセス
[description]: 
リージョンの内容をバッチファイルとして実行します。


■execute-shell-command
[       type]: Function
[  arguments]: execute-shell-command COMMAND &optional INFILE OUTPUT ENVIRON DIRECTORY
[    package]: editor
[    seealso]: call-process , execute-subprocess , shell-execute
[   referred]: pipe-command
[       file]: process.l
[    section]: プロセス
[description]: 
外部プログラムを実行します。結果だけをxyzzyに取り込みます。

  COMMAND    : 実行するコマンドをオプション付で指定します。
  INFILE     : 標準入力を使用する外部プログラムであれば入力ファイル名を
               指定します。
  OUTPUT     : 標準出力を出力するバッファを指定します。
  ENVIRON    : 設定する環境変数を連想リスト形式で渡します。
                (("HOME" . "C:/applications/xyzzy/")
                 ("TOPDIR" . "C:/spool/"))
  DIRECTORY  : 実行するディレクトリを指定します。

このコマンドは call-process を使って実装されています。
call-processとは違って標準出力をバッファに出力します。出力するバッファは完
全に破壊されますので注意してください。
外部プログラムとして実行したくない場合は， execute-subprocess を使います。

使用例：
  ;;; コマンドプロンプトのhelpを表示してみる。
  (execute-shell-command "help" nil (selected-buffer))


■execute-subprocess
[       type]: Function
[  arguments]: execute-subprocess CMD &optional ARG BUFNAME ENVIRON DIRECTORY
[    package]: editor
[    seealso]: make-process , execute-shell-command , filter-region , command-output-mode , shell-command-line
[       file]: process.l
[    section]: プロセス
[description]: 
プログラムを BUFFNAME で指定したバッファ上で実行します。[C-x &]
結果は， BUFFNAME で指定されたバッファ上に表示されます。

  CMD        : 実行するコマンドをオプション付で指定します。
  ARG        : (詳細不明)
  BUFNAME    : 関連付けるバッファ名を指定します。デフォルトは "*Command Output*" です。
               指定したバッファが存在しないとき，新しくバッファを作ります。
  ENVIRON    : 設定する環境変数を連想リスト形式で渡します。
                  (("HOME" . "C:/applications/xyzzy/")
                   ("TOPDIR" . "C:/spool/"))
  DIRECTORY  : 実行するディレクトリを指定します。 

指定されたバッファは command-output-mode になります。

使用例：
  ;;; cmd.exe をバッファ上で実行します。 シンプルなシェルとして動作します。
  (execute-subprocess "cmd.exe")
  =>#<buffer: *Command Output*>


■exp
[       type]: Function
[  arguments]: exp NUMBER
[    package]: lisp
[       file]: builtin.l
[    section]: 数値
[description]: 
自然対数の底 e の NUMBER 乗の数値を返します。

使用例：
  ;;; 自然対数の底 e とその二乗を表示してみる。
  (exp 1)
  => 2.718282
  (exp 2)
  => 7.389056


■expand-abbrev
[       type]: Function
[  arguments]: expand-abbrev
[    package]: editor
[    seealso]: abbrev-mode
[   referred]: *global-abbrev-table* , *local-abbrev-table* , *pre-abbrev-expand-hook*
[       file]: abbrev.l
[    section]: テキスト
[description]: 
カーソル位置で静的略称展開を行います。[C-x ']
abbrev-mode の時は self-insert-command でも実行されます。


■export
[       type]: Function
[  arguments]: export SYMBOLS &optional PACKAGE
[    package]: lisp
[    seealso]: パッケージ , use-package , どの関数の頭に何がつくのでしょうか？
[   referred]: unexport
[       file]: builtin.l
[    section]: パッケージ
[description]: 
シンボルをパッケージの外部から参照できるようにします。

引数で指定された シンボル（変数や関数）はパッケージからエクスポートされ、
別のパッケージから修飾子無しで参照できるようになります。ただし、修飾子無
しで参照するには、別のパッケージからもuse-packageもしておかないといけませ
ん。
                   use  ┌system──┐
                    ┌─┤          │
  ┌lisp───┐←─┘  └─────┘        ┌user───┐
  │          │←────────────┬─┤          │
  └─────┘←─┐  ┌editor──┐    │  └─────┘
                    └─┤          │←─┘
                        └─────┘

上の図はどのパッケージをuse-pakcageしているかを示しています。
パッケージがuseする他のパッケージはpackage-use-listを使って確認すること
ができます。userは、lispとeditorをuse-packageしています。

si:system-rootはsystemからexportされていますが、userがsystemを
use-packageしていないので修飾子が必要です。

  ;;; system-rootがsystemからexportされていることを確認する。
  (find-symbol "system-root" "system")
  => system:system-root
     :external

このためuserからsystem-rootを使用する場合には(si:system-root)という呼び
出し方になります。

使用例：
    ;;; 引数で指定された aset, file-name-sans-versions, ...は
    ;;; エクスポートされ、別のパッケージから参照できるようになる。
    (export '(aset file-name-directory file-name-nondirectory
          file-name-sans-versions))


■expt
[       type]: Function
[  arguments]: expt BASE-NUMBER POWER-NUMBER
[    package]: lisp
[       file]: builtin.l
[    section]: 数値
[description]: 
べき乗します。

使用例：  
  (expt 2 10)
  => 1024
  (expt 10 3)
  => 1000


■extended-alphabet-char-p
[       type]: Function
[  arguments]: extended-alphabet-char-p CHAR
[    package]: editor
[    seealso]: characterp
[    section]: データ型
[description]: 
CHAR が欧文(ISO8859)の単語構成文字かを判定します。


■extract-archive
[       type]: Function
[  arguments]: extract-archive ARCHIVE-FILE TO-DIRECTORY &rest FILES
[    package]: editor
[    seealso]: create-archive , delete-file-in-archive
[   referred]: find-file-in-archive
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
アーカイブを展開します。

ARCHIVE-FILE : 展開するアーカイブを指定します。
TO-DIRECTORY : 展開するディレクトリを指定します。
FILES        : 展開するファイルを指定します。指定しない場合は、全てのフ
               ァイルが展開されます。

使用例：
  ;;; d:/foo.lzh を c:/tmp に展開します。
  (extract-archive "d:/foo.lzh" "c:/tmp")


■fast-scroll-down
[       type]: Function
[  arguments]: fast-scroll-down
[    package]: editor
[    seealso]: fast-scroll-up , scroll-window
[       file]: cmds.l
[    section]: バッファ
[description]: 
高速に下スクロールします。[C-Up]


■fast-scroll-up
[       type]: Function
[  arguments]: fast-scroll-up
[    package]: editor
[    seealso]: fast-scroll-down , scroll-window
[       file]: cmds.l
[    section]: バッファ
[description]: 
高速に上スクロールします。[C-Down]


■fboundp
[       type]: Function
[  arguments]: fboundp SYMBOL
[    package]: lisp
[    seealso]: boundp , fmakunbound , macro-function
[       file]: builtin.l
[    section]: シンボル
[description]: 
シンボルに関数が定義されているかどうかを返します。

使用例：
  (fboundp 'car)
  => t
  (fboundp 't)
  => nil


■fceiling
[       type]: Function
[  arguments]: fceiling NUMBER &optional DIVISOR
[    package]: lisp
[    seealso]: ceiling
[       file]: builtin.l
[    section]: 数値
[description]: 
ceiling と同じですが浮動小数点数を返します。


■featurep
[       type]: Function
[  arguments]: featurep FEATURE
[    package]: lisp
[    seealso]: *features*
[       file]: evalmacs.l
[    section]: システム
[description]: 
FEATURE が *features* の要素であればそれ以降のリストを返します。
そうでなければ nil を返します。

使用例：
 ;;; process.l より
 (let ((shell (if (featurep :windows-nt) "cmd.exe" "command.com")))
   (defvar *shell* shell)
   (defvar *eshell* shell))


■ffloor
[       type]: Function
[  arguments]: ffloor NUMBER &optional DIVISOR
[    package]: lisp
[    seealso]: floor
[       file]: builtin.l
[    section]: 数値
[description]: 
floor と同じですが浮動小数点数を返します。


■fifth
[       type]: Function
[  arguments]: fifth X
[    package]: lisp
[    seealso]: nth
[       file]: list.l
[    section]: リスト
[description]: 
list の 5 番目の要素を返します。

  (fifth X) = (nth 4 X)

使用例：
  (fifth '(1 2 3 4 5 6 7 8 9 0))
  => 5


■file-directory-p
[       type]: Function
[  arguments]: file-directory-p PATHNAME
[    package]: lisp
[    seealso]: file-exist-p
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
PATHNAMEがディレクトリならt、そうでなければnilを返します。

使用例：  
  (file-directory-p "C:/xyzzy/")
  => t
  (file-directory-p "C:/xyzzy/xyzzy.exe")
  => nil
  (file-directory-p "~/")
  => t


■file-executable-p
[       type]: Function
[  arguments]: file-executable-p PATHNAME
[    package]: lisp
[    seealso]: file-exist-p
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
注）何故か実行ファイルでも、tが返らない気がする。
PATHNAMEが実行ファイルか否かを返します。

  t    実行ファイルである。
  nil  実行ファイルではない。


■file-exist-p
[       type]: Function
[  arguments]: file-exist-p PATHNAME
[    package]: lisp
[    seealso]: check-valid-pathname , file-readable-p , file-writable-p , file-executable-p , file-directory-p , file-write-time
[   referred]: valid-path-p
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
PATHNAMEが存在すればt、そうでなければnilを返します。

使用例：  
  (file-exist-p "C:/xyzzy/xyzzy.exe")
  => t
  (file-exist-p "~/")
  => t


■file-length
[       type]: Function
[  arguments]: file-length PATHNAME
[    package]: lisp
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
指定されたファイルの大きさをバイト単位で返します。

  PATHNAME : ファイル名を指定します。

使用例：
  (file-length "C:/xyzzy/xyzzy.exe")
  => 977408


■file-name-dialog
[       type]: Function
[  arguments]: file-name-dialog &key :char-encoding :eol-code :filter :filter-index :title :default :extension :save :multiple :must-exist :explorer :hide-read-only :initial-directory
[    package]: editor
[    seealso]: directory-name-dialog , open-file-dialog , read-directory-name
[   referred]: dialog-box , drive-dialog
[       file]: builtin.l
[    section]: ダイアログ
[description]: 
ファイルを指定するダイアログを表示します。
ユーザーが指定したファイルを返します。多値で返します。
（詳細不明）

  :char-encoding        文字コード指定プルダウンメニューを表示
  :eol-code             改行コード指定プルダウンメニューを表示
  :filter               ファイルの種類リスト
  :filter-index         （詳細不明）
  :title                ダイアログのタイトル
  :default              デフォルトのファイル名
  :initial-directory    初期表示するディレクトリ
  :extension            （詳細不明）
  :save                 non nilならファイル名を付けて保存？
  :multiple             non nilなら複数ファイル指定可
  :must-exist           non nilなら存在しないファイルを指定できない
  :explorer             （詳細不明）
  :hide-read-only       Read Onlyなファイルを表示しない？

使用例：
  ;;; タイトルをFooにして、複数選択可能なダイアログを表示する。
  (file-name-dialog :title "Foo"
                    :multiple t
                    :filter '(("すべてのファイル(*.*)" . "*.*")))
  => ("C:/applications/xyzzy/xyzzycli.exe")


■file-namestring
[       type]: Function
[  arguments]: file-namestring PATHNAME
[    package]: lisp
[    seealso]: pathname-name , directory-namestring
[   referred]: merge-pathnames , namestring , pathname-type
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
PATHNAMEのファイル名の部分を返します。
  
使用例：
  (file-namestring "C:/xyzzy/xyzzy.exe")
  => "xyzzy.exe"
  (file-namestring "C:/Windows/")
  => ""

須田さんの場合：
  ;;; 須田さんは、こんなのを定義しているらしい。
  (defun file-name-directory (filename)
    (directory-namestring filename))

  (defun file-name-nondirectory (filename)
    (file-namestring filename))

  (defun file-name-sans-versions (name)
    "Return FILENAME sans backup versions or strings.
  This is a separate procedure so your site-init or startup file can
  redefine it."
    (substring name 0
             (or (string-match "\\.~[0-9]+~\\'" name)
                 (string-match "~\\'" name)
                 (length name))))


■file-newer-than-file-p
[       type]: Function
[  arguments]: file-newer-than-file-p FILE1 FILE2
[    package]: editor
[    seealso]: file-write-time
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
ファイルの最終更新日を比較します。
戻り値は以下のとおりです。

  t   file1の方が新しい、もしくはfile2が無効。
  nil file2の方が新しい、file1が無効、時間差が無い、のいずれか。


■file-position
[       type]: Function
[  arguments]: file-position FILE-STREAM &optional POSITION
[    package]: lisp
[    seealso]: buffer-stream-point , buffer-stream-set-point
[       file]: builtin.l
[    section]: 入出力
[description]: 
FILE-STREAM上の現在位置を取得・変更します。
POSITIONを省略すると、FILE-STREAMの現在位置を返します。
POSITIONを指定すると、FILE-STREAMの現在位置を変更します。

  FILE-STREAM : 入出力するストリームを指定します。
  POSITION    : ストリームの先頭からの位置を指定します。
                0を基底とするインデックスです。

POSITIONには負の数値を指定することはできません。
また、ストリームの終端を越えた数値を指定すると、
その間はNUL文字が詰められます。

使用例：
  ;;; "01234567"と出力後、移動して"abc"と出力します。
  (setq foo (open "abc.txt" :direction :output))
  => #<file-output stream: C:/applications/xyzzy/abc.txt>
  (princ "0123456" foo)         => "0123456"
  (file-position foo 10)        => t
  (princ "abc" foo)             => "abc"
  (close foo)                   => t


■file-property
[       type]: Function
[  arguments]: file-property PATHNAME
[    package]: editor
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
PATHNAMEのファイルのプロパティを表示します。
使用例：
  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =>"C:/Applications/xyzzy/xyzzy.exe"

  (file-property a)
  =>t


■file-readable-p
[       type]: Function
[  arguments]: file-readable-p PATHNAME
[    package]: lisp
[    seealso]: file-writable-p , file-exist-p
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
PATHNAMEが読み取り可能ならt、そうでなければnilを返します。

使用例：
  (file-readable-p "C:/xyzzy/xyzzy.exe")
  => t
  (file-readable-p "~/")
  => nil


■file-visited-p
[       type]: Function
[  arguments]: file-visited-p &optional BUFFER
[    package]: editor
[       file]: builtin.l
[    section]: バッファ
[description]: 
BUFFER がファイル名を持つとき t となります。
デフォルトでは BUFFER は 現在のバッファです。


■file-writable-p
[       type]: Function
[  arguments]: file-writable-p PATHNAME
[    package]: lisp
[    seealso]: file-readable-p , file-exist-p
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
PATHNAMEが書き込み可能ファイルならt、そうでなければnilを返します。

使用例：  
  (file-writable-p "C:/xyzzy/xyzzy.exe")
  => t
  (file-writable-p "~/")
  => nil


■file-write-time
[       type]: Function
[  arguments]: file-write-time FILENAME
[    package]: lisp
[    seealso]: set-file-write-time , file-newer-than-file-p , decode-universal-time , format-date-string , file-exist-p , get-universal-time
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
ファイルの最終更新日をユニバーサルタイム形式で返します。

  FILENAME : ファイル名を指定します。
             フルパスでなければ(default-directory)からの相対パスになります。

使用例：
  ;;; .xyzzyの最終更新日を返します。
  (file-write-time ".xyzzy")
  => 3076147256


■filer
[       type]: Function
[  arguments]: filer &optional PATH ALLOW-MULTIPLE-SELECT-P CAPTION DUAL-WINDOW-P MODELESSP
[    package]: editor
[    seealso]: *filer-primary-directory* , *filer-secondary-directory*
[   referred]: *filer-directories* , *filer-echo-filename* , *filer-guide-text* , *filer-mark-file-size-unit* , *filer-modal* , *filer-path-masks* , *filer-primary-file-mask* , *filer-secondary-file-mask* , *filer-use-recycle-bin* , *modal-filer-save-size* , open-filer
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラを開きます。

  PATH      : ファイラが最初に表示するディレクトリを指定します。
  ALLOW-MULTIPLE-SELECT-P
            : ファイルを複数選択可能にするかどうかを指定します。
  CAPTION   : ファイラのウィンドウのタイトルを指定します。
  DUAL-WINDOW-P
            : 二画面ファイラで開くかどうかを指定します。
  MODELESSP : モードレスダイアログでファイラを開くかどうかを指定します。
              モードレスの場合には編集しつつファイラを表示できます。

選択結果を多値で返します。

  最初の戻り値はユーザが選択したファイルのリストを返します。
  次の戻り値はOKボタンを押したらt、CANCELボタンを押したらnilを返します。

使用例：
  ;;; multiple-value-bindでファイルを受け取る。
  (multiple-value-bind (files bool)
       (filer "c:/" t "title" nil)
       (when bool
         (msgbox "~{~S~%~}" files)))
  => :ok


■filer-calc-directory-byte-size
[       type]: Function
[  arguments]: filer-calc-directory-byte-size
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにて選択したディレクトリのファイルサイズの合計を計算します。


■filer-calc-directory-size
[       type]: Function
[  arguments]: filer-calc-directory-size
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにて選択したディレクトリのディスク使用量を計算します。


■filer-cancel
[       type]: Function
[  arguments]: filer-cancel
[    package]: editor
[    seealso]: filer-close
[       file]: filer.l
[    section]: ファイラ
[description]: 
ファイラを閉じます。
「閉じる」ボタンや「キャンセルボタン」を押したときと同じ効果が得られます。

(defun filer-cancel ()
 (filer-close nil))
と定義されています。


■filer-clear-all-marks
[       type]: Function
[  arguments]: filer-clear-all-marks &optional SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにてマークを全て解除します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-close
[       type]: Function
[  arguments]: filer-close RESULT
[    package]: editor
[    seealso]: filer-cancel
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラを閉じます。

  RESULT : モーダルファイラの場合、関数filerの戻り値に影響を与えます。
           （詳細不明）


■filer-context-menu
[       type]: Function
[  arguments]: filer-context-menu
[    package]: editor
[    section]: ファイラ
[description]: 
ファイラにてコンテキストメニューを表示します。


■filer-count-marks
[       type]: Function
[  arguments]: filer-count-marks &optional FILE-ONLY-P SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにてマークされたファイルの数を返します。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します。
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-current-file-directory-p
[       type]: Function
[  arguments]: filer-current-file-directory-p &optional SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにてカーソル位置のファイルがディレクトリかどうかを判定します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-current-file-dot-dot-p
[       type]: Function
[  arguments]: filer-current-file-dot-dot-p &optional SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにてカーソル位置のファイルが親ディレクトリを示す ".." 
であるかどうかを判定します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-demand-reload
[       type]: Function
[  arguments]: filer-demand-reload
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
（詳細不明）


■filer-dual-window-p
[       type]: Function
[  arguments]: filer-dual-window-p
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラが二画面ファイラかどうかを判別します。


■filer-forward-line
[       type]: Function
[  arguments]: filer-forward-line &optional ARG SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにてカーソルを次の行に移動します。

  ARG                : 指定行数移動します
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-forward-page
[       type]: Function
[  arguments]: filer-forward-page &optional ARG SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにてカーソルを次のページに移動します。

  ARG                : 指定ページ数移動します
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-get-current-file
[       type]: Function
[  arguments]: filer-get-current-file &optional SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにてカーソル位置のファイルのパスを返します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-get-directory
[       type]: Function
[  arguments]: filer-get-directory &optional SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにて現在表示しているディレクトリのフルパスを取得します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-get-drive
[       type]: Function
[  arguments]: filer-get-drive &optional SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにて現在表示しているドライブを取得します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-get-mark-files
[       type]: Function
[  arguments]: filer-get-mark-files &optional FILE-ONLY-P SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにてマークされたファイルのパスをリストの形で返します。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-get-sort-order
[       type]: Function
[  arguments]: filer-get-sort-order &optional SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにおけるファイルの表示順を返します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-get-text
[       type]: Function
[  arguments]: filer-get-text
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
一画面ファイラにて上部のファイル名の欄に書いてあるテキストを返します。


■filer-goto-bof
[       type]: Function
[  arguments]: filer-goto-bof &optional SECONDARY-WINDOW-P
[    package]: editor
[    seealso]: filer-goto-eof
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにてカーソルをウィンドウの先頭に移動します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-goto-eof
[       type]: Function
[  arguments]: filer-goto-eof &optional SECONDARY-WINDOW-P
[    package]: editor
[    seealso]: filer-goto-bof
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにてカーソルをウィンドウの最後に移動します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-goto-file
[       type]: Function
[  arguments]: filer-goto-file STRING &optional START REVERSE WILD-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにてファイル名が STRING の位置にカーソルを移動します。

  STRING  : 検索するファイル名
  START   : 検索を開始する位置
     nil      先頭から
     t        現在位置から
     それ以外 現在位置の次から
  REVERSE : 探す方向
     nil      前方向
     non-nil  後方向
  WILD-P  : ワイルドカードを有効にするか
     nil      無効
     t        有効
     それ以外 有効かつ先頭一致(末尾に"*"を補う)


■filer-isearch
[       type]: Function
[  arguments]: filer-isearch &optional CHAR NO-WRAP SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにてインクリメンタルサーチによるカーソル移動を行います。

  CHAR               : 検索する文字。nil の時は入力されたキーを検索します。
  NO-WRAP            : 最後までいったら、最初に戻るかどうか
             nil         戻らない
             non-nil     戻る
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-left-window
[       type]: Function
[  arguments]: filer-left-window
[    package]: editor
[    seealso]: filer-right-window
[       file]: builtin.l
[    section]: ファイラ
[description]: 
二画面ファイラにて左側のウィンドウをアクティブにします。


■filer-left-window-p
[       type]: Function
[  arguments]: filer-left-window-p
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
二画面ファイラにて現在アクティブなウィンドウが左側のウィンドウか判別します。


■filer-mark
[       type]: Function
[  arguments]: filer-mark &optional FILE-ONLY-P SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにてカーソル位置のファイルをマークします。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-mark-all
[       type]: Function
[  arguments]: filer-mark-all &optional FILE-ONLY-P SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにて現在表示しているディレクトリにあるファイル全てをマークします。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-mark-match-files
[       type]: Function
[  arguments]: filer-mark-match-files MASK &optional SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
MASK の示す条件を満たすファイルを全てマークします。

  MASK               : マークするファイル名の条件
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-modal-p
[       type]: Function
[  arguments]: filer-modal-p
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラがモーダルか判別します。


■filer-modify-column-width
[       type]: Function
[  arguments]: filer-modify-column-width N D &optional SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにおけるそれぞれのカラムの幅を変えます。

  N                  : 変更するカラム
             0           ファイル名
             1           サイズ
             2           更新日時
             3           属性
  D                  : 変更量
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-read-char
[       type]: Function
[  arguments]: filer-read-char
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにてキーボードからの入力を読み込み、文字を返します。


■filer-reload
[       type]: Function
[  arguments]: filer-reload &optional MASK SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラの画面を更新し、最新の状態にします。

  MASK               : 表示するファイルの条件を指定します
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-right-window
[       type]: Function
[  arguments]: filer-right-window
[    package]: editor
[    seealso]: filer-left-window
[       file]: builtin.l
[    section]: ファイラ
[description]: 
二画面ファイラにて右側のウィンドウをアクティブにします。


■filer-scroll-left
[       type]: Function
[  arguments]: filer-scroll-left &optional SECONDARY-WINDOW-P
[    package]: editor
[    seealso]: filer-scroll-right
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにて左方向にスクロールします。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-scroll-right
[       type]: Function
[  arguments]: filer-scroll-right &optional SECONDARY-WINDOW-P
[    package]: editor
[    seealso]: filer-scroll-left
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにて右方向にスクロールします。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-set-directory
[       type]: Function
[  arguments]: filer-set-directory DIRECTORY &optional SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにて表示するディレクトリを DIRECTORY に変更します。

  DIRECTORY          : ディレクトリを指定します
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-set-file-mask
[       type]: Function
[  arguments]: filer-set-file-mask MASK &optional SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにて表示する条件を指定します。

  MASK               : 表示する条件
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-set-text
[       type]: Function
[  arguments]: filer-set-text STRING
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
一画面ファイラのファイル名の欄に STRING をセットします。


■filer-sort
[       type]: Function
[  arguments]: filer-sort ARG &optional SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにおけるファイルの表示順を変更します。

  ARG                : 表示順を指定します
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-subscribe-to-reload
[       type]: Function
[  arguments]: filer-subscribe-to-reload PATH &optional SUB-DIRECTORY-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにて PATH を表示しているウィンドウを更新し、
最新の状態にします。

  PATH            : パスを指定します
  SUB-DIRECTORY-P : PATH のサブディレクトリを更新対象にするか否か
          nil         更新しない
          non-nil     更新する


■filer-swap-windows
[       type]: Function
[  arguments]: filer-swap-windows
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
二画面ファイラにてもう一方のウィンドウへフォーカスを移します。


■filer-toggle-all-marks
[       type]: Function
[  arguments]: filer-toggle-all-marks &optional FILE-ONLY-P SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにて現在のディレクトリの全てのファイルについてマークされた状態と
されていない状態を反転させます。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-toggle-mark
[       type]: Function
[  arguments]: filer-toggle-mark &optional FILE-ONLY-P SECONDARY-WINDOW-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにてカーソル位置のファイルについてマークされた状態とされていない
状態を反転させます。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ


■filer-viewer
[       type]: Function
[  arguments]: filer-viewer
[    package]: editor
[       file]: builtin.l
[    section]: ファイラ
[description]: 
ファイラにてカーソル位置のファイルの最初の方を見ることができます。


■fill
[       type]: Function
[  arguments]: fill SEQUENCE ITEM &key :start :end
[    package]: lisp
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCEのそれぞれをITEMに置換えます。元のSEQUENCEは置き換えられます。

使用例：
  ;;; シーケンスを作って、変更してみる。
  (setq foo (make-sequence 'string 8 :initial-element #\a))
  => "aaaaaaaa"
  (fill foo #\b :start 3 :end 4)
  => "aaabaaaa"
  foo
  => "aaabaaaa"


■fill-column
[       type]: Variable
[    package]: editor
[    seealso]: auto-fill-mode , set-fill-column , fill-prefix
[   referred]: fill-region , fill-region-as-paragraph
[       file]: fill.l
[    section]: ポジション
[description]: 
詰め込み時の折り返しの桁数を保持します。
既定値は 72 です。

使用例:
  ;;; 既定値を 62 に変更する。
  (setq-default fill-column 62)

カレントバッファの値を変更する場合は、関数 set-fill-column
を使用します。


■fill-paragraph
[       type]: Function
[  arguments]: fill-paragraph
[    package]: editor
[    seealso]: fill-region-as-paragraph , fill-prefix
[   referred]: fill-region
[       file]: fill.l
[    section]: 文字列
[description]: 
現在の段落を詰め込みます。[ESC q]


■fill-pointer
[       type]: Function
[  arguments]: fill-pointer VECTOR
[    package]: lisp
[    seealso]: array-has-fill-pointer-p , make-array , vector-pop , vector-push , length
[   referred]: vector , vector-push-extend
[       file]: builtin.l
[    section]: 配列
[description]: 
ベクタ（一次元配列） VECTOR のフィルポインタの位置を返します。
VECTOR がフィルポインタを持たない場合、エラーとなります。
  
備考:
  フィルポインタは、ベクタの見た目上の最後の位置を決めます。
  make-array では与えられた DIMENSION の配列を作りますが、
  フィルポインタを与えた場合、画面に表示されたり vector-pop などの関数が
  作用したりするのはフィルポインタの位置までとなります。

  なお、aref を使えばフィルポインタ以降の要素にもアクセスできます。
  また、フィルポインタに関係ないベクタ本来の長さを知りたい場合は
  array-dimension （または array-dimensions）を使います。


■fill-region
[       type]: Function
[  arguments]: fill-region FROM TO
[    package]: editor
[    seealso]: fill-paragraph , fill-region-as-paragraph , fill-column
[       file]: fill.l
[    section]: リージョン
[description]: 
リージョン内の各段落に対し、詰め込みを行います。

使用例:
  ;;; バッファ全体を詰め込み
  (fill-region (point-min) (point-max))


■fill-region-as-paragraph
[       type]: Function
[  arguments]: fill-region-as-paragraph FROM TO
[    package]: editor
[    seealso]: fill-paragraph , fill-region , fill-column
[       file]: fill.l
[    section]: リージョン
[description]: 
リージョンを 1 つの段落として詰め込みます。
詰め込み桁数は、変数 fill-column が参照されます。


■fill-region-hook
[       type]: Variable
[    package]: editor
[    seealso]: auto-fill-hook
[    section]: リージョン
[description]: 
fill-region/fill-paragraphの最後で実行されます。


■filter-buffer
[       type]: Function
[  arguments]: filter-buffer COMMAND
[    package]: editor
[    seealso]: filter-region
[       file]: process.l
[    section]: プロセス
[description]: 
バッファ全体の内容を標準入力につなげて COMMAND を実行します。[C-x #]
COMMAND の終了を待ち、終了するとバッファの内容は一旦全て消去され、
COMMAND の標準出力がバッファに出力されます。


■filter-region
[       type]: Function
[  arguments]: filter-region COMMAND &optional START END
[    package]: editor
[    seealso]: filter-buffer , call-process
[   referred]: execute-subprocess , make-process
[       file]: process.l
[    section]: プロセス
[description]: 
リージョンの内容を標準入力につなげて COMMAND を実行します。[C-x |]
COMMAND の終了を待ち、終了するとリージョンの内容は一旦全て消去され、
COMMAND の標準出力がリージョンにに出力されます。

リージョンが指定されていないときは、COMMANDの結果を単にカーソル位置
に出力します。


■find
[       type]: Function
[  arguments]: find ITEM SEQUENCE &key :from-end :test :test-not :start :end :key
[    package]: lisp
[    seealso]: find-if , find-if-not , position , member , getf
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCE の中で ITEM との :test を満たすものがあればそれを返します。なければ
nilを返します。

使用例：
  ;;; リストから'aを探してみる。
  (find 'a '(e c a b))
  => a


■find-all-symbols
[       type]: Function
[  arguments]: find-all-symbols NAME
[    package]: lisp
[    seealso]: find-symbol
[       file]: package.l
[    section]: シンボル
[description]: 
印字名が NAME であるようなシンボルを各パッケージから探します。
戻り値は見つかったシンボルのリストです。

使用例：
  (find-all-symbols "y")
  => (editor::y system::y lisp::y winapi::y)

  (find-all-symbols "system-root")
  => (system:system-root)

  (find-all-symbols "test")
  => (editor::test test :test lisp::test)


■find-buffer
[       type]: Function
[  arguments]: find-buffer BUFFER-NAME
[    package]: editor
[    seealso]: find-name-buffer , get-file-buffer , get-buffer-create
[   referred]: create-new-buffer
[       file]: builtin.l
[    section]: バッファ
[description]: 
名前がBUFFER-NAMEなバッファが存在すればそのバッファを返します。
存在しなければnilを返します。

使用例：
  (find-buffer "*scratch*")
  => #<buffer: *scratch*>
  (find-buffer "*hoge hoge*")
  => nil


■find-file
[       type]: Function
[  arguments]: find-file FILENAME &optional ENCODING NOMSG
[    package]: editor
[    seealso]: find-other-file , find-file-other-window , ed::find-file-internal , *prefix-args*
[   referred]: *auto-encoding-alist* , *auto-mode-parameter-alist* , *before-find-file-hook* , *find-file-auto-mode-function* , *find-file-file-not-found-hook* , *find-file-hooks* , *find-file-no-auto-encoding* , find-file-in-archive , find-file-read-only , insert-file , read-file
[       file]: files.l
[    section]: ファイルシステム
[description]: 
指定されたファイルを開き、カレントバッファをこのファイルにします。 [C-x C-f]
インタラクティブに呼び出すとファイル名をミニバッファで尋ねます。
プレフィックスアーギュメント付きで呼び出すと、ファイルの文字
コードを指定して開くことができます。

  FILENAME : ファイル名、またはファイル名のリストです。
  ENCODING : ファイルの文字コードを指定します。
  NOMSG    : non-nil でステータスバーに状況などを出力しなくなります。


■find-file-in-archive
[       type]: Function
[  arguments]: find-file-in-archive ARCNAME FILENAME
[    package]: editor
[    seealso]: extract-archive , find-file
[       file]: files.l
[    section]: ファイルシステム
[description]: 
アーカイブからファイルを展開して開きます。

  ARCNAME  : アーカイブを指定します。
  FILENAME : 展開するファイルを指定します。

使用例：
  (find-file-in-archive "C:/foo/bar.lzh" "hoge/fuga.txt")


■find-file-other-window
[       type]: Function
[  arguments]: find-file-other-window FILENAME &optional ENCODING NOMSG
[    package]: editor
[    seealso]: find-file
[       file]: files.l
[    section]: ファイルシステム
[description]: 
指定されたファイルを別のウィンドウで開きます。[C-x 4 f]


■find-file-read-only
[       type]: Function
[  arguments]: find-file-read-only FILENAME &optional ENCODING NOMSG
[    package]: editor
[    seealso]: find-file
[   referred]: *find-file-hooks* , *find-file-read-only-hook*
[       file]: files.l
[    section]: ファイルシステム
[description]: 
ファイル FILENAME を read-only で開きます。
FILENAME はファイルのリストであってもかまいません。

すでに FILENAME を読み込んでいるバッファがある場合、そのバッファを read-only に設定します。
FILENAME を読み込んでいるバッファがない場合は find-file と同様にファイルを読み込み、
バッファを read-only に設定して *find-file-hooks* を実行します。

いずれの場合も最後に *find-file-read-only-hook* を実行します。

  ENCODING : エンコーディングを指定します。
  NOMSG    : non-nil ならステータスバーに経過メッセージを表示しません。


■find-if
[       type]: Function
[  arguments]: find-if PREDICATE SEQUENCE &key :from-end :start :end :key
[    package]: lisp
[    seealso]: find , find-if-not
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCEの中でPREDICATEを満たすものがあればそれを返します。なければnilを返します。


■find-if-not
[       type]: Function
[  arguments]: find-if-not PREDICATE SEQUENCE &key :from-end :start :end :key
[    package]: lisp
[    seealso]: find , find-if
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCEの中でPREDICATEを満たさないものがあればそれを返します。なければ
nilを返します。


■find-load-path
[       type]: Function
[  arguments]: find-load-path FILENAME
[    package]: lisp
[    seealso]: *load-path*
[       file]: builtin.l
[    section]: システム
[description]: 
*load-path*からファイルを検索しそのフルパスを返します。

使用例：
  (find-load-path "wip/ftp.l")
  => "C:/APPLICATIONS/XYZZY/lisp/wip/ftp.l"
  (find-load-path "siteinit.l")
  => "C:/APPLICATIONS/XYZZY/site-lisp/siteinit.l"


■find-name-buffer
[       type]: Function
[  arguments]: find-buffer BUFFER-NAME
[    package]: editor
[    seealso]: find-buffer , get-file-buffer , create-new-buffer
[   referred]: buffer-name
[       file]: builtin.l
[    section]: バッファ
[description]: 
名前がBUFFER-NAMEもしくはBUFFER-NAME<数字>なバッファのリストを返します。
存在しなければnilを返します。

使用例：
  (find-name-buffer " *TAGS*")
  => (#<buffer:  *TAGS*<2>> #<buffer:  *TAGS*>)
  (find-name-buffer "*hoge hoge*")
  => nil


■find-other-file
[       type]: Function
[  arguments]: find-other-file FILENAME &optional ENCODING NOMSG
[    package]: editor
[    seealso]: *find-other-file-requires-file-name* , find-file
[       file]: files.l
[    section]: ファイルシステム
[description]: 
現在のバッファを閉じて指定されたファイルを開きます。[C-x C-v]

互換性：
  muleにはなさそう。


■find-package
[       type]: Function
[  arguments]: find-package NAME
[    package]: lisp
[    seealso]: パッケージ , list-all-packages , defpackage , delete-package
[   referred]: package-name
[       file]: builtin.l
[    section]: パッケージ
[description]: 
パッケージを名前で検索して、そのパッケージを返します。

  NAME : パッケージの名前

使用例：
  ;;; lispとsystemパッケージを取得してみる。
  (find-package "lisp")
  => #<package: lisp>
  (find-package "si")
  => #<package: system>

  ;;; "baz"という名のパッケージは存在しない
  (find-package "baz")
  => nil


■find-pseudo-frame
[       type]: Function
[  arguments]: find-pseudo-frame NAME
[    package]: editor
[    seealso]: select-pseudo-frame , selected-pseudo-frame
[       file]: pframe.l
[    section]: ウィンドウ
[description]: 
現在のフレームの中から名前が NAME であるものを探して返します。


■find-symbol
[       type]: Function
[  arguments]: find-symbol STRING &optional PACKAGE
[    package]: lisp
[    seealso]: intern , パッケージ
[   referred]: find-all-symbols
[       file]: builtin.l
[    section]: パッケージ
[description]: 
パッケージ中にシンボルが登録されているかを調べます。

  STRING  : シンボルの名前
  PACKAGE : パッケージの名前

戻り値は多値で返されます。

  nil     シンボルが見つからなかった場合はnilを返します。
  nil以外 シンボルが見つかった場合はそのシンボルをそのまま返します。

使用例：
  ;;; find-fileとfind-file-internalというシンボルを調べてみる。
  (find-symbol "find-file" "lisp")
  => nil
     nil
  (find-symbol "find-file" "editor")
  => find-file
     :external
  (find-symbol "find-file-internal" "editor")
  => editor::find-file-internal
     :internal


■find-text-attribute
[       type]: Function
[  arguments]: find-text-attribute TAG &key :start :end :from-end :test :test-not :key
[    package]: editor
[    seealso]: find-text-attribute-if , find-text-attribute-if-not , find-text-attribute-point
[   referred]: list-text-attributes , set-text-attribute
[       file]: builtin.l
[    section]: テキスト
[description]: 
set-text-attributeで指定したタグを検索します。

(progn
  (set-text-attribute 1 6 'my-tag 1)
  (multiple-value-bind (from to tag)
      (find-text-attribute 'my-tag)
    (format t "~d, ~d, ~A" from to tag)))
==> 1, 6, my-tag

| 2. set-text-attribute で、複数範囲に同一 tag を指定した場
|    合、find〜 は一番先頭に近いものしか返さない(ところしか
|    見たことがない)のですが、二番目以降を取得することはで
|    きますでしょうか？

find-text-attribute TAG :start POS

で、POS に現在位置+1を与えれば次のが返ってくる予定です。
使ったことないので動くかどうか分かりませんが。

| 3. find-text-attribute の &key 引数は、何か意味を持ってい
|    ますでしょうか？

シーケンスと同様に、:test と :test-not には比較関数を
与えます。また、:key にはアクセス関数(か?)を与えます。
たとえば、tag の形式が

  ("foo" bar)

である場合、

  (find-text-attribute "foo" :test #'equal :key #'car)

とか、

  (find-text-attribute 'bar :test #'eq :key #cadr)

で検索することができる予定です。使ったことないので動く
かどうか分かりませんが。

:test-not は、関数が nil を返した場合に真とする以外は :
test と同様です。:test と :test-not は同時に指定するこ
とはできず、省略した場合は :test #'eql が与えられたも
のとします。また :key を省略した場合は :key #'identity 
が与えられたものとします(たぶん)。


■find-text-attribute-if
[       type]: Function
[  arguments]: find-text-attribute-if TEST &key :start :end :from-end :key
[    package]: editor
[    seealso]: find-text-attribute-if-not , find-text-attribute , find-text-attribute-point , set-text-attribute
[       file]: builtin.l
[    section]: テキスト
[description]: 
テキスト属性のうち、タグが TEST を満たすものを探し、最初に見つかったものを返します。
多値で、テキスト属性の開始位置・終了位置・タグを返します。

  :start     検索開始位置（デフォルトでは point-min?）
  :end       検索終了位置（デフォルトでは point-max?）
  :from-end  後ろから検索するかどうか
  :key       TEST に渡す前にタグに適用する関数


■find-text-attribute-if-not
[       type]: Function
[  arguments]: find-text-attribute-if-not TEST &key :start :end :from-end :key
[    package]: editor
[    seealso]: find-text-attribute-if , find-text-attribute , find-text-attribute-point , set-text-attribute
[       file]: builtin.l
[    section]: テキスト
[description]: 
テキスト属性のうち、タグが TEST を満たさないものを探し、最初に見つかったものを返します。
多値で、テキスト属性の開始位置・終了位置・タグを返します。

  :start     検索開始位置（デフォルトでは point-min?）
  :end       検索終了位置（デフォルトでは point-max?）
  :from-end  後ろから検索するかどうか
  :key       TEST に渡す前にタグに適用する関数


■find-text-attribute-point
[       type]: Function
[  arguments]: find-text-attribute-point POINT
[    package]: editor
[    seealso]: modify-text-attributes , find-text-attribute , delete-text-attribute-point
[   referred]: find-text-attribute-if , find-text-attribute-if-not , set-text-attribute
[       file]: builtin.l
[    section]: テキスト
[description]: 
POINT の位置のテキストの属性を多値で返します。

  FROM          属性を付加された開始位置
  TO            属性を付加された終了位置
  TAG           個々の属性を区別するタグ
  FOREGROUND    文字色
  BACKGROUND    背景色
  BOLD          ボールド
  UNDERLINE     下線付き
  STRIKE-OUT    取り消し線
  PREFIX        不明
  EXTEND        不明

使用例：
  ;;; my-tagというタグ名で領域を緑色に設定
  (set-text-attribute (point-min) (point-max) 'my-tag :foreground 2)
  => t
  ;;; カーソル位置にタグがあれば赤色かつボールドに変更
  (multiple-value-bind (from to tag foreground background bold underline strike-out prefix extend)
      (find-text-attribute-point 1)
    (when tag
      (modify-text-attributes tag ; foregroundとbold以外はそのまま設定する。
       :foreground 1              ; 赤色に設定
       :background background
       :bold t                    ; ボールドに設定
       :underline underline
       :strike-out strike-out
       :prefix prefix
       :extend extend)))
  => t


■first
[       type]: Function
[  arguments]: first LIST
[    package]: lisp
[    seealso]: car , nth
[   referred]: second
[       file]: list.l
[    section]: リスト
[description]: 
carの別名です。
全く同じ動きをします。

使用例：
  ;;; carと同じ動きをする。
  (car '(1 2 3))
  => 1
  (first '(1 2 3))
  => 1
  (symbol-function 'car)
  => #<function: car>
  (symbol-function 'first)
  => #<function: car>
 
参考：
  ;;; list.lの定義
  (si:*fset 'first #'car)


■first-error
[       type]: Function
[  arguments]: first-error &optional ARG WRAP
[    package]: editor
[    seealso]: next-error , *error-regexp-list*
[       file]: errors.l
[    section]: エラー
[description]: 
grep後の*compilation*バッファ上で実行すると、該当行へジャンプ可能です。[F10]
以後は、next-error([F11], [C-x `])を押すことで次々と該当行へジャンプ可能です。
各種コンパイラの出力結果に応じてジャンプすることも可能です。
また、コンパイラのエラー出力が標準に対応していなくても、
*error-regexp-list*を変更することで対応が可能な場合があります。


■flet
[       type]: Special Form
[  arguments]: flet ({(NAME LAMBDA-LIST {declaration}* [doc-string] {FORM}*)}*) {FORM}*
[    package]: lisp
[    seealso]: labels , macrolet
[       file]: builtin.l
[    section]: 関数
[description]: 
ローカルな関数を定義してフォームを評価します。フォーム内で flet で
定義された関数は、外部で定義された同じ名前の関数よりも優先されます。
関数は同時に複数定義できます。

それぞれの定義方法は defun のように、最初に関数名、
次にパラメータのリスト(&optional, &rest, &key パラメータも使えます)、
そしてoptional declaration と docstring、そして最後にフォームと続きます。

  (flet ((safesqrt (x) (sqrt (abs x)))) 
    ;; The safesqrt function is used in two places. 
    (safesqrt (apply #'+ (map 'list #'safesqrt longlist))))


■float
[       type]: Function
[  arguments]: float NUMBER &optional OTHER
[    package]: lisp
[    seealso]: rationalize
[       file]: builtin.l
[    section]: 数値
[description]: 
任意の型の数値を浮動小数点型に変換します。

  (float 'NUMBER) == (coerce 'NUMBER 'single-float)

使用例：
  ;;; integerをfloatに変換する。
  (setq var 0)                  => 0
  (type-of var)                 => integer
  (setq var (float var))        => 0.0
  (type-of var)                 => single-float


■floatp
[       type]: Function
[  arguments]: floatp OBJECT
[    package]: lisp
[    seealso]: numberp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTがfloatならt、それ以外ならnilを返します。


■floor
[       type]: Function
[  arguments]: floor NUMBER &optional DIVISOR
[    package]: lisp
[    seealso]: ceiling , truncate , round , ffloor
[   referred]: mod
[       file]: builtin.l
[    section]: 数値
[description]: 
NUMBERを負の無限大方向に丸めます。
DIVISORを省略した場合にはNUMBERを越えない最大の整数になります。

使用例：  
  (floor 2.2)
  => 2
  (floor 2.8)
  => 2
  (floor -2.4)
  => -3  
  (multiple-value-list (floor 2.2))
  => (2 0.2)


■fmakunbound
[       type]: Function
[  arguments]: fmakunbound SYMBOL
[    package]: lisp
[    seealso]: fboundp
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
指定されたシンボルの関数定義からの束縛を解消します。
これ以降fboundpはnilを返すようになります。値と関数定義の束縛は独立してい
るので、fmakunboundをしてもboundpの結果は変わりません。

使用例：
  ;;; 関数定義への束縛を解消してみる。
  (defun foo (x) (* x 3))       => foo
  (fboundp 'foo)                => t
  (fmakunbound 'foo)            => foo
  (fboundp 'foo)                => nil


■focus-tool-bar
[       type]: Function
[  arguments]: focus-tool-bar
[    package]: editor
[       file]: builtin.l
[    section]: メニュー
[description]: 
タブバーにフォーカスを移します。タブバーからはTABを押すことで元のバッフ
ァに戻ることが出来ます。タブバーが存在しないときは、フォーカスは元のバッ
ファのままです。


■following-char
[       type]: Function
[  arguments]: following-char
[    package]: editor
[    seealso]: preceding-char , char-after
[       file]: builtin.l
[    section]: テキスト
[description]: 
カーソルがある位置のキャラクタを返します。
バッファの末尾にカーソルがある場合には、#\NULを返します。

使用例：
  ;;; "長崎市"の'崎'の上にカーソルがある場合
  (following-char)
  => #\崎

  ;;; [EOF]にカーソルがある場合
  (following-char)
  => #\NUL


■format
[       type]: Function
[  arguments]: format DESTINATION CONTROL-STRING &rest ARGUMENTS
[    package]: lisp
[   referred]: message , minibuffer-message , msgbox , string
[       file]: builtin.l
[    section]: 入出力
[description]: 
出力書式に従って出力します。

  DESTINATION : 出力先を指定します。
        t       標準出力に出力
        nil     文字列として結果を返す
        fp      指定のストリームに出力

  CONTROL-STRING : 以下の出力指定子で整形します。
        ~A      Ascii（アスキー指示）。princタイプで出力。
        ~S      S-Expression（S式指示）。prin1タイプで出力。
        ~%      改行。~n%はn個の改行
        ~&      出力ストリームが行頭でなければ改行。fresh-line参照。
        ~|      改ページ
        ~~      Tilde（チルダ指示）
        ~改行   改行とそれに続く空白文字を無視する
        ~T      Tabulate（タブ指示）
        ~*      次のargumentを無視
        ~?      Indirection（間接指示）
        ~D      10進数
        ~B      Binary（2進指示）
        ~O      Octal（8進指示）
        ~X      Hexadecimal（16進指示）
        ~R      Radix（基数指示）
        ~P      Plural（複数形指示）
        ~C      Character（文字指示）
        ~F      Fixed-format floating-point（固定小数点形式浮動小数指示）
        ~E      Exponential floating-point（指数形式浮動小数指示）
        ~G      General floating-point（一般浮動小数点指示）
        ~$      Dollars floating-point（ドル浮動小数点指示）
        ~(      Case conversion（ケース変換指示）
        ~)      ~(を閉じる
        ~[      Conditional expression（条件選択指示）
        ~]      ~[を閉じる
        ~{      Iteration（反復指示）
        ~}      ~{を閉じる
        ~^      Up and out（ゼロ終了指示）

使用例:
  ;;; 整数に0を付けて出力 ("~[最小桁数][,パディング文字][,桁区切り文字]D")
  (format nil "~5,'0D" 4)
  => "00004"

  ;;; 整数を3桁ごとにカンマで区切って出力
  (format nil "~:D" 1234567890)
  => "1,234,567,890"

  ;;; 文字列を最低桁カラムになるように空白を追加して出力
  (format nil "~10A" "foo")
  => "       foo"
  (format nil "~10@A" "foo")
  => "foo       "

  ;;; ケース変換の例
  (format nil "~(~A~)" "FOO BAR")  ;全て小文字
  => "foo bar"
  (format nil "~:(~A~)" "foo bar") ;単語の先頭の文字を大文字
  => "Foo Bar"
  (format nil "~@(~A~)" "foo bar") ;先頭の文字を大文字
  => "Foo bar"
  (format nil "~:@(~A~)" "foo bar");全て大文字
  => "FOO BAR"

  ;;; 間接指示の例
  (format nil "~? ~D" "[~A ~D]" '("foo" 2) 3)
  => "[foo 2] 3"
  (format nil "~@? ~D" "[~A ~D]" "foo" 2 3)
  => "[foo 2] 3"

  ;;; 条件選択指示の例
  (format nil "Windows ~[NT~;98~;95~]" 0)
  => "Windows NT"
  (format nil "Windows ~[NT~;98~;95~]" 1)
  => "Windows 98"
  ;デフォルト値 "~:;"
  (format nil "Windows ~[NT~;98~;95~:;3.1~]" 5)
  => "Windows 3.1"

  ;;; 反復指示の例
  ; "~{" 引数はリスト
  (format nil "~{ ~A~}" '("dog" "cat" "pig"))
  => " dog cat pig"
  ; "~:{"  引数はリストのリスト
  (format nil "~:{[~A ~D]~}" '(("a" 1) ("b" 2) ("c" 3)))
  => "[a 1][b 2][c 3]"
  ; "~@{" 残りの引数をリストとして用いる
  (format nil "~@{[~A ~D]~}" "a" 1 "b" 2 "c" 3)
  => "[a 1][b 2][c 3]"
  ; "~@:{" 引数のリストをリストとして用いる
  (format nil "~:@{[~A ~D]~}" '("a" 1) '("b" 2) '("c" 3))
  => "[a 1][b 2][c 3]"

  ;;; ゼロ終了指示の例
  ;引数がなければ終了
  (format nil "Done.~^ ~D warning~:P.~^ ~D error~:P.")
  => "Done."
  (format nil "Done.~^ ~D warning~:P.~^ ~D error~:P." 3)
  => "Done. 3 warnings."
  (format nil "Done.~^ ~D warning~:P.~^ ~D error~:P." 3 5)
  => "Done. 3 warnings. 5 errors."

  ;;; 反復指示とゼロ終了指示
  ;副リストの中の引数がもうなければ "~{" をそこで閉じる
  (format nil "~:{/~S~^ ...~}" '((hot dog) (hamburger) (ice cream) (french fries)))
  => "/hot .../hamburger/ice .../french ..."
  ;リストが終わりならそこで ":{" 全体を終了
  (format nil "~:{/~S~:^ ...~}" '((hot dog) (hamburger) (ice cream) (french fries)))
  => "/hot .../hamburger .../ice .../french"
  ;副リストの中の引数がもうなければ全体を終了
  (format nil "~:{/~S~#:^ ...~}" '((hot dog) (hamburger) (ice cream) (french fries)))
  => "/hot .../hamburger"

  ;;; 16進数のformat書式の書き方
  (format nil "~2,'0x" 10)
  => "0a"
  (format nil "~:@(~2,'0x~)" 10)
  => "0A"


■format-date
[       type]: Function
[  arguments]: format-date S FMT &optional UNIVERSAL-TIME
[    package]: editor
[    seealso]: decode-universal-time , format-date-string
[       file]: timestmp.l
[    section]: 日付・時間
[description]: 
書式に従って整形した日時をストリームに出力します。

  S              : 出力ストリームを指定します。
                   formatの様にtやnilを指定することはできません。
  FMT            : 日付用の書式文字列を指定します。
                   日付用の書式文字列はformat-date-stringを参照して下さい。
  UNIVERSAL-TIME : 出力する日時をユニバーサルタイム形式で指定します。
                   省略時は現在時刻が使われます。


■format-date-string
[       type]: Function
[  arguments]: format-date-string FMT &optional UNIVERSAL-TIME
[    package]: editor
[    seealso]: decode-universal-time , format-date
[   referred]: encode-universal-time , file-write-time , get-decoded-time , get-universal-time , set-file-write-time
[       file]: timestmp.l
[    section]: 日付・時間
[description]: 
書式に従って整形した日時を文字列として返します。

  FMT            : 日付用の書式文字列を指定します。
  UNIVERSAL-TIME : 出力する日時をユニバーサルタイム形式で指定します。
                   省略時は現在時刻が使われます。

使用例：
  (format-date-string "%y/%m/%d %H:%M:%S" 3112500590)
  => "98/08/19 16:29:50"
  (format-date-string "%y年%#m月%#d日(%v)")
  => "99年11月10日(水)"

日付用の書式：
  書式文字については timestmp.l を参照して下さい。以下は抜粋です。 
  a: 短い形式の曜日
  A: 長い形式の曜日
  b: 短い形式の月
  B: 長い形式の月
  d: 日(00〜31)                 # (0〜31)
  e: 和暦の年(01〜)             # (1〜)
  E: 和暦の年(元, 02〜)         # (元, 2〜)
  g: 元号(明治,大正,昭和,平成)  # (明,大,昭,平)
  G: 元号(M, T, S, H)
  H: 時(00〜23)                 # (0〜23)
  I: 12時間の時(01〜12)         # (1〜12)
  i: Internet Time(000〜999)
  m: 月(01〜12)                 # (1〜12)
  M: 分(00〜59)                 # (0〜59)
  p: 午前/午後
  P: AM/PM                      # am/pm
  S: 秒(00〜59)                 # (0〜59)
  v: 曜日(日本語)
  y: 年(2桁)
  Y: 年(4桁)
  z: タイムゾーン名(JST-9)
  Z: タイムゾーン(+0900)        # (+09:00)


■format-drive
[       type]: Function
[  arguments]: format-drive &optional DRIVE QUICK
[    package]: editor
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
ドライブをフォーマットします。

  DRIVE : ドライブを文字で指定します。

使用例：
  (format-drive #\a t)
  => nil


■forward-char
[       type]: Function
[  arguments]: forward-char &optional (ARG 1)
[    package]: editor
[    seealso]: backward-char , *prefix-args*
[   referred]: forward-word
[       file]: builtin.l
[    section]: ポジション
[description]: 
指定された文字数だけ右に移動します。改行があれば次行に移動します。
[C-f], [Right]

互換性： 
  Emacsでは移動できない場合エラーが発生します。xyzzyではエラーは発生し
  ません。その代わり、動けたときは t、動けなければ nil を返します。


■forward-line
[       type]: Function
[  arguments]: forward-line &optional (N 1)
[    package]: editor
[    seealso]: previous-line , forward-virtual-line , next-line , *prefix-args*
[   referred]: backward-line
[       file]: builtin.l
[    section]: ポジション
[description]: 
N行後に物理行に移動します。
移動の前後で goal-column を保存しません。

戻り値:
  移動した行数を返します。全く移動できなかったときは nil です。


■forward-list
[       type]: Function
[  arguments]: forward-list &optional ARG NO-ERRORS
[    package]: editor
[    seealso]: forward-sexp , up-list , backward-list
[       file]: builtin.l
[    section]: ポジション
[description]: 
前方のリストの終端へ移動します。[ESC C-n]
  
  使用例:
    ;;; forward-list で移動する
    ;;; 
    ;;; ^ でポイント位置を表す
    (let ((hoge '(1 2))) (foo hoge) ...)
      ^ 最初はこの位置
    (let ((hoge '(1 2))) (foo hoge) ...)
                        ^ 一回
    (let ((hoge '(1 2))) (foo hoge) ...)
                              二回 ^


■forward-page
[       type]: Function
[  arguments]: forward-page &optional (ARG 1)
[    package]: editor
[    seealso]: backward-page
[   referred]: mark-page
[       file]: page.l
[    section]: ポジション
[description]: 
前方の改ページまで移動します。[C-x []
改ページが無い場合はバッファの末尾に移動します。
一般には制御文字のform feedが単独である行で改ページを表します。

  ARG : ページ数を指定します。デフォルトは 1 です。
        負の値の場合、逆向きに移動します。


■forward-paragraph
[       type]: Function
[  arguments]: forward-paragraph &optional (ARG 1)
[    package]: editor
[    seealso]: backward-paragraph
[       file]: paragrph.l
[    section]: ポジション
[description]: 
カーソルを段落の末尾に移動します。[ESC }]


■forward-sexp
[       type]: Function
[  arguments]: forward-sexp &optional ARG NO-ERRORS
[    package]: editor
[    seealso]: backward-sexp , up-list
[   referred]: forward-list
[       file]: builtin.l
[    section]: バッファ
[description]: 
lisp-modeでS式を1つ進めます。[ESC C-f]

使用例：
  (forward-sexp)


■forward-virtual-line
[       type]: Function
[  arguments]: forward-virtual-line &optional (ARG 1)
[    package]: editor
[    seealso]: forward-line
[   referred]: backward-virtual-line
[       file]: builtin.l
[    section]: ポジション
[description]: 
表示行で次行へ移動します。


■forward-word
[       type]: Function
[  arguments]: forward-word &optional (ARG 1)
[    package]: editor
[    seealso]: backward-word , forward-char
[   referred]: capitalize-word , kill-word , mark-word , next-word
[       file]: builtin.l
[    section]: ポジション
[description]: 
カーソルを前方の単語に移動します。[ESC f]


■fourth
[       type]: Function
[  arguments]: fourth X
[    package]: lisp
[    seealso]: cadddr , nth
[       file]: list.l
[    section]: リスト
[description]: 
cadddr の別名です。全く同じ動きをします。


■fresh-line
[       type]: Function
[  arguments]: fresh-line &optional OUTPUT-STREAM
[    package]: lisp
[    seealso]: terpri
[       file]: builtin.l
[    section]: 入出力
[description]: 
OUTPUT-STREAM が行の先頭ではないときだけ改行 (#\LFD) を出力します。


■fround
[       type]: Function
[  arguments]: fround NUMBER &optional DIVISOR
[    package]: lisp
[    seealso]: round
[       file]: builtin.l
[    section]: 数値
[description]: 
round と同じですが浮動小数点数を返します。


■ftruncate
[       type]: Function
[  arguments]: ftruncate NUMBER &optional DIVISOR
[    package]: lisp
[    seealso]: truncate
[       file]: builtin.l
[    section]: 数値
[description]: 
truncateと同じですが浮動小数点数を返します。


■funcall
[       type]: Function
[  arguments]: funcall FN &rest ARGUMENTS
[    package]: lisp
[    seealso]: apply
[   referred]: *auto-fill-hook
[       file]: builtin.l
[    section]: 評価
[description]: 
引数を指定して関数を表すシンボルから関数を呼び出します。
FNには関数を表すシンボルでも関数でも構いません。引数の個数が静的に定まら
ない場合にはfuncallは向いていないので、その場合にはapplyを使います。

使用例：
  ;;; carをいろいろな呼び出し方でする。
  (car '(a b c))                => a
  (funcall 'car '(a b c))       => a
  (funcall #'car '(a b c))      => a

注意：
  funcallやapply等の様に関数を引数とする標準の関数は、carがlambdaの式や
  シンボルを内部的に関数に変換します。従って、関数を表すシンボルでも関数
  そのものでも構いません。


■function
[       type]: Special Form
[  arguments]: function FN
[    package]: lisp
[    seealso]: symbol-function , quote
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
関数の関数定義を返します。#'と同じです。

使用例：
  ;;; #'とfunctionとsymbol-functionを比べてみる。
  (defun foo (x) (* x 3))
  => foo
  #'foo
  => #<lexical-closure: foo>
  (function foo)
  => #<lexical-closure: foo>
  (symbol-function 'foo)
  => #<lexical-closure: foo>


■functionp
[       type]: Function
[  arguments]: functionp OBJECT
[    package]: lisp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTが関数ならt、それ以外ならnilを返します。


■gc
[       type]: Function
[  arguments]: gc &optional NO-MESSAGE
[    package]: lisp
[       file]: builtin.l
[    section]: その他
[description]: 
（多分）ゴミ集めをします。


■gcd
[       type]: Function
[  arguments]: gcd &rest INTEGERS
[    package]: lisp
[    seealso]: lcm
[       file]: builtin.l
[    section]: 数値
[description]: 
引数の最大公約数を返します。

使用例：
  (gcd 91 70)
  => 7
  (gcd 63 -42 35)
  => 7
  (gcd -3)
  => -3
  (gcd 35 8)
  => 1


■gensym
[       type]: Function
[  arguments]: gensym &optional X
[    package]: lisp
[    seealso]: *gensym-counter* , make-symbol , unintern , uninterned
[   referred]: gentemp , symbol-package
[       file]: evalmacs.l
[    section]: シンボル
[description]: 
uninterned なシンボルを生成します。印字名は G の後に *gensym-counter* の
値をつなげたものです。

引数 X を指定すると、
  X が整数のときは *gensym-counter* の代わりに X の値が使われます。
  X が文字列のときは "G" の代わりに X の値が使われます。


■gentemp
[       type]: Function
[  arguments]: gentemp &optional (PREFIX t) (PACKAGE *package*)
[    package]: lisp
[    seealso]: gensym , intern
[       file]: evalmacs.l
[    section]: シンボル
[description]: 
intern されたシンボルを生成します
PACKAGE に intern された PREFIX と内部カウンタをつなげたシンボルを返します

必ず衝突しないシンボルを生成します。


■get
[       type]: Function
[  arguments]: get SYMBOL INDICATOR &optional DEFAULT
[    package]: lisp
[    seealso]: symbol-plist , remprop
[       file]: builtin.l
[    section]: シンボル
[description]: 
シンボルのプロパティを返します。

  SYMBOL    : プロパティを返すシンボル
  INDICATOR : プロパティのインジケータ

使用例：
  ;;; シンボルにプロパティを設定してみる。
  (get 'clyde 'species)                         => nil 
  (setf (get 'clyde 'species) 'elephant)        => elephant 
  (get 'clyde 'species)                         => elephant

  ;;; 関数の説明を取得してみる。
  (defun foo (x) "increment" (1+ x))            => foo
  (get 'foo 'lisp::function-documentation)      => "increment"


■get-alternate-file-buffer
[       type]: Function
[  arguments]: get-alternate-file-buffer FILENAME &key (:test #'equalp)
[    package]: editor
[    seealso]: get-buffer-alternate-file-name , set-buffer-alternate-file-name
[       file]: buffer.l
[    section]: バッファ
[description]: 
ファイル名の別名が FILENAME であるようなバッファを返します。


■get-buffer-alternate-file-name
[       type]: Function
[  arguments]: get-buffer-alternate-file-name &optional BUFFER
[    package]: editor
[    seealso]: set-buffer-alternate-file-name
[   referred]: get-alternate-file-buffer
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファBUFFERに設定されたファイル名の別名を取得します。


■get-buffer-create
[       type]: Function
[  arguments]: get-buffer-create NAME
[    package]: editor
[    seealso]: create-new-buffer , find-buffer , new-file , switch-to-buffer , バッファの内部構造
[   referred]: buffer-name
[       file]: buffer.l
[    section]: バッファ
[description]: 
指定した名前のバッファを返します。名前を指定しますが、同じ名前のバッファ
が既にあればそれを返します。無ければcreate-new-bufferで新しく作ります。

switch-to-bufferも良く似た動きをしますが、switch-to-bufferは
get-buffer-createを用いて実装されています。

  NAME : バッファの名前

使用例：
  ;;; *calc*がなければ作成する。
  (get-buffer-create "*calc*")
  => #<buffer: *calc*>


■get-buffer-file-name
[       type]: Function
[  arguments]: get-buffer-file-name &optional BUFFER
[    package]: editor
[    seealso]: set-buffer-file-name , get-file-buffer
[   referred]: *save-buffer-no-filenames-hook*
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファが参照しているファイルのフルパスを返します。
ファイルを参照していなければnilを返します。

  BUFFER : ファイルのフルパスを返すバッファを指定します。

使用例：
  ;;; カレントバッファのファイルのフルパスを返します。
  (get-buffer-file-name)
  => "C:/xyzzy/site-lisp/xmldoc/reference.xml"


■get-buffer-window
[       type]: Function
[  arguments]: get-buffer-window BUFFER &optional START-WINDOW
[    package]: editor
[    seealso]: window-buffer
[   referred]: set-window
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
バッファを表示しているウィンドウを返します。同じバッファが複数のウィンド
ウに表示されていますので、START-WINDOWから順番に探し始めます。
現在表示されてないバッファはnilが返ります。

  BUFFER       : 検索するバッファ
  START-WINDOW : 検索をし始めるウィンドウ

使用例：
  ;;; window-bufferも使ってみる。
  (selected-buffer)
  => #<buffer: *scratch*>
  (window-buffer (get-buffer-window (selected-buffer)))
  => #<buffer: *scratch*>


■get-clipboard-data
[       type]: Function
[  arguments]: get-clipboard-data
[    package]: editor
[    seealso]: copy-to-clipboard , clipboard-empty-p
[       file]: builtin.l
[    section]: システム
[description]: 
クリップボードの内容を文字列として取り出します。


■get-decoded-time
[       type]: Function
[  arguments]: get-decoded-time
[    package]: lisp
[    seealso]: decode-universal-time , format-date-string
[       file]: builtin.l
[    section]: 日付・時間
[description]: 
現在の時間を多値で返します。
  
  (get-decoded-time) == (decode-universal-time (get-universal-time))
  
使用例：
  (multiple-value-list (get-decoded-time))
  => (55 35 14 17 11 1999 2 nil -9)


■get-disk-usage
[       type]: Function
[  arguments]: get-disk-usage DIRECTORY &optional RECURSIVEP
[    package]: editor
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
指定されたディレクトリの容量を取得します。

  DIRECTORY  : 情報を取得するディレクトリを指定します。
  RECURSIVEP : サブディレクトリも再帰的にチェックするかを指定します。

戻り値は多値で返します。

  1 ブロックサイズ（バイト）
  2 全ディスク容量（バイト）
  3 空きディスク容量（バイト）
  4 ブロック単位の合計（バイト）
  5 ファイルサイズを単純に加算した合計（バイト）
  6 調べたディレクトリの個数
  7 調べたファイルの個数

使用例：
  (defun my-folder-size (my-dir)
    (interactive "Dfolder name: ")
    (let (my-dir-list (my-total-size  0))
      (setq my-dir-list (directory my-dir
                                   :wile "*.*"
                                   :absolute t
                                   :file-only t
                                   :recursive t
                                   :show-dots nil))
      (dolist (f my-dir-list)
        (setq my-total-size (+ my-total-size (file-length f))))
      (msgbox (format nil "フォルダの使用容量は、~d バイトです。"
                      my-total-size))))


■get-dispatch-macro-character
[       type]: Function
[  arguments]: get-dispatch-macro-character DISP-CHAR SUB-CHAR &optional READTABLE
[    package]: lisp
[    seealso]: make-dispatch-macro-character , set-dispatch-macro-character
[       file]: builtin.l
[    section]: 入出力
[description]: 
ディスパッチマクロを取得します。
SUB-CHAR は大文字小文字を区別しません。

DISP-CHAR がディスパッチマクロ文字でなければエラーとなります。


■get-file-attributes
[       type]: Function
[  arguments]: get-file-attributes PATHNAME
[    package]: editor
[    seealso]: get-file-info
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
ファイルの属性を返します。ファイルサイズや最終更新日などの情報も一括して取
得したい場合には、get-file-infoを使用しましょう。

  PATHNAME : 属性を取得するファイル名を指定します。

戻り値は以下の値の合計で表されます。

  ed::*file-attribute-readonly*   : 読み取り専用
  ed::*file-attribute-hidden*     : 隠しファイル
  ed::*file-attribute-system*     : システムファイル
  ed::*file-attribute-directory*  : ディレクトリ
  ed::*file-attribute-archive*    : アーカイブ
  ed::*file-attribute-compressed* : 圧縮

使用例：
  ;;; c:\autoexec.batの属性を取得してみる。多分アーカイブになっているので
  ;;; ed::*file-attribute-archive*との論理積が0以外になる。
  (get-file-attributes "c:/autoexec.bat")
  => 32
  (= (get-file-attributes "c:/autoexec.bat") ed::*file-attribute-archive*)
  => t


■get-file-buffer
[       type]: Function
[  arguments]: get-file-buffer FILENAME
[    package]: editor
[    seealso]: get-buffer-file-name
[   referred]: create-file-buffer , find-buffer , find-name-buffer
[       file]: builtin.l
[    section]: バッファ
[description]: 
ファイルを表示しているバッファを返します。
なければnilを返します。

使用例：  
  (get-file-buffer "not-documented.xml")
  => #<buffer: not-documented.xml>


■get-file-info
[       type]: Function
[  arguments]: get-file-info PATHNAME
[    package]: editor
[   referred]: get-file-attributes
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
ファイルの属性をまとめて取得します。属性・最終更新日・サイズ・短い
名前のリストの形式です。属性は以下の感じで。
  ed::*file-attribute-readonly*
  ed::*file-attribute-hidden*
  ed::*file-attribute-system*
  ed::*file-attribute-directory*
  ed::*file-attribute-archive*
  ed::*file-attribute-compressed*

使用例：
  (setq i (get-file-info (si:system-root)))
  => (16 3208385786 0 "XYZZY")
  (logand (car i) ed::*file-attribute-directory*)
  => 16
  (logand (car i) ed::*file-attribute-hidden*)
  => 0
  (format-date-string "%y/%m/%d %H:%M:%S" (cadr i))
  => "01/09/02 11:16:26"


■get-image-size
[       type]: Function
[  arguments]: get-image-size FILENAME
[    package]: editor
[       file]: imagehdr.l
[    section]: その他
[description]: 
指定された画像ファイルの縦・横・フォーマットを取得することが可能です。

使用例：
  ;;; imageタグを挿入してみる
  (require "imagehdr")
  (defun html-write-image-tag (file)
    (interactive "fJPEG, GIF, PNG : ")
    (multiple-value-bind (width height fmt)
      (get-image-size file)
      (insert (format nil "<IMG SRC=\"~a\" WIDTH=~d HEIGHT=~d>" file width height))))


■get-ime-mode
[       type]: Function
[  arguments]: get-ime-mode
[    package]: editor
[    seealso]: toggle-ime
[       file]: builtin.l
[    section]: キーマップ
[description]: 
IMEのON/OFF状態を返します。

戻り値は以下の通りです
  t   変換モード
  nil 直接入力モード


■get-internal-real-time
[       type]: Function
[  arguments]: get-internal-real-time
[    package]: lisp
[    seealso]: internal-time-units-per-second , si:performance-counter
[       file]: builtin.l
[    section]: 日付・時間
[description]: 
内部的にGetTickCountを呼び出しています。GetTickCountはMSDNによると
システムを起動した後の経過時間を、ミリ秒（ms）単位で取得します。
この時間は、システムタイマの分解能による制限を受けます。
システムを 49.7 日間連続して動作させると、経過時間は 0 に戻ります。

だそうです。

使用例：  
  ;;普通に呼び出す。整数が帰ってくる
  (get-internal-real-time)
  =>984001406

  ;;書式付で起動時間を表示
  (let ((tick (get-internal-real-time))
        d h m s ms)
    (multiple-value-setq (tick ms)
        (truncate tick 1000))
    (multiple-value-setq (tick s)
        (truncate tick 60))
    (multiple-value-setq (tick m)
        (truncate tick 60))
    (multiple-value-setq (d h)
        (truncate tick 24))
    (format nil "PC起動経過時間 day ~D time ~2,'0D:~2,'0D:~2,'0D.~3,'0D" d h m s ms))
  =>"PC起動経過時間 day 11 time 09:20:04.578"


■get-local-window-flags
[       type]: Function
[  arguments]: get-local-window-flags WINDOW-OR-BUFFER
[    package]: editor
[    seealso]: set-local-window-flags
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
ローカルに設定されたウィンドウフラグの状態を多値で返します。

　 WINDOW-OR-BUFFER : バッファかウィンドウのいずれかを指定します。

戻り値
   一つ目はローカルに t に設定されたフラグ
   二つ目はローカルに nil に設定されたフラグ

使用例 :
  (progn
    (set-local-window-flags (selected-window) *window-flag-line-number* t)
    (set-local-window-flags (selected-window) *window-flag-ruler* t)
    (set-local-window-flags (selected-window) *window-flag-vscroll-bar* nil)
    (get-local-window-flags (selected-window)))
  =>
  3
  32


■get-macro-character
[       type]: Function
[  arguments]: get-macro-character CHAR &optional READTABLE
[    package]: lisp
[    seealso]: set-macro-character
[       file]: builtin.l
[    section]: 入出力
[description]: 
マクロ文字 CHAR に割り当てられている関数を返します。マクロ文字でない
場合は nil を返します。
また、マクロ文字である場合には二番目の戻り値として CHAR が 
non-terminating かどうかを返します。

使用例：
  ;;; # は non-terminating macro character
  (get-macro-character #\#)
  => system:|#-reader|
  => t
  ;;; ' は terminating macro character
  (get-macro-character #\')
  => system:|'-reader|
  => nil
  ;;; A はマクロ文字ではない
  (get-macro-character #\A)
  => nil


■get-menu
[       type]: Function
[  arguments]: get-menu MENU TAG-OR-POSITION &optional TAG-OR-POSITION-P
[    package]: editor
[    seealso]: current-menu , get-menu-position , define-menu
[   referred]: add-menu-item , add-menu-separator , insert-menu-item , insert-menu-separator
[       file]: builtin.l
[    section]: メニュー
[description]: 
指定されたメニューから、タグ名または位置で検索したメニューを取得します。

  TAG-OR-POSITION   : タグもしくは位置を指定します。
  TAG-OR-POSITION-P : TAG-OR-POSITIONの引数をタグとして解釈するか位置と
                      して解釈するかを決めます。
           nil     TAG-OR-POSITIONはタグを表すシンボル
           non-nil TAG-OR-POSITIONは位置を表す整数値
使用例：
  (get-menu *app-menu* 3 t)


■get-menu-position
[       type]: Function
[  arguments]: get-menu-position MENU TAG
[    package]: editor
[    seealso]: get-menu , define-menu
[   referred]: add-menu-separator , insert-menu-separator
[       file]: builtin.l
[    section]: メニュー
[description]: 
メニューの中からタグの位置を検索して返します。

  MENU : 検索するメニューを指定します。
  TAG  : 検索するタグを指定します。

見つからなかった場合にはnilが返されます。
見つかった場合にはその位置とそれを含むメニューを返します。


■get-next-buffer
[       type]: Function
[  arguments]: get-next-buffer &optional BUFFER REVERSE TAB-ORDER INTERNAL
[    package]: editor
[    seealso]: next-buffer , buffer-list
[       file]: builtin.l
[    section]: バッファ
[description]: 
次のバッファを返します。

  BUFFER    : 
       :top     先頭のバッファを返します。
       :bottom  最後尾のバッファを返します。
       バッファ 指定したバッファの次のバッファを返します。
  REVERSE   : non-nil なら一つ前のバッファを返します。
  TAB-ORDER : nil ならバッファの生成順で、non-nil ならバッファタブ順で
              次のバッファを返します。
  INTERNAL  : non-nil なら非表示バッファも含めて次のバッファを返します。


■get-properties
[       type]: Function
[  arguments]: get-properties PLACE INDICATOR-LIST
[    package]: lisp
[    seealso]: getf
[       file]: builtin.l
[    section]: シンボル
[description]: 
2番目の引数がリストになっているgetfです。
一致すると多値で値を返します。

使用例：
  ;;; get-propertiesで値を取得してみる。
  (get-properties '(ind1 10 ind2 20 ind3 30) '(ind2))
  => ind2
     20
     (ind2 20 ind3 30)


■get-selection-type
[       type]: Function
[  arguments]: get-selection-type
[    package]: editor
[    seealso]: set-selection-type , start-selection
[   referred]: pre-selection-p
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファの選択状態を返します。

  nil   選択なし、
  1     行モード選択状態
  2     文字モード選択状態
  3     矩形選択状態


■get-short-path-name
[       type]: Function
[  arguments]: get-short-path-name PATHNAME
[    package]: lisp
[    seealso]: truename
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
PATHNAMEの8.3形式でのパスを返します。
使用例：
  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =>"C:/Applications/xyzzy/xyzzy.exe"

  (get-short-path-name a)
  =>"C:/APPLIC~2/xyzzy/xyzzy.exe"


■get-special-folder-location
[       type]: Function
[  arguments]: get-special-folder-location PLACE
[    package]: editor
[    seealso]: get-windows-directory , get-system-directory
[       file]: builtin.l
[    section]: システム
[description]: 
いろいろなフォルダへのパスを返します。

  PLACE : フォルダの種類を指定します。
    :start-menu
    :send-to
    :desktop
    :personal
    :programs
    :recent
    :startup
    :templates

参考：
  WindowsAPIのGetSpecialFolderLocation


■get-system-directory
[       type]: Function
[  arguments]: get-system-directory
[    package]: editor
[    seealso]: get-windows-directory , get-special-folder-location
[       file]: builtin.l
[    section]: システム
[description]: 
Windowsシステムフォルダまでのパスを返す。

使用例：
  (get-system-directory)
  => "C:/WINDOWS/System32/"


■get-universal-time
[       type]: Function
[  arguments]: get-universal-time
[    package]: lisp
[    seealso]: decode-universal-time , format-date-string , file-write-time
[       file]: builtin.l
[    section]: 日付・時間
[description]: 
現在の時間を返します。

使用例：
  (get-universal-time)
  => 3151806404


■get-window-handle
[       type]: Function
[  arguments]: get-window-handle &optional WINDOW
[    package]: editor
[       file]: builtin.l
[    section]: システム
[description]: 
指定されたウィンドウのハンドルを返します。

  WINDOW : ハンドルを返すウィンドウを指定します。

使用例：
  ;;; カーソルがあるウィンドウのハンドルを返します。
  (get-window-handle (selected-window))


■get-window-line
[       type]: Function
[  arguments]: get-window-line &optional WINDOW
[    package]: editor
[    seealso]: window-lines , refresh-screen
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
ウィンドウでのカーソルの表示行を返します。
ウィンドウ内の一番上の表示行にカーソルがある場合 0 を返します。
現在のカーソル位置を正確に得るため、行数を取得する前に画面表示
を更新します。

  WINDOW : ウィンドウを指定します。
           指定しなければ (selected-window) が使われます。


■get-window-start-line
[       type]: Function
[  arguments]: get-window-start-line &optional WINDOW
[    package]: editor
[    seealso]: current-virtual-line-number , current-line-number
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
ウィンドウの先頭行が表示行で何行目かを返します。

補足：
  どういった場合に起こりえるのか不明ですが、ウィンドウにバッファが関連付
  いていない場合は nil を返します。


■get-windows-directory
[       type]: Function
[  arguments]: get-windows-directory
[    package]: editor
[    seealso]: get-system-directory , get-special-folder-location
[       file]: builtin.l
[    section]: システム
[description]: 
Windowsフォルダへのパスを返します。

使用例：
  (get-windows-directory)
  => "C:/WINDOWS/"


■getf
[       type]: Function
[  arguments]: getf PLACE INDICATOR &optional DEFAULT
[    package]: lisp
[    seealso]: get-properties , symbol-plist
[   referred]: find , member
[       file]: builtin.l
[    section]: シンボル
[description]: 
インジケータと値のリストから、インジケータに一致する値を取得します。

  (get x y) == (getf (symbol-plist x) y)

使用例：
  ;;; 実用性は無いけれどgetfを使って取得してみる。
  (getf '(ind1 10 ind2 20 ind3 30) 'ind2)
  => 20


■gethash
[       type]: Function
[  arguments]: gethash KEY HASH-TABLE &optional DEFAULT
[    package]: lisp
[    seealso]: gethash-region , maphash , make-hash-table
[       file]: builtin.l
[    section]: ハッシュ
[description]: 
ハッシュテーブルの中からキーが一致するものを返します。

  KEY        : 検索するキーを指定します。
  HASH-TABLE : ハッシュテーブルを指定します。

使用例：
  (setq hash-table (make-hash-table))
  => #<hash table>
  (gethash 'a hash-table)
  => nil
  (setf (gethash 'a hash-table) 1)
  => 1
  (gethash 'a hash-table)
  => 1

  (setq h (make-hash-table :test #'equalp))
  (setf (gethash "body" h) '(a b c))
  (gethash "BODY" h)


■gethash-region
[       type]: Function
[  arguments]: gethash-region FROM TO HASHTABLE &optional DEFAULT
[    package]: editor
[    seealso]: gethash
[       file]: builtin.l
[    section]: ハッシュ
[description]: 
リージョンの文字列をハッシュテーブルから取得します。
(buffer-substring FROM TO)してから(gethash ... HASHTABLE)するようなものです。


■global-set-key
[       type]: Function
[  arguments]: global-set-key KEY COMMAND
[    package]: editor
[    seealso]: global-unset-key , define-key , local-set-key , undefined , *global-keymap* , キー表現使用可能文字
[   referred]: BS と C-h に別々の機能を割り当てるには？
[       file]: keymap.l
[    section]: キーマップ
[description]: 
グローバルなキーマップにキーを登録します。

使用例：
 (global-set-key #\C-r          'previous-page)
 (global-set-key #\S-Left       'selection-backward-char)
 (global-set-key #\S-C-Left     'selection-backward-word)


■global-unset-key
[       type]: Function
[  arguments]: global-unset-key KEY
[    package]: editor
[    seealso]: global-set-key
[       file]: keymap.l
[    section]: キーマップ
[description]: 
グローバルなキーマップのキーの割り当てを解除します。

使用例：
  ;;; global-set-keyで割り当てたキーを解除してみる。
  (global-set-key #\C-r 'previous-page)
  => t
  (global-unset-key #\C-r)
  => t


■go
[       type]: Special Form
[  arguments]: go TAG
[    package]: lisp
[    seealso]: tagbody , prog
[       file]: builtin.l
[    section]: 制御構造
[description]: 
tagbody や prog の中で指定されたタグへジャンプします。

使用例:
  ;;; dotimes 相当のループを tagbody と go で書いてみる
  (let ((x 0) (sum 0))
    (tagbody
      start
      (setq sum (+ sum x)
            x (1+ x))
      (if (<= x 10) (go start)))
    sum)
  => 55


■goal-column
[       type]: Function
[  arguments]: goal-column
[    package]: editor
[    seealso]: set-goal-column
[   referred]: next-line
[       file]: builtin.l
[    section]: ポジション
[description]: 
現在のゴールカラムを取得します。
[xyzzy:06371] あたりのスレッドを見ると、save-excursionでゴールカラムが保
存されないのは仕様のようです。


■goto-bol
[       type]: Function
[  arguments]: goto-bol
[    package]: editor
[    seealso]: goto-eol , goto-virtual-bol
[   referred]: goto-line
[       file]: builtin.l
[    section]: ポジション
[description]: 
行頭に移動します。

互換性：
  xyzzyオリジナルのようです。
  効率がいいのでこれを使うのが推奨されているみたい。


■goto-char
[       type]: Function
[  arguments]: goto-char POINT
[    package]: editor
[    seealso]: point-min , point-max , what-cursor-position
[   referred]: goto-line , goto-marker , make-marker
[       file]: builtin.l
[    section]: ポジション
[description]: 
指定された位置にカレントバッファのカーソルを移動します。
この位置はpoint, point-min, point-max等のポイントを返す関数を
使用することで得ることが可能です。

  POINT: バッファ上の位置です。整数またはマーカーを利用できます。
         移動できる最小の位置は point-min で取得でき、これよりも小さい
         値を指定した時は point-min の位置に移動します。
         移動できる最大の位置は point-max で取得でき、これよりも大きい
         値を指定した時は point-max の位置に移動します。

戻り値：
  mule では、POINT が返されますが、 xyzzy では常に t です。 


■goto-column
[       type]: Function
[  arguments]: goto-column COLUMN &optional EXCEED-P
[    package]: editor
[    seealso]: goto-virtual-column , current-virtual-column , current-line-columns , goto-line
[   referred]: current-column
[       file]: builtin.l
[    section]: ポジション
[description]: 
指定された桁位置に移動します。移動した後の桁位置を返します。
current-line-columns が返す値よりも大きな値を指定した場合には、行の終端に
位置します。負の数を指定した場合には、行の先頭に位置します。

  COLUMN : 桁数


■goto-eol
[       type]: Function
[  arguments]: goto-eol
[    package]: editor
[    seealso]: goto-bol , goto-virtual-line
[   referred]: goto-line , goto-virtual-eol
[       file]: builtin.l
[    section]: ポジション
[description]: 
行末に移動します。

互換性：
  xyzzyオリジナルのようです。
  効率がいいのでこれを使うのが推奨されているみたい。


■goto-last-modified-line
[       type]: Function
[  arguments]: goto-last-modified-line
[    package]: editor
[    seealso]: last-modified-point , exchange-point-and-mark
[       file]: cmds.l
[    section]: バッファ
[description]: 
現在のバッファで最近変更された行の先頭に移動します。


■goto-line
[       type]: Function
[  arguments]: goto-line LINE
[    package]: editor
[    seealso]: goto-virtual-line , goto-char , goto-column , goto-bol , goto-eol
[       file]: builtin.l
[    section]: ポジション
[description]: 
指定された行番号にジャンプします。折り返しを有効にしていて表示行にジャン
プしたい場合には、goto-virtual-lineを使用します。[ESC g]


■goto-marker
[       type]: Function
[  arguments]: goto-marker MARKER
[    package]: editor
[    seealso]: set-marker , goto-char
[       file]: builtin.l
[    section]: ポジション
[description]: 
マーカーのポジションへポイントを移動します。
goto-char と違い、ポイント（数字）を引数として受け取ることはできません。


■goto-matched-parenthesis
[       type]: Function
[  arguments]: goto-matched-parenthesis &optional ARG
[    package]: editor
[   referred]: set-syntax-match
[       file]: builtin.l
[    section]: ポジション
[description]: 
ポイントに存在するキャラクタが、syntax-open-pもしくはsyntax-close-pを満
たす場合に、対応するキャラクタに移動します。対応する各種括弧に移動するの
に使われます。[ESC ]]


■goto-virtual-bol
[       type]: Function
[  arguments]: goto-virtual-bol
[    package]: editor
[    seealso]: goto-bol , goto-virtual-eol
[   referred]: beginning-of-virtual-line
[       file]: builtin.l
[    section]: ポジション
[description]: 
表示行の行頭に移動します。
※実際の表示が表示行／物理行には依存しません。


■goto-virtual-column
[       type]: Function
[  arguments]: goto-virtual-column COLUMN &optional EXCEED-P
[    package]: editor
[    seealso]: goto-column
[   referred]: current-virtual-column
[       file]: builtin.l
[    section]: ポジション
[description]: 
指定された表示桁へ移動します。

  COLUMN   : 移動する表示桁位置を指定します。
  EXCEED-P : （詳細不明）

表示桁が折り返しの桁位置よりも大きいときは、折り返しの桁位置で止まります。
※実際の表示が表示行／物理行には依存しません。


■goto-virtual-eol
[       type]: Function
[  arguments]: goto-virtual-eol
[    package]: editor
[    seealso]: goto-eol , goto-virtual-bol
[   referred]: end-of-virtual-line
[       file]: builtin.l
[    section]: ポジション
[description]: 
表示行の行末に移動します。
※実際の表示が表示行／物理行には依存しません。


■goto-virtual-line
[       type]: Function
[  arguments]: goto-virtual-line LINE
[    package]: editor
[    seealso]: goto-line
[   referred]: current-virtual-line-number , goto-eol
[       file]: builtin.l
[    section]: ポジション
[description]: 
表示行での指定行に移動します。
ウィンドウの表示行／物理行の切替は、「共通設定」−「表示」−「行番号は表示行(D)」
で行います。

参考：
  ファイルイメージ： 
    001| ABCDEFGHIJKLMNOPQR
    002| ABCDEFGHIJKLMNOPQRS
    003| ABCDEFGHIJKLMNOPQRST
    004| ABCDEFGHIJKLMNOPQRSTU
    005| ABCDEFGHIJKLMNOPQRSTUV

                    │
      ┌──────┴──────┐
      ↓                          ↓

  物理行：                        表示行：                      
    001| ABCDEFGHIJKLMNOPQR         001| ABCDEFGHIJKLMNOPQR
    002| ABCDEFGHIJKLMNOPQRS        002| ABCDEFGHIJKLMNOPQRS
    003| ABCDEFGHIJKLMNOPQRST       003| ABCDEFGHIJKLMNOPQRST
    004| ABCDEFGHIJKLMNOPQRST       004| ABCDEFGHIJKLMNOPQRST
       | U                          005| U
    005| ABCDEFGHIJKLMNOPQRST       006| ABCDEFGHIJKLMNOPQRST
       | UV                         007| UV


■graphic-char-p
[       type]: Function
[  arguments]: graphic-char-p CHAR
[    package]: lisp
[       file]: builtin.l
[    section]: データ型
[description]: 
CHAR が印字文字かどうかを判定します。

  (graphic-char-p #\A)
  =>t
  (graphic-char-p #\SPC)
  =>t
  (graphic-char-p #\TAB)
  =>nil


■handler-case
[       type]: Macro
[  arguments]: handler-case FORM &rest CASES
[    package]: lisp
[    seealso]: ignore-errors , trap-errors , unwind-protect , error , エラー処理関係
[   referred]: define-condition , make-condition
[       file]: handler.l
[    section]: エラー
[description]: 
例外をキャッチします。
詳細はエラー処理関連を参照してください。キャッチした例外は
si:*condition-stringで対応する文字列を取得できるようです。

  (handler-case
    例外が発生しそうな処理
    (エラーのシンボル1 (仮引数1) エラー処理1)     
    (エラーのシンボル2 (仮引数2) エラー処理2)     
    (エラーのシンボル3 (仮引数3) エラー処理3))

例えば、例外が発生しそうな処理で(error エラーシンボル2)が起きると、途中
の処理をすっとばして、エラー処理2が実行されます。そこで対応出来れば処理
を継続しますが、対応できなければ(error 仮引数2)を実行して、より上位の
handler-caseに対応をお願いします。どこまでいっても対応できなければ、
xyzzyがエラーダイアログを出して処理を終了します。

使用例：
  ;;; 例外が出ても、個々に対応しつつ処理を継続する場合
  ;;; with-output-to-stringを使ってるのは変数が煩わしいから
  (with-output-to-string (out)
    (dolist (i '((6 3) (6 0) (6 "a")))
      (handler-case
          (/ (car i) (cadr i))
        (division-by-zero (c)
          (format out "division-by-zero: ~a~%" (si:*condition-string c)))
        (error (c)
          (format out "error:\t ~a~%" (si:*condition-string c))))))
  => "division-by-zero: 0で除算しました: /: (6 0)
      error:     不正なデータ型です: \"a\": number"


■hash-table-count
[       type]: Function
[  arguments]: hash-table-count HASH-TABLE
[    package]: lisp
[    seealso]: hash-table-size , make-hash-table
[       file]: builtin.l
[    section]: ハッシュ
[description]: 
ハッシュテーブルの要素数を返します。

  HASH-TABLE : ハッシュテーブルを指定します。


■hash-table-p
[       type]: Function
[  arguments]: hash-table-p OBJECT
[    package]: lisp
[    seealso]: make-hash-table
[       file]: builtin.l
[    section]: ハッシュ
[description]: 
オブジェクトがハッシュテーブルかどうかを返します。

  OBJECT : 判定するオブジェクトを指定します。

  (hash-table-p x) == (typep x 'hash-table)


■hash-table-rehash-size
[       type]: Function
[  arguments]: hash-table-rehash-size HASH-TABLE
[    package]: lisp
[    seealso]: make-hash-table
[       file]: builtin.l
[    section]: ハッシュ
[description]: 
ハッシュテーブルの現在のrehash-sizeを返します。

  HASH-TABLE : ハッシュテーブルを指定します。


■hash-table-size
[       type]: Function
[  arguments]: hash-table-size HASH-TABLE
[    package]: lisp
[    seealso]: hash-table-count , make-hash-table
[       file]: builtin.l
[    section]: ハッシュ
[description]: 
ハッシュテーブルの現在の大きさを返します。

  HASH-TABLE : ハッシュテーブルを指定します。


■hash-table-test
[       type]: Function
[  arguments]: hash-table-test HASH-TABLE
[    package]: lisp
[    seealso]: make-hash-table
[       file]: builtin.l
[    section]: ハッシュ
[description]: 
ハッシュテーブルのキーを比較する関数を返します。

  HASH-TABLE : ハッシュテーブルを指定します。

使用例：
  (hash-table-test hash-table)
  => eql


■hide-command-bar
[       type]: Function
[  arguments]: hide-command-bar SYM
[    package]: editor
[    seealso]: show-command-bar
[       file]: cmdbar.l
[    section]: メニュー
[description]: 
define-command-barで定義したコマンドバーを非表示にします。


■hide-restricted-region
[       type]: Variable
[    package]: editor
[    seealso]: narrow-to-region
[    section]: リージョン
[description]: 
narrow-to-regionした領域を非表示にするか薄く表示するかを制御します。

  t   : 非表示にします。
  nil : 薄く表示します。


■hide-tool-bar
[       type]: Function
[  arguments]: hide-tool-bar NAME
[    package]: editor
[    seealso]: show-tool-bar
[       file]: builtin.l
[    section]: メニュー
[description]: 
ツールバーNAMEを非表示にします。


■html-highlight-mode
[       type]: BufferLocal
[    package]: editor
[    seealso]: set-syntax-tag , parse-point-syntax
[    section]: シンタックス
[description]: 
non-nilならばシンタックスの :tag が利用可能になります。


■if
[       type]: Special Form
[  arguments]: if TEST THEN [ELSE]
[    package]: lisp
[   referred]: cond
[       file]: builtin.l
[    section]: 制御構造
[description]: 
いわゆるIF文を実行します。
TESTがnon nilならTHENを実行。nilならELSEを実行します。

構文：
  (if TEST THEN [ELSE])


■ignore-errors
[       type]: Macro
[  arguments]: ignore-errors &body BODY
[    package]: lisp
[    seealso]: trap-errors , handler-case , unwind-protect , エラー処理関係
[   referred]: error
[       file]: handler.l
[    section]: エラー
[description]: 
本体を評価したときに発生するエラーを全て無視します。
エラーが発生した場合には、ignore-errorsはnilとそのコンディションを多値で
返します。

C++の場合：
  try {
    return resolve_shortcut("c:\\autoexec.bat");
  } catch (...) {
    return nil;
  }

xyzzyの場合：
  (ignore-errors  (resolve-shortcut "c:/autoexec.bat"))
  =>nil
  =>#S(file-error pathname "c:/autoexec.bat" datum ショートカットではありません)


■ignored-extensions
[       type]: Variable
[    package]: editor
[       file]: defs.l
[    section]: ミニバッファ
[description]: 
ミニバッファでの入力補完において、ignored-extensionsの拡張子がついたファ
イルは補完の対象になりません。

使用例：
  ; exeとdllは入力補完しない
  (setq ignored-extensions '("exe" "dll"))


■imagpart
[       type]: Function
[  arguments]: imagpart NUMBER
[    package]: lisp
[    seealso]: realpart , complex
[       file]: builtin.l
[    section]: 数値
[description]: 
複素数の虚数部を取得します。

使用例：
  (setq a (complex 1 3))
  =>#C(1 3)

  (imagpart a)
  =>3


■ime-push-composition-string
[       type]: Function
[  arguments]: ime-push-composition-string &optional NODELETE
[    package]: editor
[    seealso]: rewind-ime-composition
[       file]: kanji.l
[    section]: 文字列
[description]: 
セレクションの確定済仮名文字を非確定状態にします。[C-c C-p]


■ime-register-word-dialog
[       type]: Function
[  arguments]: ime-register-word-dialog
[    package]: editor
[       file]: kanji.l
[    section]: ダイアログ
[description]: 
単語/用例登録ダイアログを表示します。[C-c C-r]
セレクションがあれば、セレクションの文字列を語句とします。


■import
[       type]: Function
[  arguments]: import SYMBOLS &optional PACKAGE
[    package]: lisp
[    seealso]: パッケージ
[       file]: builtin.l
[    section]: パッケージ
[description]: 
シンボルのリストを指定して、その全てのシンボルをパッケージ内でパッケージ
名指定なしでアクセスできるようにします。シンボルが既にパッケージ内に存在
する場合は例外を発生します。


■in-package
[       type]: Macro
[  arguments]: in-package NAME
[    package]: lisp
[    seealso]: use-package , パッケージ , *package*
[   referred]: defpackage , make-package
[       file]: package.l
[    section]: パッケージ
[description]: 
どのパッケージで実行するかを変更します。変更した後に作られたシンボルは、
指定されたパッケージに登録されます。

使用例：
    ;;; これ以降新しく作られるシンボルは、"editor"パッケージに登録さ
    ;;; れるようになる。
    (in-package "editor")


■incf
[       type]: Macro
[  arguments]: incf PLACE &optional (DELTA 1)
[    package]: lisp
[    seealso]: decf
[       file]: setf.l
[    section]: 数値
[description]: 
変数をインクリメントします。

使用例：
  ;;; 変数xの値をインクリメントする。
  (setq x 1)    => 1
  (incf x)      => 2
  x             => 2


■indent-for-comment
[       type]: Function
[  arguments]: indent-for-comment
[    package]: editor
[       file]: cmds.l
[    section]: テキスト
[description]: 
行末にコメント文字列 (comment-start, comment-end) を挿入します。[ESC ;]
コメント位置は comment-indent-function を呼び出した結果で決まります。

コメント挿入後のカーソル位置は comment-start-skip か
comment-start-skip-function で指定できます。


■indent-region
[       type]: Function
[  arguments]: indent-region FROM TO
[    package]: editor
[   referred]: mode-specific-indent-command
[       file]: lispmode.l
[    section]: リージョン
[description]: 
mode-specific-indent-commandがnon-nilならば、指定のリージョンを
mode-specific-indent-commandで一行ずつインデントします。
行末はdelete-trailing-spacesで空白を削除されます。


■indent-relative
[       type]: Function
[  arguments]: indent-relative
[    package]: editor
[    seealso]: newline-and-indent
[   referred]: indent-to
[       file]: cmds.l
[    section]: テキスト
[description]: 
半角スペースやタブ以外の文字を後方へ向かって検索し、最初に見つかった
場所の行のインデント幅と同じだけ現在行をインデントします。

ちなみに emacs の同名のコマンドとは挙動が違います。


■indent-to
[       type]: Function
[  arguments]: indent-to COLUMN
[    package]: editor
[    seealso]: indent-relative , smart-indentation
[       file]: builtin.l
[    section]: テキスト
[description]: 
指定された桁数までインデントします。現在のカーソル位置が引数より小さけれ
ばスペースを挿入します。そうでなければ何もしません。

  COLUMN : インデントする桁数を指定します。

戻り値は以下のとおりです。

  t   インデントした場合
  nil 何もしなかった場合


■insert
[       type]: Function
[  arguments]: insert &rest STRING-OR-CHAR
[    package]: editor
[   referred]: insert-buffer , insert-buffer-substring
[       file]: builtin.l
[    section]: テキスト
[description]: 
文字列をバッファに挿入します。

  STRING-OR-CHAR : 挿入する文字列を指定します。
                   &restで受けられているので何個でもOKです。

履歴：
  xyzzyのバージョン0.0.0.45.1よりまえのバージョンでは
  Emacsとinsertの仕様が、やや異なっていました。

  ;;; Emacsの場合
  (insert "abc" "def" "ghi")
  => "abcdefghi"が挿入される

  ;;; xyzzyの場合
  (insert "ab" 4)
  => "abababab"が挿入される

  xyzzyのバージョン0.0.0.45.1以降、Emacsとのinsert互換性が高まって
  います。

  (insert "foo")         => foo          ; 今までと同じ
  (insert "foo" 2)       => foofoo       ; 今までと同じ
  (insert "foo" "bar")   => foobar       ; Emacsと同じ
  (insert "foo" "bar" 2) => foobarfoobar
  (insert #\f "o" #\o)   => foo          ; Emacsと同じ
  (insert #\f "o" #\o 2) => foofoo
  (insert 2)             => エラー
  (insert "foo" 2 "bar") => エラー
  (insert 102 111 111)   => エラー       ; Emacsは  => foo


■insert-buffer
[       type]: Function
[  arguments]: insert-buffer BUFFER
[    package]: editor
[    seealso]: insert-buffer-substring , insert-file , insert-file-contents , insert
[       file]: buffer.l
[    section]: バッファ
[description]: 
指定されたバッファの内容を現在のバッファに挿入します。


■insert-buffer-substring
[       type]: Function
[  arguments]: insert-buffer-substring BUFFER &optional FROM TO
[    package]: editor
[    seealso]: insert-buffer , insert
[       file]: buffer.l
[    section]: バッファ
[description]: 
指定されたバッファの内容を現在のバッファに挿入します。
リージョンが指定されていればその領域を挿入します。


■insert-file
[       type]: Function
[  arguments]: insert-file FILENAME &optional ENCODING
[    package]: editor
[    seealso]: insert-file-contents , insert-buffer , find-file
[   referred]: read-file
[       file]: files.l
[    section]: ファイルシステム
[description]: 
指定されたファイルをカーソルの位置に読み込みます。[C-x i]


■insert-file-contents
[       type]: Function
[  arguments]: insert-file-contents FILENAME &optional VISIT-P OFFSET SIZE
[    package]: editor
[    seealso]: insert-file
[   referred]: insert-buffer , read-file
[       file]: builtin.l
[    section]: バッファ
[description]: 
ファイルの内容をカーソル位置に挿入します。

  FILENAME : 挿入するファイル名
  VISIT-P  : ファイルを挿入後の動作を指定します。
        t       変更フラグ・UNDO情報のクリア、ファイルの日付の変更等を行います。
        nil     特に何もしません。
  OFFSET   : 挿入するオフセット
  SIZE     : 挿入する長さ

使用例：
  ;;; 簡単なテンプレートの挿入例
  ;;; site-lisp/template.lを用意しておくこと
  (defun insert-template ()
    (and (get-buffer-file-name)
         (not (file-exist-p (get-buffer-file-name)))
         (insert-file-contents (merge-pathnames "site-lisp/template.l" (si:system-root)) t)
         (message "template inserted")))
  => insert-template
  (add-hook '*lisp-mode-hook* 'insert-template)
  => (insert-template lisp-load-keyword-file)


■insert-menu-item
[       type]: Function
[  arguments]: insert-menu-item MENU POSITION TAG ITEM &optional COMMAND INIT
[    package]: editor
[    seealso]: add-menu-item , get-menu , define-menu
[       file]: builtin.l
[    section]: メニュー
[description]: 
メニュー項目を作成しメニューの所定の位置に挿入します。

  MENU     : 追加先のメニューを指定します。
  POSITION : 挿入する位置を指定します。
  TAG      : 識別するタグを指定します。必要なければnilを指定します。
  ITEM     : メニューに表示される名前を指定します。
  COMMAND  : メニューの項目が選択されたときに実行するコマンドを指定します。
  INIT     : メニューが開く直前に評価し返される値によってメニューの状態
             を設定します。詳細はadd-menu-itemを参照して下さい。


■insert-menu-separator
[       type]: Function
[  arguments]: insert-menu-separator MENU POSITION &optional TAG
[    package]: editor
[    seealso]: add-menu-separator , define-menu , define-popup-menu , get-menu , get-menu-position
[       file]: builtin.l
[    section]: メニュー
[description]: 
セパレータをメニューの所定の位置に挿入します。

  MENU     : 追加先のメニューを指定します。
  POSITION : 挿入する位置を指定します。
  TAG      : 識別するタグを指定します。


■insert-popup-menu
[       type]: Function
[  arguments]: insert-popup-menu MENU POSITION POPUP-MENU MENU-NAME
[    package]: editor
[    seealso]: add-popup-menu , define-popup-menu
[       file]: builtin.l
[    section]: メニュー
[description]: 
ポップアップメニューをメニューの所定の位置に挿入します。

  MENU       : 追加先のメニューを指定します。
  POSITION   : 挿入する位置を指定します。
  POPUP-MENU : 追加するポップアップメニューを指定します。
  NAME       : メニューに表示される名前を指定します。

使用例：
  ;;; 右クリックメニューを標準のメニューに追加してみる。
  (insert-popup-menu *app-menu* 2 *app-popup-menu* "編集2(&E)")
  => #<menu 48701736>


■insert-register
[       type]: Function
[  arguments]: insert-register R
[    package]: editor
[    seealso]: copy-to-register
[   referred]: copy-rectangle-to-register
[       file]: register.l
[    section]: リージョン
[description]: 
レジスタ R の内容をバッファに挿入します。[C-x r i], [C-x r g]
R にテキストまたは矩形領域が入っていないとエラーになります。


■integer-length
[       type]: Function
[  arguments]: integer-length INTEGER
[    package]: lisp
[       file]: builtin.l
[    section]: 数値
[description]: 
2進数で表した時の長さを返します。

使用例:
  (integer-length 7) => 3 ; #b00000111
  (integer-length 8) => 4 ; #b00001000


■integerp
[       type]: Function
[  arguments]: integerp OBJECT
[    package]: lisp
[    seealso]: numberp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTがintegerならt、それ以外ならnilを返します。

  (integerp x) == (typep x 'integer)


■interactive
[       type]: Special Form
[  arguments]: interactive {INTERACTIVE-STRING {PARAMETER}*|LIST}
[    package]: editor
[    seealso]: commandp , long-operation , *prefix-args* , read-buffer-name , read-char-encoding , read-command-name , read-directory-name , read-exist-buffer-name , read-exist-file-name , read-file-name-list , read-file-name , read-function-name , read-integer , read-sexp , read-string , read-symbol-name , read-variable-name
[   referred]: command-execute , completing-read , eval-expression , interactive-p , lambda-list-keywords
[       file]: builtin.l
[    section]: 関数
[description]: 
関数が対話的に実行可能であること、すなわちコマンドであることを宣言します。
このフォームを定義に含む関数は対話的に実行できます。
対話的に実行とは具体的には
・キーバインドでの実行
・M-x (execute-extended-command) での実行
・ツールバーでの実行
などです。

実行に引数が必要でない関数では必要ありませんが、引数を与えなければならな
い関数の場合は、INTERACTIVE-STRINGによって対話的に実行したときに関数に渡
す引数の値やその与え方を制御する必要があります。
INTERACTIVE-STRINGの構成は以下のようになります。
  *             任意。書込み禁止バッファでの実行を禁止します。
  0             任意。プロンプトに数引数がつきます。
  指定子        引数に与えるデータとその与え方の指定になります。
  任意の文字列  ミニバッファで引数を与えるときのプロンプトになります。
  \n            区切り文字です。続けて次の引数についての記述ができます。

PARAMETERでは指定子に対する設定を記述できます。
 :defaultN      初期表示
 :historyN      履歴情報
 :titleN        ダイアログのタイトル
Nの部分には何番目の指定子に対する設定かという数値が入ります。
例えば最初の指定子に対する初期表示の指定は:default0で行います。
:defaultNと:titleNで指定するのは文字列、
:historyNで指定するのはminibuffer-history-variableプロパティを持つシンボルです。
履歴のデータはそのプロパティ値が使用されます。minibuf.l参照。

以下、指定子とその動作です。

  {属性}
   P: Prompt       ミニバッファでユーザー入力
   M: Must Match   正しく入力されるまで繰り返す
   C: Completion   入力候補表示・補完あり
   D: Default      :defaultN使用可能
   H: History      :historyN使用可能
   T: Title        :titleN使用可能

  [最終変換値]
  {xx}    - 関数には xxx 型の値がくる
  {xx/yy} - 入力値が省略又は未定義値だと、yy型がくる
  {xx|yy} - 入力値が多重値だと、yy の型でくる
  {*****} - なんでもあり

        {PMCDHT}
  a     {PMCDH }[symbol]        関数名
  B     {P CDH }[buffer/string] バッファ名
  b     {PMCDH }[buffer]        既存のバッファ名
  c     {P     }[character]     文字
  C     {PMCDH }[symbol]        コマンド名
  d     {      }[integer]       ポイント位置
  D     {PMCDHT}[string]        ディレクトリ名
  e     {P CDH }[string]        実行ファイル
  F     {P CDHT}[string]        ファイル名
  f     {PMCDHT}[string]        既存のファイル名
  l     {P CDHT}[string|cons]   ファイル名(複数可)
  M     {      }[integer]       セレクション開始位置
  m     {      }[integer]       マーク位置
  n     {PM    }[integer]       整数
  N     {PM    }[integer]       整数(前置引数を優先)
  p     {      }[integer]       前置引数の値
  P     {      }[symbol/nil]    生の前置引数
  R     {      }[integer]       セレクション範囲(一つ目がセレクションの始点、二つ目がセレクションの終点)
  r     {      }[integer]       リージョン(一つ目がマーク位置、二つ目がポイント位置)
  s     {P  DH }[string]        文字列
  S     {PMCDH }[symbol]        シンボル
  v     {PMCDH }[symbol]        変数名
  X     {P     }[*****]         S式(引数には評価した値が渡される)
  x     {P     }[*****]         S式そのもの
  z     {PMC H }[encoding]      文字エンコーディング
  Z     {PMC H }[encoding]      文字エンコーディング(自動判定を除く)
 
新たに任意の指定子を作成することもできます。
*interactive-specifier-alist*に指定子にあたる文字と処理の関数シンボルを
登録します。keymap.lを参照。

また、LISTにて指定子に依らない任意の動作をさせることもできます。
cmds.lのrepeat-complex-commandの定義などを参照。

備考:
・0zと0Zという指定は特別に、前置引数が与えられたときのみミニバッファで入
  力待ちになるという動作になります。
・PARAMETERで:emacsにnon-nilを指定するとemacsとの互換性を考慮した動作に
  なります。


■interactive-p
[       type]: Function
[  arguments]: interactive-p
[    package]: editor
[    seealso]: commandp , interactive
[       file]: builtin.l
[    section]: 評価
[description]: 
実行中の関数が interactive に呼ばれていればt、そうでなければnilを返します。

使用例：
  ;;; fooとbarという関数を定義して、fooをinteractiveに呼び出してみる。
  ;;; fooはinteractive扱いされているが、barはそうでない。
  (defun foo () (interactive) (msgbox "foo: ~A" (interactive-p)) (bar))
  => foo
  (defun bar () (interactive) (msgbox "bar: ~A" (interactive-p)))
  => bar
  M-x: foo
  => [foo: t]
     [bar: nil]


■intern
[       type]: Function
[  arguments]: intern STRING &optional PACKAGE
[    package]: lisp
[    seealso]: find-symbol , symbol-name , unintern , make-symbol , パッケージ
[   referred]: gentemp , symbol-package
[       file]: builtin.l
[    section]: パッケージ
[description]: 
文字列からシンボルを作成します。作成したシンボルは指定されたパッケージに
internされます。make-symbolも文字列からシンボルを作り出しますが、パッケ
ージにinternされません。

  STRING  : 文字列
  PACKAGE : 作成したシンボルを登録するパッケージ

使用例：
  ;;; foobarというシンボルが*package*に登録される
  (intern "foobar")
  => foobar

  ;;; foobazというシンボルがlispパッケージに登録される。
  (intern "foobaz" (find-package "lisp"))
  => foobaz


■internal-time-units-per-second
[       type]: Variable
[    package]: editor
[    seealso]: get-internal-real-time
[    section]: 日付・時間
[description]: 
get-internal-real-time で取得した値の、1秒あたりの量を表します。
Windowsの種類により、この値が変わるかどうかは不明です。


■intersection
[       type]: Function
[  arguments]: intersection LIST1 LIST2 &rest REST &key :test :test-not :key
[    package]: lisp
[    seealso]: nintersection , union , set-difference , set-exclusive-or , ldiff , subsetp
[       file]: list.l
[    section]: リスト
[description]: 
LIST1 と LIST2 の両方に含まれる要素のリストを作って返します。
nintersection と違い引数 LIST1 は保存されます。

使用例:
  (intersection '(1 3 5 7 9) '(2 3 5 7 11))
  => (7 5 3)


■isqrt
[       type]: Function
[  arguments]: isqrt INTEGER
[    package]: lisp
[       file]: builtin.l
[    section]: 数値
[description]: 
整数の平方根を整数で返します。

 (isqrt INTEGER) == (floor (sqrt INTEGER))

使用例：
  ;;; 143と144のisqrtを計算する。
  (isqrt 143)
  => 11
  (isqrt 144)
  => 12


■jump-to-register
[       type]: Function
[  arguments]: jump-to-register R
[    package]: editor
[    seealso]: point-to-register
[       file]: register.l
[    section]: ポジション
[description]: 
レジスタ R に格納されたマーカーの位置へジャンプします。[C-x r j]
R にマーカーが入っていないとエラーになります。


■just-one-space
[       type]: Function
[  arguments]: just-one-space
[    package]: editor
[    seealso]: delete-horizontal-spaces , delete-indentation
[       file]: cmds.l
[    section]: テキスト
[description]: 
カーソル位置の前後にある半角スペースとタブを削除した後、半角スペース
をひとつだけ挿入します。[ESC /]


■kana-char-p
[       type]: Function
[  arguments]: kana-char-p CHAR
[    package]: editor
[    seealso]: kanji-char-p , characterp
[       file]: builtin.l
[    section]: データ型
[description]: 
文字が半角カナ文字かを返します。

  t    半角カナ文字である。
  nil  半角カナ文字でない。

カナ文字は以下の範囲です。
  Code          Char
  ----          ----
  0xa1 .. 0xb0  #\｡ .. #\ｰ
  0xb1 .. 0xdd  #\ｱ .. #\ﾝ
  0xde          #\ﾞ
  0xdf          #\ﾟ


■kanji-char-p
[       type]: Function
[  arguments]: kanji-char-p CHAR
[    package]: editor
[    seealso]: kana-char-p , characterp
[       file]: builtin.l
[    section]: データ型
[description]: 
文字CHARが漢字かを返します。
（詳細不明）


■kept-undo-information
[       type]: BufferLocal
[    package]: editor
[    seealso]: undo , undo-boundary , clear-undo-boundary , setup-temp-buffer
[    section]: バッファ
[description]: 
undo 可能回数を指定する変数です。

  <integer> : 指定回数分の undo 情報を保持します。
  上記以外  : undo 情報を保持しません。(undo できません。)

使用例：
  ;;; 現在開いているファイルではundoできないようにします。
  (make-local-variable 'kept-undo-information)
  => t
  (setq kept-undo-information nil)
  => nil


■key-to-string
[       type]: Function
[  arguments]: key-to-string KEY &optional ESC-TO-META
[    package]: editor
[       file]: help.l
[    section]: キーマップ
[description]: 
キーを読みやすいように文字列に変換します。

  ESC-TO-META : non-nilならESCをM-に変換します

使用例:
  (key-to-string '(#\ESC #\C-a))    => "ESC C-a"
  (key-to-string '(#\ESC #\C-a) t)  => "M-C-a"


■keymapp
[       type]: Function
[  arguments]: keymapp OBJECT
[    package]: editor
[    seealso]: make-keymap
[       file]: builtin.l
[    section]: データ型
[description]: 
指定されたOBJECTがキーマップかを返します。

  non-nil   OBJECTはキーマップ
  nil       OBJECTはキーマップではない


■keywordp
[       type]: Function
[  arguments]: keywordp OBJECT
[    package]: lisp
[       file]: builtin.l
[    section]: データ型
[description]: 
与えられたオブジェクト OBJECT がキーワードか否かを返します。 OBJECT がシ
ンボルであり、かつ keyword パッケージに所属するときに t を返しているよう
です。

  (symbol-package 'a)
  =>#<package: user>
  (symbol-package :a)
  =>#<package: keyword>
  
  (symbolp 'a)
  =>t
  (keywordp 'a)
  =>nil
  
  (symbolp :a)
  =>t
  (keywordp :a)
  =>t


■kill-all-buffers
[       type]: Function
[  arguments]: kill-all-buffers &optional NOT-VERBOSE
[    package]: editor
[       file]: buffer.l
[    section]: バッファ
[description]: 
全バッファをkill-bufferします。
NOT-VERBOSEで保存するか否かを指定できます。

  NOT-VERBOSE :
        t       何も確認せずに保存しようとします。
        nil     変更があるバッファは確認のダイアログ表示されます。


■kill-all-local-variables
[       type]: Function
[  arguments]: kill-all-local-variables
[    package]: editor
[   referred]: kill-local-variable , make-local-variable
[       file]: builtin.l
[    section]: バッファ
[description]: 
全てのローカル変数が現在のバッファで独自の値を持てないようにします。
setq-defaultされていなかったローカル変数は参照できなくなります。

使用例：
  ;;; defvar-localした変数の値を設定してからkillしてみる。
  (defvar-local abc 123)        => abc
  (setq abc 456)                => 456
  abc                           => 456
  (kill-all-local-variables)    => t
  abc                           => 123


■kill-buffer
[       type]: Function
[  arguments]: kill-buffer BUFFER
[    package]: editor
[    seealso]: delete-buffer , deleted-buffer-p , kill-selected-buffer , *query-kill-buffer-hook* , *kill-buffer-kills-scratch*
[       file]: buffer.l
[    section]: バッファ
[description]: 
バッファを削除します。[C-x k]
ただし、kill-bufferはバッファが変更されていると削除していいかどうか聞
いてきます。マクロ中で使う際には、delete-bufferを使ったほうがいいでし
ょう。(ユーザに聞かずにいきなり削除します）

また、*query-kill-buffer-hook*にフック関数を設定すると、独自の用件でバ
ッファの破棄を確認できます。

使用例：
  ;;; 現在のバッファを削除する。
  (kill-buffer (selected-buffer))
  => t


■kill-line
[       type]: Function
[  arguments]: kill-line &optional LINES
[    package]: editor
[    seealso]: *kill-ring* , kill-region
[       file]: cmds.l
[    section]: リージョン
[description]: 
行をkillします。 killした行は *kill-ring* へ追加されます。 [C-k]
連続して kill-line を実行することで、複数行を一括して
*kill-ring* へ追加することができます。

  LINES 
     nil  : ポイントが行末ならば、その位置の改行コードをkillします。
            ポイントが行末でなければ、その行の行末までkillします。
       0  : ポイントが行頭ならば、前行の行頭までkillします。
            ポイントが行頭でなければ、その行の行頭までkillします。
     その他の整数 : 指定された行数 kill します。 


■kill-local-variable
[       type]: Function
[  arguments]: kill-local-variable SYMBOL
[    package]: editor
[    seealso]: kill-all-local-variables , make-local-variable , make-variable-buffer-local
[       file]: builtin.l
[    section]: バッファ
[description]: 
SYMBOLが現在のバッファで独自の値を持てない様にします。
kill-local-variableを実行した後では、SYMBOLの値はグローバルなSYMBOLの値
になります。setq-defaultされていなかったローカル変数は参照できなくなります。

使用例：
  ;;; defvar-localした変数の値を設定してからkillしてみる。
  (defvar-local abc 123)        => abc
  (setq abc 456)                => 456
  abc                           => 456
  (kill-local-variable 'abc)    => t
  abc                           => 123


■kill-paragraph
[       type]: Function
[  arguments]: kill-paragraph &optional (ARG 1)
[    package]: editor
[    seealso]: kill-region , backward-kill-paragraph
[       file]: paragrph.l
[    section]: リージョン
[description]: 
現在のパラグラフの最後までkillします。


■kill-process
[       type]: Function
[  arguments]: kill-process PROCESS
[    package]: editor
[    seealso]: kill-subprocess , signal-process , make-process
[   referred]: process-status
[       file]: builtin.l
[    section]: プロセス
[description]: 
プロセスを強制的に終了させます。


■kill-rectangle
[       type]: Function
[  arguments]: kill-rectangle P1 P2
[    package]: editor
[    seealso]: delete-rectangle , kill-region , kill-rectangle-selection , *rectangle-kill-buffer*
[   referred]: copy-rectangle , copy-rectangle-to-register , yank-rectangle
[       file]: rectangl.l
[    section]: リージョン
[description]: 
P1とP2で指定される矩形領域をkillします。
killした矩形領域のyankには、yank-rectangleを使います。
通常の*kill-ring*とは別の領域に格納されているようです。


■kill-rectangle-selection
[       type]: Function
[  arguments]: kill-rectangle-selection
[    package]: editor
[    seealso]: copy-rectangle-selection , kill-rectangle , operate-on-rectangle-selection
[   referred]: delete-rectangle-selection , kill-rectangle-selection-to-clipboard , yank-rectangle-selection
[       file]: select.l
[    section]: リージョン
[description]: 
マウスで矩形選択されたセレクションの領域をkillします。
yankにはyank-rectangle-selectionを使いますが、yank-rectangleでも行けそうです。
killした内容は*kill-ring*ともクリップボードとも違う領域に格納されているようです。


■kill-rectangle-selection-to-clipboard
[       type]: Function
[  arguments]: kill-rectangle-selection-to-clipboard
[    package]: editor
[    seealso]: kill-rectangle-selection , copy-rectangle-selection-to-clipboard
[   referred]: copy-to-clipboard , kill-region-to-clipboard , kill-selection-to-clipboard
[       file]: select.l
[    section]: リージョン
[description]: 
マウスで矩形選択されたセレクションの領域を削除した後、クリップボードにコ
ピーします。


■kill-region
[       type]: Function
[  arguments]: kill-region FROM TO
[    package]: editor
[    seealso]: copy-region-as-kill , kill-selection , zap-to-char
[   referred]: *kill-ring* , backward-kill-paragraph , kill-line , kill-paragraph , kill-rectangle , kill-region-to-clipboard , kill-word
[       file]: region.l
[    section]: リージョン
[description]: 
リージョンをkill ringに入れます。 [C-w]

--- kill ringのいい加減な説明 ---
kill-regionした文字列は、*kill-ring*の先頭に追加されます。*kill-ring*は
最大で*kill-ring-max*（標準で16）まで保持できます。最大を越えたら古いも
のから破棄されます。

        *kill-ring*
        ┌─────┐  ─┐
        │"defun"   ←─── kill-regionした内容
        ├──↓──┤    │
        │"length"  │    │
        ├──↓──┤    ├最大*kill-ring-max*個
        │"test"    │    │
        ├──↓──┤    │
        │...       │    │
        └─────┘  ─┘

普通はkill[C-k]してyank[C-y]したら、*kill-ring*の先頭のものしか貼り付け
られませんが、killした直後にyank-pop[M-y]を繰り返すと、*kill-ring*の要素
を順次貼り付けてくれます。


■kill-region-to-clipboard
[       type]: Function
[  arguments]: kill-region-to-clipboard FROM TO
[    package]: editor
[    seealso]: kill-rectangle-selection-to-clipboard , kill-region
[   referred]: copy-to-clipboard , kill-selection-to-clipboard
[       file]: region.l
[    section]: リージョン
[description]: 
FROMとTOで指定される領域を削除したのち、クリップボードにコピーします。


■kill-selected-buffer
[       type]: Function
[  arguments]: kill-selected-buffer
[    package]: editor
[    seealso]: kill-buffer
[       file]: buffer.l
[    section]: バッファ
[description]: 
名前のとおりselected-bufferをkill-bufferします。

参考：
  ;;; buffer.l
  (defun kill-selected-buffer ()
    (interactive)
    (kill-buffer (selected-buffer)))


■kill-selection
[       type]: Function
[  arguments]: kill-selection
[    package]: editor
[    seealso]: yank-selection , copy-selection
[   referred]: kill-region
[       file]: select.l
[    section]: リージョン
[description]: 
選択された領域を切り取り、*selection-ring*の先頭に追加します。 [F7]
追加した内容はyank-selectionで貼り付けられます。


■kill-selection-to-clipboard
[       type]: Function
[  arguments]: kill-selection-to-clipboard
[    package]: editor
[    seealso]: kill-region-to-clipboard , kill-rectangle-selection-to-clipboard
[   referred]: copy-to-clipboard
[       file]: select.l
[    section]: リージョン
[description]: 
セレクションを削除し、クリップボードに転送します。[C-Delete]
矩形選択状態であれば、 kill-rectangle-selection-to-clipboard
を実行します。


■kill-subprocess
[       type]: Function
[  arguments]: kill-subprocess
[    package]: editor
[    seealso]: kill-process , make-process
[       file]: process.l
[    section]: プロセス
[description]: 
バッファに結び付けられているプロセスを停止させます。[C-c C-k]


■kill-word
[       type]: Function
[  arguments]: kill-word &optional (ARG 1)
[    package]: editor
[    seealso]: backward-kill-word , kill-region , forward-word
[       file]: cmds.l
[    section]: リージョン
[description]: 
カーソル位置から前方の単語の末尾までを切り取り、キルリングに追加します。
[ESC d] または [ESC h]
カーソルが単語の途中にある場合は、カーソル位置からその単語の末尾までが、
対象となります。


■kinsoku-bol-chars
[       type]: Function
[  arguments]: kinsoku-bol-chars &optional BUFFER
[    package]: editor
[    seealso]: kinsoku-eol-chars , set-kinsoku-chars
[   referred]: kinsoku-extend-limit , kinsoku-goto-column
[       file]: builtin.l
[    section]: テキスト
[description]: 
行頭禁則文字の集合を文字列で返します。


■kinsoku-eol-chars
[       type]: Function
[  arguments]: kinsoku-eol-chars &optional BUFFER
[    package]: editor
[    seealso]: kinsoku-bol-chars , set-kinsoku-chars
[   referred]: kinsoku-goto-column , kinsoku-shorten-limit
[       file]: builtin.l
[    section]: テキスト
[description]: 
行末禁則文字の集合を文字列で返します。


■kinsoku-extend-limit
[       type]: Function
[  arguments]: kinsoku-extend-limit &optional BUFFER
[    package]: editor
[    seealso]: kinsoku-bol-chars , kinsoku-shorten-limit , set-kinsoku-chars , kinsoku-goto-column
[       file]: builtin.l
[    section]: テキスト
[description]: 
禁則処理でぶら下げる文字数を返します。


■kinsoku-goto-column
[       type]: Function
[  arguments]: kinsoku-goto-column COLUMN &optional KINSOKU-MODE
[    package]: editor
[    seealso]: kinsoku-bol-chars , kinsoku-extend-limit , kinsoku-eol-chars , kinsoku-shorten-limit
[       file]: builtin.l
[    section]: テキスト
[description]: 
COLUMN桁で禁則処理を施したときの行末に移動します。


■kinsoku-mode
[       type]: Function
[  arguments]: kinsoku-mode &optional BUFFER
[    package]: editor
[    seealso]: set-kinsoku-chars , *fill-kinsoku-mode*
[       file]: builtin.l
[    section]: テキスト
[description]: 
禁則処理の状態を表す4ビットのフラグを返します。

  8: 禁則処理を行うとき t
  4: ワードラップするとき t
  2: 改行文字をぶら下げるとき t
  1: 空白文字をぶら下げるとき t


■kinsoku-shorten-limit
[       type]: Function
[  arguments]: kinsoku-shorten-limit &optional BUFFER
[    package]: editor
[    seealso]: kinsoku-eol-chars , kinsoku-extend-limit , set-kinsoku-chars , kinsoku-goto-column
[       file]: builtin.l
[    section]: テキスト
[description]: 
禁則処理で追い出す文字数を返します。


■lambda
[       type]: Misc
[  arguments]: lambda LAMBDA-LIST [[{DECLARATION}* | DOCUMENTATION]] {FORM}*
[    package]: lisp
[    seealso]: defun , si:closure-variable
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
関数に名前を付ける必要がなく、手続きだけを記述したい場合にラムダ式
を用います。ラムダ式の二番目の引数はラムダリストと呼ばれ、関数の
パラメータの名前を与えます。lambda式のより完全な構文は以下です。

(lambda ({var}*
         [&optional {var | (var [initform [svar]])}*]
         [&rest var]
         [&key {var | ({var | (keyword var)} [initform [svar]])}*]
         [&aux {var | (var [initform])}*])
   [[{declaration}* | documentation-string]]
   {form}*)

引数がラムダ式によって表される関数に適用されると、form が評価
されて最後の form の結果が返されます。form は順に評価されます。

((lambda (x y) (+ x y)) 10 20)        => 30

ラムダリストの各要素は、パラメータ指定子や、記号&（アンパサンド）
で始まるラムダリストキーワードからなる。ラムダリストは５つの部分で
構成されます。

・必須パラメータの記述
    ラムダリストキーワードよりも前に現れる var を必須パラメータという。

・オプショナルパラメータの記述
    &optionalから次のラムダリストキーワードまでか、ラムダリストの
    終わりまで。関数呼び出し時に、オプショナルパラメータに対応する
    引数はあっても無くてもよい。引数が省略された場合、initform が
    あれば initform に初期化され、無ければ nil で初期化される。
    svar は引数が与えられたかどうかを示す。

  ((lambda (x &optional (y 0 given))
       (if given (+ x y) x))
    10 20)
  => 30

・レストパラメータの記述
    &restとそれに続く一つのパラメータ指定子。関数への引数のうち、
    必須パラメータとオプショナルパラメータに対応するもの以外
    からなるリストに束縛される。

  ((lambda (x &optional (y 1) (z 2) &rest args)
       (list x y z args))
    'a 'b 'c 'd 'e 'f)
  => (a b c (d e f))

・キーワードパラメタの記述
    &keyから次のラムダリストキーワードまでか、ラムダリストの
    終わりまで。関数が呼ばれたときに対応する keyword に対応する
    パラメータ指定子 var が値に束縛される。

  ((lambda (x &key ((:test f) #'eq))
       (if (funcall f x "word") 'True 'False))
   "word" :test #'equal)
  => True

  ((lambda (x &key (test #'eq))
       (if (funcall test x "word") 'True 'False))
    "word" :test #'eql)
  => False

・補助変数の記述
    ラムダリストに &aux が含まれるなら、この後の全ての指定は
    補助変数の指定子である。次に示す二つの例は同じ結果を与える。
    これらの使用については純粋にスタイルの問題である。
  
  ((lambda (x &aux (l (length x)))
       (list x l))
    '(a b c))
  => ((a b c) 3)
  
  ((lambda (x)
       (let ((l (length x))) (list x l)))
    '(a b c))
  => ((a b c) 3)


■lambda-list-keywords
[       type]: Variable
[    package]: lisp
[    seealso]: interactive
[       file]: evalmacs.l
[    section]: 変数と定数
[description]: 
ラムダリストキーワードとして使えるシンボルのリストです。

参照例:
  lambda-list-keywords
  =>(&optional &rest &key &aux &body &whole &environment)


■lambda-parameters-limit
[       type]: Variable
[    package]: lisp
[    seealso]: call-arguments-limit
[    section]: 変数と定数
[description]: 
lambdaに与えることのできる引数の個数の限界値

参照例： 
  lambda-parameters-limit
  => 536870911


■last
[       type]: Function
[  arguments]: last LIST &optional (N 1)
[    package]: lisp
[    seealso]: butlast , subseq
[       file]: builtin.l
[    section]: リスト
[description]: 
リストの末尾からN個分のリストを返します。

使用例：
  ;;; 末尾を取得してみる。
  (last '(a b c d))     => (d)
  (last '(a b c d) 2)   => (c d)
  (last '(a b c d) 5)   => (a b c d)


■launch-application
[       type]: Function
[  arguments]: launch-application APP
[    package]: editor
[       file]: dialogs.l
[    section]: プロセス
[description]: 
プログラムを xyzzy の外部で実行します。


■lcm
[       type]: Function
[  arguments]: lcm INTEGER &rest MORE-INTEGERS
[    package]: lisp
[    seealso]: gcd
[       file]: builtin.l
[    section]: 数値
[description]: 
引数の最小公倍数を返します。

使用例：  
  (lcm 14 35)
  => 70
  (lcm 0 5)
  => 0
  (lcm 1 2 3 4 5 6)
  => 60


■ldb
[       type]: Function
[  arguments]: ldb BYTESPEC INTEGER
[    package]: lisp
[    seealso]: dpb , byte
[   referred]: deposit-field , ldb-test , mask-field
[       file]: number.l
[    section]: 数値
[description]: 
指定されたフィールドの値を取り出します。
フィールドを指定する byte specifier は関数 byte で作ります。

例：
  ;;; 最下位ビットを取り出す
  (ldb (byte 1 0) #x02)  => 0
  (ldb (byte 1 0) #x0f)  => 1
  ;;; (最下位バイトの)上位 4 ビットを取り出す
  (ldb (byte 4 4) #x0f)  => 0
  (ldb (byte 4 4) #xaf)  => 10
  (ldb (byte 4 4) #xf0)  => 15


■ldb-test
[       type]: Function
[  arguments]: ldb-test BYTESPEC INTEGER
[    package]: lisp
[    seealso]: ldb
[       file]: number.l
[    section]: 数値
[description]: 
指定されたフィールドが non-zero かどうかを判定します。
(not (zerop (ldb BYTESPEC INTEGER))) と同じです。


■ldiff
[       type]: Function
[  arguments]: ldiff LIST OBJECT
[    package]: lisp
[    seealso]: tailp , intersection , set-difference , set-exclusive-or
[   referred]: union
[       file]: list.l
[    section]: リスト
[description]: 
OBJECT が LIST の一部であるなら、LIST から OBJECT の部分を除いたリストを返します。

LIST の一部分であるかどうかの判定は eq で行います。
OBJECT が LIST の tailp であれば LIST の一部であるとみなされるとも言えます。

使用例:
  (setq x '(a b c d e))
  => (a b c d e)
  (setq y (cddr x))
  => (c d e)
  (ldiff x y)
  => (a b)
  ;; 見た目は同じでも x の一部分でないならダメ
  (ldiff x '(c d e))
  => (a b c d e)


■length
[       type]: Function
[  arguments]: length SEQUENCE
[    package]: lisp
[    seealso]: list-length , fill-pointer
[   referred]: make-array , vector
[       file]: builtin.l
[    section]: シーケンス
[description]: 
sequence(文字列や、リスト、配列)の長さを求めます。
配列にfill-pointerがある場合は、そこまでの長さになります。

使用例：
  (length "abcd")               => 4
  (length (list 1 2 3))         => 3
  (length (make-array 7))       => 7
  (length (make-array 7 :fill-pointer 4))
                                => 4


■let
[       type]: Special Form
[  arguments]: let ({VAR|(VAR [VALUE])}*) {declaration}* {FORM}*
[    package]: lisp
[    seealso]: let*
[   referred]: do* , prog
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
ローカルな変数を定義してフォームを評価します。


■let*
[       type]: Special Form
[  arguments]: let* ({VAR|(VAR [VALUE])}*) {declaration}* {FORM}*
[    package]: lisp
[    seealso]: let
[   referred]: do* , prog*
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
letとよく似ています。letと異なり、VARの初期化に先に定義した他のVARを参照
することが可能です。

使用例：
  ;;; letとlet*の違い
  (setq Y 2)
  => 2
  (let (X (Y 1) (Z Y)) (list X Y Z))
  => (nil 1 2)
  (let* (X (Y 1) (Z Y)) (list X Y Z))
  => (nil 1 1)


■lisp-complete-symbol
[       type]: Function
[  arguments]: lisp-complete-symbol
[    package]: editor
[    seealso]: *lisp-popup-completion-list*
[       file]: lispmode.l
[    section]: シンボル
[description]: 
Lisp のシンボル名を補完します。[ESC TAB]


■lisp-indent-hook
[       type]: Misc
[    package]: editor
[    section]: シンボル
[description]: 
シンボルにプロパティを設定することで lisp-indent-line でのインデント量を制御します。

  数値 n   : n 番目以降の引数を *lisp-body-indent* だけ、
             それより前の引数を (* *lisp-body-indent* 2) だけインデント
  nil      : 通常のインデント
             ただし1番目の引数のインデント量は *lisp-indent-offset* に従う
  それ以外 : すべての引数を *lisp-body-indention* だけインデント

使用例：
  ;;; $XYZZY/lisp/lispmode.l から
  (setf (get 'lambda 'lisp-indent-hook) 'defun)
  (setf (get 'interactive 'lisp-indent-hook) 1)
  (setf (get 'progn 'lisp-indent-hook) 0)
  (setf (get 'if 'lisp-indent-hook) 2)
  (setf (get 'let 'lisp-indent-hook) 1)
  (setf (get 'let* 'lisp-indent-hook) 1)


■list
[       type]: Function
[  arguments]: list &rest ARGS
[    package]: lisp
[    seealso]: list* , make-list
[       file]: builtin.l
[    section]: リスト
[description]: 
この関数は、 ARGS を要素とするリストを作ります。結果として返されるリ
ストは(常に) nil でターミネート(訳注：終端)されています。 ARGS が与え
られない場合、 empty リストを返します。 

  (list 1 2 3 4 5)
  => (1 2 3 4 5)
  (list)
  => nil


■list*
[       type]: Function
[  arguments]: list* &rest ARGS
[    package]: lisp
[    seealso]: list
[       file]: builtin.l
[    section]: リスト
[description]: 
list とよく似て ARGS を要素とするリストを作りますが、 最後の要素だけは
コンスセルの cdr部に直接つなげます。

使用例:
  (setq a (list 1 2 3))
  => (1 2 3)            ; (1 . (2 . (3 . nil)))

  (setq b (list* 1 2 3))
  => (1 2 . 3)          ; (1 . (2 . 3))

  (setq c (list* 4 5 6 a))
  => (4 5 6 1 2 3)


■list-all-packages
[       type]: Function
[  arguments]: list-all-packages
[    package]: lisp
[    seealso]: defpackage , パッケージ
[   referred]: find-package
[       file]: builtin.l
[    section]: パッケージ
[description]: 
xyzzy内に存在するパッケージ一覧をリストで返します。

使用例：
  (list-all-packages)
  =>  (#<package: win-user> #<package: winapi> #<package: 
     foreign>  #<package: lisp> #<package: system> #<package: 
     keyword> #<package: user> #<package: editor>)


■list-archive
[       type]: Function
[  arguments]: list-archive ARCHIVE-FILE &optional FILE-NAME-ONLY
[    package]: editor
[    seealso]: create-archive
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
アーカイブのファイル名一覧を取り出します。

  ARCHIVE-FILE   : 一覧を取得するアーカイブを指定します。
  FILE-NAME-ONLY : 戻り値の形式を指定します。
        t   ファイル名(ディレクトリ名)のみを返します。
        nil ファイル名(ディレクトリ名)、属性、サイズ、タイムスタンプを
            返します。

使用例：
  (list-archive "foo.lzh")


■list-function
[       type]: Function
[  arguments]: list-function &rest ARGS
[    package]: editor
[    seealso]: ed::build-summary-function
[       file]: listfn.l
[    section]: 関数
[description]: 
バッファ中の関数の一覧をダイアログで表示します。選択することで定
義位置にジャンプすることが可能です。バッファ中の関数の一覧は、バ
ッファローカル変数build-summary-functionから取得しています。


■list-length
[       type]: Function
[  arguments]: list-length LIST
[    package]: lisp
[    seealso]: length
[       file]: builtin.l
[    section]: リスト
[description]: 
リストの長さを返します。
リストが循環している場合、length は結果を返さないかもしれませんが、
list-length は nil を返します。

使用例：
  ;;; リストの長さを比べてみる。
  (list-length '())             => 0 
  (list-length '(a b c d))      => 4 
  (list-length '(a (b c) d))    => 3 
  (let ((a '(x)))
    (setf (cdr a) a)
    (list-length a))            => nil


■list-server-resources
[       type]: Function
[  arguments]: list-server-resources SERVER-NAME &optional COMMENT-P
[    package]: editor
[    seealso]: list-servers
[       file]: builtin.l
[    section]: その他
[description]: 
指定されたコンピュータの共有資源の一覧を取得します。
同時に資源のコメントも取得可能です。

使用例：
  (list-server-resources "SAMURAI")
  => ("SPOOL" "E" "D" "A")
  (list-server-resources "SAMURAI" t)
  => (("SPOOL" "") ("E" "CD-ROM Drive") ("D" "Backup Storage") ("A" "FD Drive"))


■list-servers
[       type]: Function
[  arguments]: list-servers &optional COMMENT-P
[    package]: editor
[    seealso]: list-server-resources
[       file]: builtin.l
[    section]: その他
[description]: 
ネットワークコンピュータの一覧が取得できます。
同時にコンピュータに設定されているコメントも取得可能です。

使用例：
  (list-servers)
  => ("SAMURAI" "ROUNIN")
  (list-servers t)
  => (("SAMURAI" "Main Machine") ("ROUNIN" "Sub Machine"))


■list-text-attributes
[       type]: Function
[  arguments]: list-text-attributes &optional START END
[    package]: editor
[    seealso]: find-text-attribute , set-text-attribute
[       file]: builtin.l
[    section]: テキスト
[description]: 
バッファ中のテキスト属性をすべて探し、リストにして返します。
範囲を指定した場合、その範囲中に一部でも含まれるものをリストにします。

  START : 検索範囲の開始点
  END   : 検索範囲の終了点


■list-tool-bars
[       type]: Function
[  arguments]: list-tool-bars
[    package]: editor
[   referred]: tool-bar-info
[       file]: builtin.l
[    section]: メニュー
[description]: 
ツールバーの状態を取得します。状態は以下の形式で返されます。

形式：
  (((左側のツールバー1 横位置1 縦位置1 横幅1)
    (左側のツールバー2 横位置2 縦位置2 横幅2)
    (左側のツールバー3 横位置3 縦位置3 横幅3) ... )
   ((上側のツールバー1 横位置1 縦位置1 横幅1) ... )
   ((右側のツールバー1 横位置1 縦位置1 横幅1) ... )
   ((下側のツールバー1 横位置1 縦位置1 横幅1) ... )
   (非表示のツールバー1 非表示のツールバー2 ... ))

タブバーの場合だけ横幅に数字が返されます。ツールバーの場合には、必ずnil
が返されます。


■list-xyzzy-windows
[       type]: Function
[  arguments]: list-xyzzy-windows
[    package]: editor
[    seealso]: next-xyzzy-window , previous-xyzzy-window
[   referred]: activate-xyzzy-window
[       file]: builtin.l
[    section]: プロセス
[description]: 
起動中のxyzzyの一覧をリスト形式で返します。
  
  (list-xyzzy-windows)
  =>((0 . "*scratch* - xyzzy 0.2.2.235@XYZZY") (1 . "*untitled* - xyzzy 0.2.2.235@XYZZY") (2 . "*untitled*<2> - xyzzy 0.2.2.235@XYZZY"))


■listen
[       type]: Function
[  arguments]: listen &optional INPUT-STREAM
[    package]: lisp
[    seealso]: read-char-no-hang
[       file]: builtin.l
[    section]: 入出力
[description]: 
指定された入力ストリームに何か入力がある状態ならばt、ないならばnilを返します。


■listp
[       type]: Function
[  arguments]: listp OBJECT
[    package]: lisp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTがconsか空リスト()ならt、それ以外ならnilを返します。

  (listp x) == (typep x 'list) == (typep x '(or cons null))


■load-file
[       type]: Function
[  arguments]: load-file FILENAME
[    package]: lisp
[    seealso]: load-library , load , mc-load-file
[       file]: misc.l
[    section]: 評価
[description]: 
ファイルを対話的に読み込みます。
load-library と異なり、*load-path* にないファイルも読み込めます。


■load-keyword-file
[       type]: Function
[  arguments]: load-keyword-file NAME &optional ICASE TABLE CONDITION
[    package]: editor
[    seealso]: キーワードファイルの書き方 , *keyword-load-path* , make-list-from-keyword-table
[       file]: kwd.l
[    section]: その他
[description]: 
キーワードファイルをロードします。

使用例：
  (and *xmldoc-keyword-file*
       (null *xmldoc-keyword-hash-table*)
       (setq *xmldoc-keyword-hash-table*
             (load-keyword-file *xmldoc-keyword-file* t)))
  (when *xmldoc-keyword-hash-table*
    (make-local-variable 'keyword-hash-table)
    (setq keyword-hash-table *xmldoc-keyword-hash-table*))


■load-library
[       type]: Function
[  arguments]: load-library FILENAME &rest REST
[    package]: lisp
[    seealso]: si:*load-library , load-file , *load-path* , mc-load-library , 各種ロード関係の関数の違い
[   referred]: require
[       file]: misc.l
[    section]: 評価
[description]: 
ライブラリを対話的に読み込みます。
requireと異なり、一度読んでいてももう一度読み込みます。

内部的には、si:*load-libraryをinteractiveで宣言したものです。

| また、si:*load-library中で失敗したら、メッセージ等を出力して、処理を続けると
| いうのは可能でしょうか？

  (handler-case
      (si:*load-library "foo")
    (error (c) (si:*print-condition c)))
      (si:*load-library "bar")


■load-session
[       type]: Function
[  arguments]: load-session FILENAME &optional NOT-CLOSE
[    package]: editor
[    seealso]: save-session , *default-session-directory*
[   referred]: open-session-dialog
[       file]: session.l
[    section]: バッファ
[description]: 
セッションファイルに保存されている状態を復元します。 [C-x 6 f]

  NOT-CLOSE : ロード前に開いているバッファを削除するかどうか
        nil       *scratch* を除いてすべて削除してからロード
        non-nil   残したままロード


■local-keymap
[       type]: Function
[  arguments]: local-keymap &optional BUFFER
[    package]: editor
[    seealso]: use-kaymap , local-set-key
[       file]: builtin.l
[    section]: キーマップ
[description]: 
バッファ BUFFER のローカルキーマップ (use-keymap で設定されたキーマッ
プ) を返します。

BUFFER が省略された場合はカレントバッファが対象になります。


■local-set-key
[       type]: Function
[  arguments]: local-set-key KEY COMMAND
[    package]: editor
[    seealso]: local-unset-key , local-keymap , global-set-key , define-key
[       file]: keymap.l
[    section]: キーマップ
[description]: 
カレントバッファのローカルキーマップにキーを登録します。
引数の意味は global-set-key と同じです。


■local-unset-key
[       type]: Function
[  arguments]: local-unset-key KEY
[    package]: editor
[    seealso]: local-set-key
[       file]: keymap.l
[    section]: キーマップ
[description]: 
ローカルキーマップのキー割り当てを解除します。

使用例：
  ;;; lisp-modeのTABのローカルキーマップを外す。
  (lookup-key-command #\TAB)
  => lisp-indent-line
  (local-unset-key #\TAB)
  => t
  (lookup-key-command #\TAB)
  => self-insert-command


■local-variable-p
[       type]: Function
[  arguments]: local-variable-p SYMBOL &optional BUFFER
[    package]: editor
[    seealso]: make-local-variable , defvar-local
[       file]: builtin.l
[    section]: データ型
[description]: 
指定されたシンボルがバッファローカル変数かどうかを判定します。

使用例：
  ;;; buffer: foo
  (local-variable-p 'abc)
  => nil
  (make-local-variable 'abc)
  => t
  (local-variable-p 'abc)
  => t

  ;;; buffer: bar
  (local-variable-p 'abc)
  => nil


■lock-file
[       type]: BufferLocal
[    package]: editor
[    seealso]: unlock-file , file-locked-p
[    section]: バッファ
[description]: 
ロックファイルを作るかどうかを指定する変数です。

  t   : ロックファイルを作る。
  nil : ロックファイルを作らない。

使用例：
  ;;; 現在開いているファイルではロックファイルを作らないようにする。
  (make-local-variable 'lock-file)
  => t
  (setq lock-file nil)
  => nil 


■log
[       type]: Function
[  arguments]: log NUMBER &optional BASE
[    package]: lisp
[       file]: builtin.l
[    section]: 数値
[description]: 
BASE を底とする NUMBER の対数を返します。

使用例：
  (log 2.718282)
  => 1.0
  (log 7.389056)
  => 2.0


■logand
[       type]: Function
[  arguments]: logand &rest ARGS
[    package]: lisp
[    seealso]: logior , logandc1 , logandc2 , lognand , lognot
[       file]: number.l
[    section]: 数値
[description]: 
ビット毎のANDを取ります。C言語でいう&です。

使用例：
  ;;; 2進数で#b11110000と#b00110011のビットの積を取る。
  (format nil "~8,'0b" (logand #b11110000 #b00110011))
  => "00110000"


■logandc1
[  arguments]: logandc1 X Y
[    package]: lisp
[    seealso]: logand , logandc2
[       file]: number.l
[    section]: 数値
[description]: 
Xの1の補数 と Y のビット毎の論理積を返します。

使用例:
  (format nil "~4,'0b" (logandc1 #b0011 #b0101))
  => "0100"
  (format nil "~4,'0b" (logand (lognot #b0011) #b0101))
  => "0100"


■logandc2
[  arguments]: logandc2 X Y
[    package]: lisp
[    seealso]: logand , logandc1
[       file]: number.l
[    section]: 数値
[description]: 
X と Yの1の補数 のビット毎の論理積を返します。

使用例:
  (format nil "~4,'0b" (logandc2 #b0011 #b0101))
  => "0010"
  (format nil "~4,'0b" (logand #b0011 (lognot #b0101)))
  => "0010"


■logeqv
[       type]: Function
[  arguments]: logeqv &rest ARGS
[    package]: lisp
[    seealso]: logxor
[       file]: number.l
[    section]: 数値
[description]: 
ビット毎の論理等価を返します。

使用例:
  (format nil "~4,'0b" (logeqv #b0011 #b0101))
  => "-111"
  (format nil "~4,'0b" (lognot (logxor #b0011 #b0101)))
  => "-111"


■logior
[       type]: Function
[  arguments]: logior &rest ARGS
[    package]: lisp
[    seealso]: logand , lognor , logorc1 , logorc2
[       file]: number.l
[    section]: 数値
[description]: 
ビット毎のORを取ります。C言語でいう|です。

使用例：
  ;;; 2進数で#b00110000と#b00000011のビットの和を取る。
  (format nil "~8,'0b" (logior #b00110000 #b00000011))
  => "00110011"


■lognand
[       type]: Function
[  arguments]: lognand X Y
[    package]: lisp
[    seealso]: logand , lognor
[       file]: number.l
[    section]: 数値
[description]: 
ビット毎の否定的論理積(NAND)を返します。

使用例:
  ;;; X        0011
  ;;; Y        0101
  ;;; AND      0001
  ;;; NAND     1110
  ;;; 1の補数  0001
  ;;; 2の補数  0010
  (format nil "~4,'0b" (lognand #b0011 #b0101))
  => "0-10"
  (format nil "~4,'0b" (lognot (logand #b0011 #b0101)))
  => "0-10"


■lognor
[       type]: Function
[  arguments]: lognor X Y
[    package]: lisp
[    seealso]: logior , lognand
[       file]: number.l
[    section]: 数値
[description]: 
ビット毎の否定的論理和(NOR)を返します。

使用例:
  ;;; X        0011
  ;;; Y        0101
  ;;; OR       0111
  ;;; NOR      1000
  ;;; 1の補数  0111
  ;;; 2の補数  1000
  (format nil "~4,'0b" (lognor #b0011 #b0101))
  => "-1000"
  (format nil "~4,'0b" (lognot (logior #b0011 #b0101)))
  => "-1000"


■lognot
[       type]: Function
[  arguments]: lognot INTEGER
[    package]: lisp
[    seealso]: logand , logor
[       file]: builtin.l
[    section]: 数値
[description]: 
INTEGERの1の補数(2進数表現で0と1を反転させたもの)を返します。

使用例:
  ;;; INTEGER 00000011
  ;;; 反転    11111100
  ;;; 1の補数 00000011
  ;;; 2の補数 00000100
  (lognot #b0011)
  => -4
  (format nil "~8,'0b" -4)
  => "0000-100"
  (format nil "~4,'0b" (lognot -4))
  => "0011"


■logorc1
[       type]: Function
[  arguments]: logorc1 X Y
[    package]: lisp
[    seealso]: logior , logorc2
[       file]: number.l
[    section]: 数値
[description]: 
Xの1の補数 と Y のビット毎の論理和を返します。

使用例:
  (format nil "~4,'0B" (logorc1 #b0011 #b0101))
  => "0-11"
  (format nil "~4,'0b" (logior (lognot #b0011) #b0101))
  => "0-11"


■logorc2
[       type]: Function
[  arguments]: logorc2 X Y
[    package]: lisp
[    seealso]: logior , logorc1
[       file]: number.l
[    section]: 数値
[description]: 
X と Yの1の補数 のビット毎の論理和を返します。

使用例:
  (format nil "~4,'0B" (logorc2 #b0011 #b0101))
  => "-101"
  (format nil "~4,'0b" (logior #b0011 (lognot #b0101)))
  => "-101"


■logxor
[       type]: Function
[  arguments]: logxor &rest ARGS
[    package]: lisp
[    seealso]: logeqv
[       file]: number.l
[    section]: 数値
[description]: 
ビット毎の排他的論理和を返します。

使用例:
  (format nil "~4,'0b" (logxor #b0011 #b0101))
  => "0110"


■long-float-p
[       type]: Function
[  arguments]: long-float-p OBJECT
[    package]: lisp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTがlong-floatならt、それ以外ならnilを返します。


■long-operation
[       type]: Macro
[  arguments]: long-operation &rest BODY
[    package]: editor
[    seealso]: begin-wait-cursor , end-wait-cursor
[   referred]: interactive
[       file]: misc.l
[    section]: その他
[description]: 
カーソルを砂時計にします。明らかに処理時間が長いことが見込まれる場合にし
ようすると良いと思います。

使用例：
  (long-operation
     (message "start")
     ;; 何か長い処理
     (message "end"))


■looking-at
[       type]: Function
[  arguments]: looking-at REGEXP &optional CASE-FOLD
[    package]: editor
[    seealso]: looking-for , scan-buffer , string-match , string-looking-at , 正規表現の表記
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
現在のカーソル位置で前方向に正規表現でマッチしたらt、しなかったらnilを返します。

使用例：
  ;;; カーソル位置が行頭でかつ(とマッチするか?
  (defun rrr ()
    (interactive)
    (if (looking-at "^(")
      (message "ok") (message "bad")))

  ;;; 空白やタブや全角スペースがあれば削除する
  (if (looking-at "[ \t　]*")
      (delete-region (match-beginning 0) (match-end 0)))

参考：
  ;;; looking-at の後方版 (正規表現で後方マッチ)
  ;;; XyzzyWiki 質問箱/175 より
  (defun looking-at-backward (regexp &optional case-fold)
    (save-excursion
      (save-restriction
        (narrow-to-region (point-min) (point))
        (goto-char (point-min))
        (scan-buffer (format nil "~A\\'" regexp)
                     :regexp t :case-fold case-fold))))


■looking-back
[       type]: Function
[  arguments]: looking-back STRING &optional CASE-FOLD
[    package]: editor
[    seealso]: looking-for
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
現在のカーソル位置から後方向にマッチしたらt、しなかったらnilを返します。

使用例：
  (looking-back "::")
  (looking-back "\\")
  (looking-back "#'")


■looking-for
[       type]: Function
[  arguments]: looking-for STRING &optional CASE-FOLD
[    package]: editor
[    seealso]: looking-at , looking-back
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
現在のカーソル位置から前方向にマッチしたらt、しなかったらnilを返します。
後方向にマッチしたければlooking-backを、正規表現でマッチしたければ
looking-atを使用します。

使用例：
  (looking-for "^")
  (looking-for "define")
  (looking-for "::")


■lookup-dictionary
[       type]: Function
[  arguments]: lookup-dictionary DIRECTORY DIC-FILE INDEX-FILE WORD
[    package]: editor
[       file]: builtin.l
[    section]: その他
[description]: 
辞書引き機能
（詳細不明）

使用例：
  (lookup-dictionary *edict-dictionary-path* "xyzzydic" "xyzzye2j" s)


■lookup-key-command
[       type]: Function
[  arguments]: lookup-key-command KEY
[    package]: editor
[    seealso]: lookup-keymap
[       file]: help.l
[    section]: キーマップ
[description]: 
指定したキーに設定された関数を返します。
lookup-keymapを使って実装されています。


■lookup-keymap
[       type]: Function
[  arguments]: lookup-keymap KEYMAP KEY &optional IGNORE-CASE SYMBOL-ONLY
[    package]: editor
[    seealso]: command-keys , lookup-key-command
[   referred]: make-keymap
[       file]: builtin.l
[    section]: キーマップ
[description]: 
指定したキーマップの中で指定したキーにバインドされた関数を返します。


■loop
[       type]: Macro
[  arguments]: loop &body BODY
[    package]: lisp
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
無限ループします。
脱出するには以下の様にreturnを使います。

 (loop
   処理
   (if 条件 (return 値))
   処理)

使用例：
  ;;; 「はい」と答えるまで繰り返し
  (loop (if (yes-or-no-p "quit?") (return 123)))
  => 123


■lower-case-p
[       type]: Function
[  arguments]: lower-case-p CHAR
[    package]: lisp
[    seealso]: upper-case-p , both-case-p , char-downcase
[       file]: builtin.l
[    section]: 文字
[description]: 
CHAR が小文字なら t 、そうでなければ nil を返します。

使用例：
  (lower-case-p #\a)
  => t
  (lower-case-p #\A)
  => nil
  (lower-case-p #\RET)
  => nil


■machine-name
[       type]: Function
[  arguments]: machine-name
[    package]: editor
[    seealso]: user-name , si:getenv
[   referred]: os-major-version , os-minor-version , os-platform
[       file]: builtin.l
[    section]: システム
[description]: 
マシン名を返します。

使用例：
  ;;; マシン名を返します。
  (machine-name)
  => "WS4849"

  ;;; PCによって、den8やdiffのインストールディレクトリが違っているので、
  ;;; 切り替えたりできます。
  (defun my-directory-setup ()
    (let ((x (machine-name)))
      (setq *diff-command-name*
            (cond ((string= x "TOMOYO") "c:/Cygnus/diff")
                   (t "c:/z/tools/diff")))
      (setq *den8-directory*
            (cond ((string= x "KANA") "D:/1gou-ki/den8_321")
                   (t "c:/z/den8_321")))))


■macro-function
[       type]: Function
[  arguments]: macro-function SYMBOL
[    package]: lisp
[    seealso]: fboundp , boundp
[       file]: builtin.l
[    section]: マクロ
[description]: 
SYMBOLがマクロか否かを返します。マクロの場合にはその内容を返します。
使用例：
  (macro-function 'car)
  =>nil

  (macro-function 'when)
  =>(macro (lisp::test &body lisp::body)
         (block when (list 'if lisp::test (cons 'progn lisp::body))))


■macroexpand
[       type]: Function
[  arguments]: macroexpand FORM &optional ENV
[    package]: lisp
[    seealso]: defmacro , macroexpand-1
[       file]: builtin.l
[    section]: マクロ
[description]: 
フォームがどのようにマクロ展開されるかを返します。
マクロの展開され方を確認するのに役立ちます。

使用例：
  ;;; マクロM2を定義してどのように展開
  (defmacro M2 (&rest args)
      `(progn
         (m-setup) ,@args (m-cleanup)))
  (macroexpand '(M2 (insert "Begin") (insert "End")))
  => (progn (m-setup) (insert "Begin") (insert "End") (m-cleanup)) 


■macroexpand-1
[       type]: Function
[  arguments]: macroexpand-1 FORM &optional ENV
[    package]: lisp
[    seealso]: macroexpand
[       file]: builtin.l
[    section]: マクロ
[description]: 
macroexpandに似ていますが、展開されるレベルが1レベルで終わるところが違います。
自作のマクロなどがどう展開されるのか調べるときに便利です。

使用例:
  (defmacro my-macro ()
    `(dotimes (x 10)))
  というマクロがあるとき
  
  (macroexpand '(my-macro))
  => (block nil (let* ((x 0) (#1=#:count 10)) (lisp::*loop (if (>= x #1#) (return (progn 'nil))) (tagbody) (setq x (+ x 1)))))
  とmy-macro展開後のdotimesまで(実際はdotimesを展開後さらにdo*を展開)が
  再帰的に展開されますが、

  (macroexpand-1 '(my-macro))
  => (dotimes (x 10))
  と、my-macroだけが展開されます。


■macrolet
[       type]: Special Form
[  arguments]: macrolet ({(NAME LAMBDA-LIST {declaration}* [doc-string] {FORM}*)}*) {FORM}*
[    package]: lisp
[    seealso]: defmacro , flet
[       file]: builtin.l
[    section]: マクロ
[description]: 
defmacroの局所版です。


■make-array
[       type]: Function
[  arguments]: make-array DIMENSIONS &rest REST &key (:element-type t) (:initial-element () ies-p) (:initial-contents () ics-p) :fill-pointer :adjustable :displaced-to (:displaced-index-offset 0)
[    package]: lisp
[    seealso]: make-sequence , aref , setf , make-vector , length , array-dimensions
[   referred]: adjustable-array-p , array-element-type , array-rank , fill-pointer , vector
[       file]: array.l
[    section]: 配列
[description]: 
DIMENSIONS で示される大きさ・次元の配列をつくり、それを値として返します。
もし、DIMENSIONS が nil なら、ゼロ次元配列がつくられます。
たとえば、変数 hoge をサイズ4の一次元配列(=サイズ4のベクタ)にするためには、

  (setf hoge (make-array 4))
  => #(nil nil nil nil)

変数 foo をサイズ2x4の二次元配列とするためには、

  (setf foo (make-array '(2 4)))
  => #2A((nil nil nil nil) (nil nil nil nil))

とします。
:element-type は、新しい配列の各要素の型を規定します。
:initial-element が与えられている場合、新しい配列の全要素はすべて
:initial-element に初期化されます。これに対して、:initial-contents が与えら
れている場合、新しい配列の各要素が :initial-contents で初期化されます。
たとえば、

  (make-array '(2 4) :initial-element 10); 2x4の配列をつくる。:initial-elementで初期化
  => #2A((10 10 10 10) (10 10 10 10))
  (setq a (make-array '(2 4) 
  :initial-contents '((0 1 2 3) (3 2 1 0))); 2x4の配列をつくる。:initial-contentsで初期化
  => #2A((0 1 2 3) (3 2 1 0))

なお、配列の要素にアクセスするためには、 aref が使われます。

:displaced-to, :displaced-index-offset 指定は、元の配列の一部からなる共有配列
を生成するために使われます。 copy-seq による複製とは違い、配列自体を共有しています。

  (setq b (make-array '(2 3) :displaced-to a :displaced-index-offset 2))
  => #2A((2 3 3) (2 1 0))

  (setq c (make-array 5 :displaced-to a :displaced-index-offset 1))
  => #(1 2 3 3 2)

  (setf (aref b 1 0) 10)
  a
  => #2A((0 1 2 3) (3 10 1 0))
  b
  => #2A((2 3 3) (10 1 0))
  c
  => #(1 2 3 3 10)


■make-backup-files
[       type]: BufferLocal
[    package]: editor
[   referred]: save-buffer
[    section]: バッファ
[description]: 
バックアップファイルを作るかどうかを指定する変数です。

  t   : バックアップファイルを作る
  nil : バックアップファイルを作らない

使用例：
  ;;; 現在開いているファイルをバックアップとらないようにする。
  (make-local-variable 'make-backup-files)
  => t
  (setq make-backup-files nil)
  => nil


■make-broadcast-stream
[       type]: Function
[  arguments]: make-broadcast-stream &rest STREAMS
[    package]: lisp
[    seealso]: broadcast-stream-streams , broadcast-stream-p , make-concatenated-stream , make-echo-stream , xyzzyで提供されているストリームの種類
[       file]: builtin.l
[    section]: 入出力
[description]: 
ブロードキャスト用の出力ストリームを作成します。
STREAMS に指定した複数のストリームに対して同時に出力することができます。

参考：
                        OUTPUT━━┓
                    ┌→┃STREAM1 ┠→
                    │  ┗━━━━┛
        BROADCAST ┓│  OUTPUT━━┓
    ─→┃STREAM  ┠┼→┃STREAM2 ┠→
        ┗━━━━┛│  ┗━━━━┛
                    │  OUTPUT━━┓
                    └→┃STREAM3 ┠→
                        ┗━━━━┛
使用例：
  ;;; fooとbarという出力ストリームを作ってから、
  ;;; hogeというブロードキャスト用ストリームを作り一括して出力
  (with-open-stream (foo (open "foo.txt" :direction :output))
    (with-open-stream (bar (open "bar.txt" :direction :output))
      (with-open-stream (hoge (make-broadcast-stream foo bar))
        (princ "abc" hoge))))
  => "abc"


■make-buffer-stream
[       type]: Function
[  arguments]: make-buffer-stream BUFFER &optional POINT EOB
[    package]: editor
[    seealso]: buffer-stream-buffer , buffer-stream-point , buffer-stream-set-point , xyzzyで提供されているストリームの種類
[   referred]: buffer-stream-p
[       file]: builtin.l
[    section]: 入出力
[description]: 
バッファ上にbuffer-streamを作成します。

  BUFFER : buffer-streamを作成するバッファを指定します。
  POINT  : 入出力を開始するポイントを指定します。
        nil     バッファの先頭が開始位置
        nil以外 指定されたポイントが開始位置
  EOB    : 終端のポイントを指定します。
        nil     バッファの最後が終端
        nil以外 指定されたポイントが終端


■make-concatenated-stream
[       type]: Function
[  arguments]: make-concatenated-stream &rest STREAMS
[    package]: lisp
[    seealso]: make-broadcast-stream , xyzzyで提供されているストリームの種類
[   referred]: concatenated-stream-streams
[       file]: builtin.l
[    section]: 入出力
[description]: 
STREAMS に指定した複数の入力ストリームをくっつけて、順番に読み出すための
一つの入力ストリームを作ります。

参考：
                        INPUT ━━┓    
                      ┌┨STREAM1 ┃←─
                      │┗━━━━┛    
        CONCAT━━┓  │INPUT ━━┓    
    ←─┨STREAM  ┃←┼┨STREAM2 ┃←─
        ┗━━━━┛  │┗━━━━┛    
                      │INPUT ━━┓    
                      └┨STREAM3 ┃←─
                        ┗━━━━┛    

使用例：
  ;;; 文字列の入力ストリームを二本作った後、一本に連接してみる。
  (with-open-stream (foo (make-string-input-stream "foo"))
    (with-open-stream (bar (make-string-input-stream "bar"))
      (with-open-stream (hoge (make-concatenated-stream foo bar))
        (while (setq in (read-char hoge nil))
          (write-char in)))))


■make-condition
[       type]: Function
[  arguments]: make-condition TYPE &rest ARGS
[    package]: lisp
[    seealso]: handler-case , error , エラー処理関係 , define-condition
[       file]: condition.l
[    section]: エラー
[description]: 
TYPE 型のコンディションを作成して返します。
作成するだけで、エラーにはなりません。
エラーを発生させるには error などで投げる必要があります。

使用例:
  (make-condition 'simple-error)
  => #S(simple-error format-string nil format-arguments nil)


■make-dispatch-macro-character
[       type]: Function
[  arguments]: make-dispatch-macro-character CHAR &optional NON-TERMINATING-P READTABLE
[    package]: lisp
[    seealso]: set-dispatch-macro-character , get-dispatch-macro-character
[       file]: builtin.l
[    section]: 入出力
[description]: 
ディスパッチマクロ文字を新たに作成します。
CHAR が既にディスパッチマクロ文字であれば何もしません。


■make-echo-stream
[       type]: Function
[  arguments]: make-echo-stream INPUT-STREAM OUTPUT-STREAM
[    package]: lisp
[    seealso]: echo-stream-input-stream , echo-stream-output-stream , echo-stream-p , make-two-way-stream , make-broadcast-stream , xyzzyで提供されているストリームの種類
[       file]: builtin.l
[    section]: 入出力
[description]: 
INPUT-STREAM からの入力を OUTPUT-STREAM に出力するストリームを作成します。
make-two-way-stream と異なり、 INPUT-STREAM から入力された内容は、全て
OUTPUT-STREAM にエコーされます。

参考：

     ECHO STREAM━┓    INPUT ━━┓
    ←─┨←───┨←─┨STREAM  ┃←─
        ┃    ┌─┨    ┗━━━━┛
        ┃    └→┃    OUTPUT━━┓
    ─→┠───→┠─→┃STREAM  ┠─→
        ┗━━━━┛    ┗━━━━┛


■make-hash-table
[       type]: Function
[  arguments]: make-hash-table &key :test :size :rehash-size :rehash-threshold
[    package]: lisp
[    seealso]: gethash , hash-table-count , hash-table-p , hash-table-rehash-size , hash-table-size , hash-table-test , remhash , clrhash , maphash , eql
[       file]: builtin.l
[    section]: ハッシュ
[description]: 
ハッシュテーブルを作成して返します。

  :test        : ハッシュテーブルのキーの等価関係。デフォルトは eql です。
                 指定可能な関数は、eq, eql, equal, equalp に限られます。
  :size        : ハッシュテーブルの初期サイズの目安。
                 この値よりも大きい素数、または 2, 3, 5, 7 で割れない値
                 に設定されます。
  :rehash-size : ハッシュテーブルのテーブルサイズを増加させる量の目安。
                 デフォルトは 1。現在のサイズ と :rehash-size を参考
                 に、より大きい素数、または 2, 3, 5, 7 で割れないサイズ
                 にします。
  :rehash-threshold
               : xyzzy では実装されていないようです。 (0.2.2.235 現在)
                 その代わり、テーブルの使用率が 80% を超えるとテーブル
                 を伸長します。

とりうる素数は以下の通りです。
      17, 47, 101, 149, 199, 307, 401, 499, 599, 701, 797, 907, 997,
      1103, 1499, 1999, 2999, 4001, 4999, 6007, 7001, 8009, 8999,
      10007, 19997, 29989, 39989, 49999, 59999, 70001, 79999, 90001, 99991

使用例:
  (setq hash (make-hash-table :size 3))
  => #<hashtable 51122492>

  (progn
    (setf (gethash #\C-0 hash) 0)
    (setf (gethash #\C-1 hash) 1)
    (setf (gethash #\C-2 hash) 2))
  => 2
  
  (gethash #\C-1 hash)
  => 1
      t

  (hash-table-size hash)
  => 17

  (hash-table-rehash-size hash)
  => 1

  (hash-table-test hash)
  => eql


■make-keymap
[       type]: Function
[  arguments]: make-keymap
[    package]: editor
[    seealso]: make-sparse-keymap , keymapp , use-keymap , define-key , lookup-keymap
[   referred]: *full-keymap-length*
[       file]: builtin.l
[    section]: キーマップ
[description]: 
空のキーマップを作成します。


■make-list
[       type]: Function
[  arguments]: make-list SIZE &key :initial-element
[    package]: lisp
[    seealso]: list , make-sequence
[       file]: builtin.l
[    section]: リスト
[description]: 
指定された長さのリストを作成して返します。

  SIZE             : リストの長さ
  :initial-element : リストの要素

使用例：
  (make-list 3)
  => (nil nil nil)
  (make-list 0)
  => nil
  (make-list 2 :initial-element 'x)
  => (x x)


■make-list-from-keyword-table
[       type]: Function
[  arguments]: make-list-from-keyword-table HASH
[    package]: editor
[   referred]: load-keyword-file
[       file]: kwd.l
[    section]: 変数と定数
[description]: 
キーワードハッシュテーブルから補完用のリストを作成します。

  HASH：キーワードハッシュテーブル(*xxxx-keyword-hash-table*)を指定

使用例：
  ;;; CSSのキーワードハッシュテーブルを元に
  ;;; 補完用リストを作成して、do-completionする。
  (defun css-completion ()
    (interactive)
    (or *css-completion-list*
        (setq *css-completion-list* (make-list-from-keyword-table *css-keyword-hash-table*))
        (return-from css-completion nil))
    (let ((opoint (point)))
      (when (skip-syntax-spec-backward "w_")
        (let ((from (point)))
          (goto-char opoint)
          (do-completion from opoint :list-ignore-case *css-completion-list*)))))


■make-local-variable
[       type]: Function
[  arguments]: make-local-variable SYMBOL
[    package]: editor
[    seealso]: make-variable-buffer-local , defvar-local , local-variable-p , kill-local-variable , kill-all-local-variables , buffer-local-value
[   referred]: setq-default
[       file]: builtin.l
[    section]: バッファ
[description]: 
SYMBOLを現在のバッファで独自の値を持てるようにローカル変数にします。
make-variable-buffer-localとは異なり、現在のバッファだけです。

使用例：
  ;;; 現在のバッファは自動保存しないようにする。
  (make-local-variable 'auto-save)
  => t  
  (setq auto-save nil)
  => nil


■make-marker
[       type]: Function
[  arguments]: make-marker &optional BUFFER
[    package]: editor
[    seealso]: point-marker , markerp , set-marker , mark , marker-point , goto-char , process-marker
[   referred]: scan-buffer
[       file]: builtin.l
[    section]: ポジション
[description]: 
空のマーカーを作って返します。
バッファを編集することで、マーカーの位置もそれに追随して変わります。
マーカーは、 goto-char や buffer-substring、delete-region などのバッ
ファ上の位置を引数にとる関数の引数として使用できます。

  BUFFER : マーカーを作るバッファを指定します。
           指定しなければ、現在のバッファになります。

使用例：
  ;; スクラッチでマーカーを作る
  (setq marker (make-marker (find-buffer "*scratch*")))
  => #<marker: *scratch*: ->

  ;; マーカーに位置を設定する
  (set-marker marker 3)
  => #<marker: *scratch*: 3>

  ;; マーカー位置に移動する
  (goto-char marker)
  => t

  ;; マーカーより手前の内容を削除する
  (goto-char (point-max))
  (delete-region 0 1)
  (marker-point marker)
  => 2

  ;; マーカーより手前に文字列を挿入する
  (goto-char 0)
  (insert "abc")
  (marker-point marker)
  => 5

  ;; マーカー位置に文字列を挿入する
  (goto-char marker)
  (insert "xyz")
  (marker-point marker)
  => 5


■make-package
[       type]: Function
[  arguments]: make-package PACKAGE-NAME &key :nicknames :use :internal-size :external-size
[    package]: lisp
[    seealso]: defpackage , delete-package , in-package , パッケージ
[       file]: builtin.l
[    section]: パッケージ
[description]: 
パッケージを作成します。defpackageとの違いは？（詳細不明）

使用例：
  (make-package name :external-size 0)


■make-process
[       type]: Function
[  arguments]: make-process COMMAND-LINE &key :environ :output :exec-directory :incode :outcode :eol-code
[    package]: editor
[    seealso]: call-process , execute-subprocess , filter-region , buffer-process , process-send-string , set-process-sentinel , set-process-filter , kill-subprocess , shell-execute , open-network-stream
[   referred]: kill-process , process-marker , process-status
[       file]: builtin.l
[    section]: プロセス
[description]: 
プロセスを起動します。

  COMMAND-LINE    : 実行するコマンドをオプション付で指定します。
  :environ        : 設定する環境変数を連想リスト形式で渡します。
                    (("HOME" . "C:/applications/xyzzy/")
                     ("TOPDIR" . "C:/spool/"))
  :output         : プロセスの標準出力を出力するバッファを指定します。
  :exec-directory : 実行するディレクトリを指定します。
  :incode         : プロセスの入力の文字コードを指定します。
  :outcode        : プロセスの出力の文字コードを指定します。
  :eol-code       : 改行コードを指定します。

プロセスへの入力はprocess-send-stringを使用します。
プロセスはバッファに関連付けられ、プロセスの出力がバッファにそのまま出力されます。
バッファに関連付けられたプロセスの状態は，モードライン上に :Run や :Exit と
表示されます。また、環境変数や出力先等を変更できます。

戻り値は，バッファに関連付けられたプロセスです。

参考:
  [xyzzy:02210]山本真二さん
  call-process または別の組み込み関数で、標準入力、標準出力、標準エラー
  出力を直接バッファに繋ぐようにした方が早くてかっこいいと思うのですが、
  難しいですか？

  (make-process *eshell* :output (selected-buffer))
  (process-send-string (buffer-process (selected-buffer))
                       (concatenate 'string cmd *shell-ret*))


■make-random-state
[       type]: Function
[  arguments]: make-random-state &optional STATE
[    package]: lisp
[    seealso]: *random-state* , random-state-p , random
[       file]: builtin.l
[    section]: 数値
[description]: 
乱数の状態を初期化します

  STATE:
    nil          初期化はせずに現在の*random-state*のコピーを返します。
    t            時刻に基づいて新しい状態を作ります。
    random-state この関数(make-random-state)の戻り値を渡すとコピーが返ります。

使用例:
 ;;;乱数列の再現
 (let ((rs1 (make-random-state nil))
       (rs2 (make-random-state nil)))   ;;現状の乱数状態のコピーを二つ作る
   (dotimes (i 10)
     (format t "~A " (random 100 rs1))) ;;一つ目
   (terpri)
   (dotimes (i 10)
     (format t "~A " (random 100 rs1))) ;;一つ目やりすぎて
   (terpri)
   (dotimes (i 10)
     (format t "~A " (random 100 rs2))) ;;二つ目を少し見てみる。
   (terpri))
 =>3 41 81 70 73 66 32 72 2 55   ;ここと
   21 97 83 14 86 26 99 69 18 46 
   3 41 81 70 73 66 32 72 2 55   ;ここが同じになる


■make-sequence
[       type]: Function
[  arguments]: make-sequence TYPE SIZE &key :initial-element
[    package]: lisp
[    seealso]: make-vector , make-array , make-list
[   referred]: concatenate , map , string
[       file]: sequence.l
[    section]: シーケンス
[description]: 
要素のタイプが TYPE でサイズが SIZE なシーケンスを作成して返します。
:initial-element が与えられた場合はそれぞれの項目はそれで初期化されます。
  
TYPE の値と返されるシーケンスは以下の通りです。
  'list          ──→ リスト
  'vector        ─┬→ ベクタ
  'simple-vector ─┘
  'string        ─┬→ 文字列
  'simple-string ─┘

TYPE にはリストを与えることもでき、その場合は最初の要素でシーケンスが決まります。
  '(list ...)         ──→ リスト
  '(array ...)        ─┬→ 配列
  '(simple-array ...) ─┘
最初の要素が list の場合、二番目以降の引数は無視されます。
最初の要素が array または simple-array の場合は三番目の要素まで意味を持ちます。
二番目の要素は値によって以下のように変化します。リストの場合はその最初の要素で判断されます。
  t                  ─┬→ 配列
  nil                ─┘
  character          ─┬→ 文字列
  base-character     ─┤
  standard-char      ─┤
  extended-character ─┘
三番目の要素は 1 または (*) または (SIZE に等しい数値) でなければなりませんが、
どれを選んでも動作に違いはないようです。
  
使用例：
  ;;; #\a が 8 文字の文字列を作ってみる
  (make-sequence 'string 8 :initial-element #\a)
  => "aaaaaaaa"
  (make-sequence 'list 4 :initial-element "abc")
  => (#1="abc" #1# #1# #1#)
  (make-sequence 'vector 4 :initial-element 'a)
  => #(a a a a)
  ;;; あえて TYPE に array を与えてみる
  (make-sequence '(array t (*)) 4 :initial-element 'a)
  => #(a a a a)
  (make-sequence '(array character 1) 8 :initial-element #\a)
  => "aaaaaaaa"


■make-sparse-keymap
[       type]: Function
[  arguments]: make-sparse-keymap
[    package]: editor
[    seealso]: make-keymap
[       file]: builtin.l
[    section]: キーマップ
[description]: 
空のキーマップを作成します。
キー定義の数が少ない時に使うとメモリを節約できます。

使用例：
  ;;; lispmode.lより
  (unless *lisp-mode-map*
    (setq *lisp-mode-map* (make-sparse-keymap))
    (define-key *lisp-mode-map* #\C-M-x 'eval-defun)
    ...
    (define-key *lisp-mode-map* #\) 'lisp-electric-close))


■make-string-input-stream
[       type]: Function
[  arguments]: make-string-input-stream STRING &optional START END
[    package]: lisp
[    seealso]: make-string-output-stream , with-input-from-string , xyzzyで提供されているストリームの種類
[       file]: builtin.l
[    section]: 入出力
[description]: 
文字列からの入力用ストリームを作成します。
以後、このストリームからは文字列の内容を順番に取得可能です。

  STRING : 対象の文字列を指定します。
  START  : 入力ストリームとする開始位置です。
  END    : 入力ストリームとする終了位置です。

複数の入力ストリームを使用するのでなければ、with-input-from-string を使
用する方が簡単です。

使用例：
  ;;; 文字列の入力用ストリームからひとつ読み出してみる。
  (with-open-stream (foo (make-string-input-stream "abc def"))
    (read foo))
  => abc  

  ;;; with-input-from-stringを使って同じ事をしてみる。
  (with-input-from-string (foo "abc def")
    (read foo))
  => abc  


■make-symbol
[       type]: Function
[  arguments]: make-symbol PRINT-NAME
[    package]: lisp
[    seealso]: intern , gensym , symbol-package , uninterned
[       file]: builtin.l
[    section]: シンボル
[description]: 
印字名がPRINT-NAMEであるuninternedなシンボルを返します。

参考：
  evalmacs.l


■make-syntax-table
[       type]: Function
[  arguments]: make-syntax-table
[    package]: editor
[    seealso]: copy-syntax-table , syntax-table-p , use-syntax-table
[   referred]: syntax-table
[       file]: builtin.l
[    section]: シンタックス
[description]: 
シンタックステーブルを作成します。基本的に各文字にシンタックスコードを割
り振りますが、他にも目的の構文に応じて以下の設定を行います。

  ・文字列中のエスケープ文字の設定
  ・タグや括弧などの対応付けのある文字の設定
  ・単なる対になった区切り文字の設定
  ・コメントの設定
      ・開始終了を一文字で行うコメント
      ・開始終了を文字列で行うコメント
      ・C++スタイルのコメント
  ・特定行に文字があった場合のコメントの設定

これらの設定は set-syntax-... 系の関数を使って行います。設定に応じて、画
面の色付けや skip-syntax-spec-forward / skip-syntax-spec-backward での動作
が変わったりします。

デフォルト値：
  Num           Char            SyntaxCode
  ---           ----            ----------
  0x00          #\NUL           SCjunk
  0x01 .. 0x08  #\C-a .. #\C-h  SCjunk
  0x09          #\TAB           SCwhite
  0x0a          #\LFD           SCwhite
  0x0b          #\C-k           SCjunk
  0x0c          #\C-l           SCwhite
  0x0d          #\RET           SCwhite
  0x0e .. 0x1a  #\C-n .. #\C-z  SCjunk
  0x1b          #\ESC           SCjunk
  0x1c          #\C-\\          SCjunk
  0x1d          #\C-]           SCjunk
  0x1e          #\C-^           SCjunk
  0x1f          #\C-_           SCjunk
  0x20          #\SPC           SCwhite
  0x21 .. 0x2f  #\! .. #\/      SCpunct
  0x30 .. 0x39  #\0 .. #\9      SCword
  0x3a          #\:             SCpunct
  0x3b          #\;             SCpunct
  0x3c          #\<             SCpunct
  0x3d          #\=             SCpunct
  0x3e          #\>             SCpunct
  0x3f          #\?             SCpunct
  0x40          #\@             SCpunct
  0x41 .. 0x5a  #\A .. #\Z      SCword
  0x5b          #\[             SCpunct
  0x5c          #\\             SCpunct
  0x5d          #\]             SCpunct
  0x5e          #\^             SCpunct
  0x5f          #\_             SCpunct
  0x60          #\`             SCpunct
  0x61 .. 0x7a  #\a .. #\z      SCword
  0x7b          #\{             SCpunct
  0x7c          #\|             SCpunct
  0x7d          #\}             SCpunct
  0x7e          #\~             SCpunct
  0x7f          #\DEL           SCjunk
  0x80                          SCjunk
  0x81 ..0x9f   #\x81 .. #\x9f  SCkanji
  0xa0                          SCkanji
  0xa1 .. 0xb0  #\｡ .. #\ｰ      SCkana
  0xb1 .. 0xdd  #\ｱ .. #\ﾝ      SCkana
  0xde          #\ﾞ             SCkana
  0xdf          #\ﾟ             SCkana
  0xe0 .. 0xfc  #\xe0 .. #\xfc  SCkanji
  0xfd                          SCjunk
  0xfe                          SCjunk
  0xff                          SCjunk


■make-temp-file-name
[       type]: Function
[  arguments]: make-temp-file-name &optional PREFIX SUFFIX DIRECTORY DIRECTORY-P
[    package]: editor
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
一時作業用のファイルを作成しそのパスを返します。
ファイルは即時に作成されます。同じようにディレクトリを作成することも可能です。

  PREFIX      : 一時作業用のファイルの接頭子
  SUFFIX      : 一時作業用のファイルの拡張子
                指定が無ければ".tmp"となります。
  DIRECTORY   : 一時作業用のファイルを作成するディレクトリ
                指定が無ければ環境変数TMPに作成されます。
  DIRECTORY-P : ファイルではなくディレクトリを作成する場合
        t       ディレクトリを作成します。
        nil     ファイルを作成します。

使用例：
  ;;; C:\spoolに一時作業用ファイルを作成します。 
  (make-temp-file-name "_den" "tmp" "c:/spool")
  => "c:/spool/_denc0dc.tmp"


■make-two-way-stream
[       type]: Function
[  arguments]: make-two-way-stream INPUT-STREAM OUTPUT-STREAM
[    package]: lisp
[    seealso]: two-way-stream-input-stream , two-way-stream-output-stream , make-echo-stream , xyzzyで提供されているストリームの種類
[       file]: builtin.l
[    section]: 入出力
[description]: 
入力をINPUT-STREAM、出力をOUTPUT-STREAMにする入出力ストリームを作成します。

参考：
        TWO WAY
          STREAM━┓    INPUT ━━┓
    ←─┨←───┨←─┨STREAM  ┃←─
        ┃        ┃    ┗━━━━┛
        ┃        ┃    OUTPUT━━┓
    ─→┠───→┠─→┃STREAM  ┠─→
        ┗━━━━┛    ┗━━━━┛


■make-variable-buffer-local
[       type]: Function
[  arguments]: make-variable-buffer-local SYMBOL
[    package]: editor
[    seealso]: make-local-variable
[   referred]: kill-local-variable
[       file]: builtin.l
[    section]: バッファ
[description]: 
SYMBOLを個々のバッファで独自の値を持てるようにローカル変数にします。
make-local-variableとは異なり、全てのバッファが対象です。
余程のことが無い限りdefvar-localを使えば良いと思います。


■make-vector
[       type]: Function
[  arguments]: make-vector LENGTH &key (:element-type t) (:initial-element () ies-p) (:initial-contents () ics-p) :fill-pointer :adjustable :displaced-to (:displaced-index-offset 0)
[    package]: lisp
[    seealso]: vector , make-array , copy-seq
[   referred]: make-sequence
[       file]: array.l
[    section]: 配列
[description]: 
指定した長さのベクタを返します。

使用例：
  ;;; 長さが10のベクタを作ります。
  (make-vector 10)
  => #(nil nil nil nil nil nil nil nil nil nil)

  ;;; :element-typeにcharacterを指定すると文字列が作成できる
  (make-vector 10 :element-type 'character)
  => "^@^@^@^@^@^@^@^@^@^@"


■makunbound
[       type]: Function
[  arguments]: makunbound SYMBOL
[    package]: lisp
[    seealso]: boundp
[   referred]: set
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
指定されたシンボルの値からの束縛を解消します。
これ以降boundpはnilを返すようになります。値と関数定義の束縛は独立してい
るので、makunboundをしてもfboundpの結果は変わりません。

使用例：
  ;;; 束縛を解消してみる。
  (set 'foo 2)          => 2
  (boundp 'foo)         => t
  (makunbound 'foo)     => foo
  (boundp 'foo)         => nil


■map
[       type]: Function
[  arguments]: map RESULT-TYPE FUNCTION SEQUENCE &rest MORE-SEQUENCES
[    package]: lisp
[    seealso]: map-into , make-sequence , mapcar
[       file]: sequence.l
[    section]: シーケンス
[description]: 
SEQUENCE に FUNCTION を適用して、RESULT-TYPE に応じたシーケンスを返します。
mapcar との違いは、リストだけでなく文字列や配列等のシーケンスにも適用できる
ことと、RESULT-TYPE の指定が必要なことです。

  RESULT-TYPE : nil、又は make-sequence の TYPE と同じものが使えます。
                nil の場合 戻り値は常に nil で、通常 副作用を目的として
                使用されます。
  FUNCTION    : mapcar と同様、SEQUENCE の各要素をひとつずつ取り出したも
                のとなります。 MORE-SEQUENCES がある場合もやはり mapcar 
                と同じように適用されます。

使用例:
  ;;; 文字列の場合は一つ一つの要素が string ではなく char になることに注意
  (map 'list #'char-code "abc")
  => (97 98 99)


■map-backslash-to-slash
[       type]: Function
[  arguments]: map-backslash-to-slash STRING
[    package]: editor
[    seealso]: map-slash-to-backslash
[       file]: builtin.l
[    section]: 文字列
[description]: 
文字列のバックスラッシュをスラッシュに置換して返します。

  STRING : 変換対象の文字列

使用例：
  ;;; パスを変換する。
  (map-backslash-to-slash "C:\\xyzzy\\xyzzy.exe")
  => "C:/xyzzy/xyzzy.exe"


■map-char-encoding-region
[       type]: Function
[  arguments]: map-char-encoding-region P1 P2 &optional ENCODING
[    package]: editor
[    seealso]: detect-char-encoding , map-char-encoding-selection , parse-char-encoding-region
[       file]: kanji.l
[    section]: テキスト
[description]: 
リージョンの文字列データを文字エンコーディングが ENCODING のデータとして、
xyzzy内部コードへ変換します。
ENCODING が指定されない時は自動判定します。


■map-into
[       type]: Function
[  arguments]: map-into RESULT-SEQUENCE FUNCTION &rest SEQUENCES
[    package]: lisp
[    seealso]: map
[       file]: sequence.l
[    section]: シーケンス
[description]: 
SEQUENCES に map と同じように FUNCTION を適用し、その結果を 
RESULT-SEQUENCE に埋め込みます。RESULT-SEQUENCE が一番短い SEQUENCE より
も長い場合には RESULT-SEQUENCE の後部の余った要素は変化しません。
  
使用例:
  (map-into "abcde" #'char-upcase "fgh")
  => "FGHde"
  (map-into '(1 2 3) #'- '(4 5 6 7 8))
  => (-4 -5 -6)


■map-slash-to-backslash
[       type]: Function
[  arguments]: map-slash-to-backslash STRING
[    package]: editor
[    seealso]: map-backslash-to-slash
[       file]: builtin.l
[    section]: 文字列
[description]: 
文字列のスラッシュをバックスラッシュに置換して返します。

  STRING : 変換対象の文字列

使用例：
  ;;; パスを変換する。
  (map-slash-to-backslash "C:/xyzzy/xyzzy.exe")
  => "C:\\xyzzy\\xyzzy.exe"


■mapc
[       type]: Function
[  arguments]: mapc FUNCTION LIST &rest MORE-LISTS
[    package]: lisp
[    seealso]: mapcar
[       file]: builtin.l
[    section]: 制御構造
[description]: 
引数の渡し方はmapcarとよく似ていますが、戻り値には与えられたリストをその
まま返します。


■mapcan
[       type]: Function
[  arguments]: mapcan FN LISTS &rest MORE-LISTS
[    package]: lisp
[    seealso]: mapcar , mapcon , nconc
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
引数の渡し方は mapcar によく似ていますが、関数 FN の呼び出し結果をくっつ
けたリストを返します。

  (mapcan f x1 ... xn) == (apply #'nconc (mapcar f x1 ... xn))

使用例：
  ;;; mapcanとmapcarとの違い
  (mapcan #'(lambda (x) (and (characterp x) (list (char-name x))))
          '(456 #\A 789 #\b #\c 123))
  => ("latin_capital_letter_a" "latin_small_letter_b" "latin_small_letter_c")
  (mapcar #'(lambda (x) (and (characterp x) (list (char-name x))))
          '(456 #\A 789 #\b #\c 123))
  => (nil ("latin_capital_letter_a") nil ("latin_small_letter_b") ("latin_small_letter_c") nil)


■mapcar
[       type]: Function
[  arguments]: mapcar FUNCTION LIST &rest MORE-LISTS
[    package]: lisp
[    seealso]: mapcan , mapcon , maplist , mapc , mapl , map
[       file]: builtin.l
[    section]: 制御構造
[description]: 
引数のリストから関数の戻り値のリストを作成して返します。
初回は各リストのcarを、二回目はcadrを、三回目はcaddrを関数に渡します。
リストが複数の場合が分かりにくいので図示します。

  ;;; リストが一つ      ┌──┐┌──┐┌──┐
  (mapcar #'char-name '(│ #\a││ #\b││ #\c│))
                        └─┬┘└─┬┘└─┬┘
                    ┌───┘      │      └───┐
                    ↓              ↓              ↓
  == (list (char-name #\a) (char-name #\b) (char-name #\c))
  == (list "latin_small_letter_a" "latin_small_letter_b" "latin_small_letter_c")
  => ("latin_small_letter_a" "latin_small_letter_b" "latin_small_letter_c")

  ;;; リストが複数   ┌─┐┌─┐┌─┐
  (mapcar #'+      '(│ 1││ 2││ 3│ 4)
                   '(│ 1││ 3││ 5│  )
                   '(│ 1││ 4││ 9│16)
                   '(│ 1││ 8││27│  )) 
                     └┬┘└┬┘└┬┘
             ┌────┘┌─┘    │   
             ↓          ↓        ↓         
  == (list (+ 1 1 1 1) (+ 2 3 4 8) (+ 3 5 9 27))
  == (list 4 17 44)
  => (4 17 44)

使用例：
  (mapcar #'+ '(1 2 3 4) 
              '(1 3 5) 
              '(1 4 9 16) 
              '(1 8 27)) 
  => (4 17 44)


■mapcon
[       type]: Function
[  arguments]: mapcon FN LISTS &rest MORE-LISTS
[    package]: lisp
[    seealso]: maplist , mapcan , nconc
[   referred]: mapcar
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
引数の渡し方は maplist によく似ていますが、関数 FN の呼び出し結果をくっ
つけたリストを返します。

  (mapcon f x1 ... xn) == (apply #'nconc (maplist f x1 ... xn))

使用例：
  (mapcon #'(lambda (x) (if (find 2 x) (list x))) '(1 a 2 b 3))
  => ((1 a 2 b 3) (a 2 b 3) (2 b 3))
  
  (mapcon #'(lambda (x) (if (find 2 x) x)) '(1 a 2 b 3)) ; 無限ループ?
  
  (mapcon #'(lambda (x) (if (find 2 x) (copy-list x))) '(1 a 2 b 3))
  => (1 a 2 b 3 a 2 b 3 2 b 3)


■maphash
[       type]: Function
[  arguments]: maphash FUNCTION HASH-TABLE
[    package]: lisp
[    seealso]: with-hash-table-iterator , gethash , make-hash-table
[       file]: hash.l
[    section]: ハッシュ
[description]: 
ハッシュテーブルの各要素を関数に渡します。

  FUNCTION   : キーと値を受け取る関数
  HASH-TABLE : ハッシュテーブルを指定します。

使用例：
  (setf hsh (make-hash-table))
  (setf (gethash #\a hsh) "Apple")  => "Apple"
  (setf (gethash #\b hsh) "Banana") => "Banana"
  (setf (gethash #\c hsh) "Cake")   => "Cake"
  (let ((alist nil))
    (maphash #'(lambda (x y) (pushnew (cons x y) alist)) hsh)
    alist)
  =>((#\c . "Cake") (#\b . "Banana") (#\a . "Apple"))


■mapl
[       type]: Function
[  arguments]: mapl FUNCTION LIST &rest MORE-LISTS
[    package]: lisp
[    seealso]: maplist
[   referred]: mapcar
[       file]: builtin.l
[    section]: 制御構造
[description]: 
引数の渡し方はmaplistとよく似ていますが、戻り値には与えられたリストをそ
のまま返します。


■maplist
[       type]: Function
[  arguments]: maplist FUNCTION LIST &rest MORE-LISTS
[    package]: lisp
[    seealso]: mapcar , mapcon
[   referred]: mapl
[       file]: builtin.l
[    section]: 制御構造
[description]: 
引数のリストから関数の戻り値のリストを作成して返します。
初回は各リストを、二回目はcdrを、三回目はcddrを関数に渡します。

使用例：
  (maplist #'(lambda (x) (cons 'foo x)) '(a b c d))
  => ((foo a . #1=(b . #2=(c . #3=(d)))) (foo . #1#) (foo . #2#) (foo . #3#))


■mark
[       type]: Function
[  arguments]: mark &optional FORCE
[    package]: editor
[    seealso]: marker-point , make-marker , set-mark , exchange-point-and-mark
[   referred]: region-beginning , region-end
[       file]: builtin.l
[    section]: ポジション
[description]: 
マークの位置を数値で返します。

  FORCE：マークが設定されていない場合に処理を継続するか？
        t       エラーとしない、関数はnilを返す
        nil     エラーとする


■mark-dialog-box
[       type]: Function
[  arguments]: mark-dialog-box
[    package]: editor
[       file]: gmark.l
[    section]: ダイアログ
[description]: 
マークダイアログを表示します。[C-F2]

マークダイアログからは、グローバルマークを設定することができ、複数のポイ
ント間を移動することができます。

  移動   : 選択したマークに移動します。
  追加   : マークを追加します。
  削除   : 選択したマークを削除します。
  全削除 : 全てのマークを削除します。


■mark-page
[       type]: Function
[  arguments]: mark-page &optional (ARG 0)
[    package]: editor
[    seealso]: forward-page , backward-page
[       file]: page.l
[    section]: ポジション
[description]: 
改ページで区切られた領域をリージョンに設定します。[C-x C-p]
改ページが無い場合、バッファ全体がリージョンになります。

  ARG : ページ位置を指定します。デフォルトは 0 です。


■mark-paragraph
[       type]: Function
[  arguments]: mark-paragraph
[    package]: editor
[       file]: paragrph.l
[    section]: リージョン
[description]: 
段落の末尾にマークを、先頭にポイントを設定します。[ESC h]


■mark-sexp
[       type]: Function
[  arguments]: mark-sexp &optional (ARG 1)
[    package]: editor
[    seealso]: set-mark-command
[       file]: sexp.l
[    section]: 関数
[description]: 
前方のS式の末尾にマークを設定します。[ESC NUL]


■mark-whole-buffer
[       type]: Function
[  arguments]: mark-whole-buffer &optional ARG
[    package]: editor
[       file]: cmds.l
[    section]: リージョン
[description]: 
バッファ全体をリージョンにします。

ARG が
  nil ならバッファの末尾にマークを設定し、バッファの先頭に移動
  non-nil ならバッファの先頭にマークを設定し、バッファの末尾に移動


■mark-word
[       type]: Function
[  arguments]: mark-word &optional (ARG 1)
[    package]: editor
[    seealso]: set-mark-command , forward-word
[       file]: cmds.l
[    section]: リージョン
[description]: 
カーソル位置前方の単語の末尾にマークを設定します。[ESC @]
カーソルが単語の途中にある場合は、その単語の末尾にマークを設定します。


■marker-buffer
[       type]: Function
[  arguments]: marker-buffer MARKER
[    package]: editor
[       file]: builtin.l
[    section]: ポジション
[description]: 
マーカーが設定されているバッファを返します。

使用例：
  (marker-buffer m)
  => #<buffer: *scratch*>


■marker-point
[       type]: Function
[  arguments]: marker-point MARKER
[    package]: editor
[    seealso]: mark , set-marker
[   referred]: command-output-send-input , make-marker
[       file]: builtin.l
[    section]: ポジション
[description]: 
マーカーの位置を数値で返します。
マーカーの位置が設定されていなかったり削除されていたりした場合は nil を返します。

使用例：
  (marker-point m)
  => 62


■markerp
[       type]: Function
[  arguments]: markerp OBJECT
[    package]: editor
[    seealso]: make-marker
[       file]: builtin.l
[    section]: データ型
[description]: 
指定されたOBJECTがマーカーかを返します。

  t     OBJECTはマーカー
  nil   OBJECTはマーカーではない


■mask-field
[       type]: Function
[  arguments]: mask-field BYTESPEC INTEGER
[    package]: lisp
[    seealso]: ldb
[       file]: number.l
[    section]: 数値
[description]: 
指定されたフィールド以外を 0 とした値を返します。

  ;; ldb との比較
  (format nil "~2,'0x" (ldb (byte 4 4) #xaf))
  =>"0a"
  (format nil "~2,'0x" (mask-field (byte 4 4) #xaf))
  =>"a0"


■match-beginning
[       type]: Function
[  arguments]: match-beginning REGNUM
[    package]: editor
[    seealso]: match-end , match-string
[   referred]: scan-buffer
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
正規表現を使った検索後に一致した先頭のポイントを取得できます。

  REGNUM : 取得したい文字列を指定
        0の場合         正規表現全体に一致する文字列を取得
        1-9の場合       正規表現中のREGNUM番目の括弧に対応した文字列を取得


■match-data
[       type]: Function
[  arguments]: match-data &optional DATA
[    package]: editor
[    seealso]: store-match-data , scan-buffer
[   referred]: match-string , replace-match
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
scan-buffer で検索時点の状態を保持します。複数の検索をした後で、元の
検索の結果で match-string / match-beginning / match-end / replace-match 
を行うことが可能です。

使用例：
  ;;; カーソルより後ろにabcdefと文字列があった場合
  ;;; 検索を2回してからその結果をそれぞれ取得する。
  (let (1st 2nd)
    ; 検索
    (scan-buffer "a\\(\\w*\\)" :regexp t)
    (setq 1st (match-data))
    (scan-buffer "abc\\(\\w*\\)" :regexp t)
    (setq 2nd (match-data))
    ; 結果参照
    (store-match-data 1st)
    (msgbox "~A" (match-string 1))
    (store-match-data 2nd)
    (msgbox "~A" (match-string 1)))


■match-end
[       type]: Function
[  arguments]: match-end REGNUM
[    package]: editor
[    seealso]: match-beginning , match-string
[   referred]: scan-buffer
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
正規表現を使った検索後に一致した最後のポイントを取得できます。

  REGNUM : 取得したい文字列を指定
        0の場合         正規表現全体に一致する文字列を取得
        1-9の場合       正規表現中のREGNUM番目の括弧に対応した文字列を取得


■match-string
[       type]: Function
[  arguments]: match-string REGNUM
[    package]: editor
[    seealso]: match-beginning , match-end , match-data , store-match-data , scan-buffer , 正規表現の表記
[   referred]: string-looking-at
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
正規表現を使った検索後に一致した文字列を取得することができます。
(buffer-substring (match-beginning REGNUM) (match-end REGNUM))に一致します。

  REGNUM : 取得したい文字列を指定
        0の場合         正規表現全体に一致する文字列を取得
        1-9の場合       正規表現中のREGNUM番目の括弧に対応した文字列を取得

使用例：
  ;;; 次に現れるLispのコメントを取得する。
  (progn
    (scan-buffer ";\\([^;\n]+\\)" :regexp t :no-dup nil)
    (match-string 1))


■max
[       type]: Function
[  arguments]: max NUMBER &rest MORE-NUMBERS
[    package]: lisp
[    seealso]: min
[       file]: builtin.l
[    section]: 数値
[description]: 
引数の中で最大の数値を返します。

使用例：  
  (max 3)
  => 3
  (max -3 0 2)
  => 2
  (max 2.5 1)
  => 2.5
  (max 3 2.5)
  => 3


■mc-autoload
[       type]: Function
[  arguments]: mc-autoload FN FILE &optional COMMANDP MACROP ENCODING
[    package]: lisp
[    seealso]: autoload , mc-load-library , mc-load-file
[       file]: misc.l
[    section]: 評価
[description]: 
Shift_JIS 以外のエンコーディングのファイルに定義された関数を autoload するよう設定します。

  FN       : 関数シンボル
  FILE     : 関数が定義されたファイル名
  COMMANDP : interactive 関数かどうか
  MACROP   : マクロかどうか
  ENCODING : FILE を読み込む際のエンコーディング


■mc-load-file
[       type]: Function
[  arguments]: mc-load-file FILENAME &optional ENCODING
[    package]: lisp
[    seealso]: load-file , mc-autoload , mc-load-library
[       file]: misc.l
[    section]: 評価
[description]: 
Shift_JIS 以外のエンコーディングのファイルを読み込みます。
mc-load-library と違い、*load-path* にないファイルも読み込めます。
  
  FILENAME : ファイル名（フルパス）
  ENCODING : 読み込むファイルのエンコーディング


■mc-load-library
[       type]: Function
[  arguments]: mc-load-library FILENAME &key :encoding :no-suffix (:if-does-not-exist :error)
[    package]: lisp
[    seealso]: load-library , mc-autoload , mc-load-file
[       file]: misc.l
[    section]: 評価
[description]: 
Shift_JIS 以外のエンコーディングのファイルを読み込みます。

  FILENAME           : ファイル名
  :encoding          : 読み込むファイルのエンコーディング
  :no-suffix         : ファイルを *load-path* から探すかどうか指定します。
        t                ファイルを find-load-path で探します。
        nil              FILENAME をそのまま使います。
  :if-does-not-exist : ファイルが見つからなかった場合の挙動を指定します。
        :error           エラーを返します。デフォルトの挙動です。
        それ以外         nil を返します。


■member
[       type]: Function
[  arguments]: member ITEM LIST &key :test :test-not :key
[    package]: lisp
[    seealso]: member-if , member-if-not , find , position , getf
[       file]: builtin.l
[    section]: リスト
[description]: 
LIST の中で ITEM との :test を満たすものがあれば一致したところからのリストを返します。
なければ nil を返します。

使用例：
  (member 'e '(a b c d))
  => nil
  (member 'b '(a b c d))
  => (b c d)


■member-if
[       type]: Function
[  arguments]: member-if PREDICATE LIST &key :key
[    package]: lisp
[    seealso]: member , member-if-not
[       file]: builtin.l
[    section]: リスト
[description]: 
LIST の中で条件 PREDICATE を満たすものがあれば、そこからのリストを返します。
なければ nil を返します。

使用例：
  (member-if #'numberp '(a b c))
  => nil
  (member-if #'numberp '(a b 3 c))
  => (3 c)


■member-if-not
[       type]: Function
[  arguments]: member-if-not PREDICATE LIST &key :key
[    package]: lisp
[    seealso]: member , member-if
[       file]: builtin.l
[    section]: リスト
[description]: 
LIST の中で条件 PREDICATE を満たさないものがあれば、そこからのリストを返します。
なければ nil を返します。

使用例：
  (member-if-not #'numberp '(1 2 3))
  => nil
  (member-if-not #'numberp '(1 2 a 3))
  => (a 3)


■menup
[       type]: Function
[  arguments]: menup OBJECT
[    package]: editor
[       file]: builtin.l
[    section]: メニュー
[description]: 
オブジェクトがメニューかどうかを返します。

  OBJECT : 判定するオブジェクト

  t   オブジェクトはメニュー
  nil オブジェクトはメニューではない


■merge
[       type]: Function
[  arguments]: merge RESULT-TYPE SEQUENCE1 SEQUENCE2 PREDICATE &key :key
[    package]: lisp
[    seealso]: union , concatenate , stable-sort
[       file]: sequence.l
[    section]: シーケンス
[description]: 
SEQUENCE1とSEQUENCE2を併合します。SEQUENCE1とSEQUENCE2は破壊されません。
PREDICATEによりSEQUENCE1とSEQUENCE2の値を比較し、非nilならば SEQUENCE1の値を 
nil ならば SEQUENCE2の値を順にマージしていきます。

  RESULT-TYPE : 結果となるシーケンスの型を指定します。
  PREDICATE   : シーケンス同士を比較する関数を指定します。
  :key        : 比較対照を取得する関数を指定します。

例
  (merge 'list '(1 2 3 5 8) '(2 4 6) #'<) => (1 2 2 3 4 5 6 8)
  (merge 'string "AbCF" "aBcd" #'char-lessp) => "AabBCcdF"


■merge-pathnames
[       type]: Function
[  arguments]: merge-pathnames PATHNAME &optional DEFAULTS
[    package]: lisp
[    seealso]: file-namestring , directory-namestring , namestring
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
パスとファイル名をくっつけます。

  PATHNAME : ファイル名の部分を指定します。
  DEFUALTS : パスの部分を指定します。
             指定しないと(default-directory)のパスが使用されます。

使用例：
  ;;; "c:/foo"と"bar.l"をくっつける。
  (merge-pathnames "bar.l" "c:/foo")
  => "c:/foo/bar.l"

  (merge-pathnames "bar.l" "c:/foo/") <--ディレクトリの末尾に/がつい
  => "c:/foo/bar.l"                      ているかとか気にしなくていい。


■message
[       type]: Function
[  arguments]: message FMT &rest ARGS
[    package]: lisp
[    seealso]: clear-message , msgbox , message-box , minibuffer-message , with-interval-message , format , *status-window* , status-window-stream-p
[       file]: misc.l
[    section]: 入出力
[description]: 
メッセージをステータスバーに出力します。

  FMT  : format同様の書式が指定できます。
  ARGS : 出力書式へのパラメタとなります。


■message-box
[       type]: Function
[  arguments]: message-box MESSAGE &optional TITLE STYLES &key :button1 :button2 :button3 :button4 :button5 :no-wrap
[    package]: editor
[    seealso]: yes-or-no-p , msgbox
[   referred]: message
[       file]: builtin.l
[    section]: ダイアログ
[description]: 
yes-or-no-p 系よりも柔軟なダイアログを表示します。

  MESSAGE  : ダイアログに表示するメッセージを指定します。
  TITLE    : ダイアログのタイトルを指定します。
  STYLES   : ダイアログのスタイルをリストで指定します。
        :ok                     [OK] を表示します。
        :ok-cancel              [OK][キャンセル] を表示します。
        :yes-no                 [はい][いいえ] を表示します。
        :yes-no-cancel          [はい][いいえ][キャンセル] を表示します。
        :abort-retry-ignore     [中止][再試行][無視] を表示します。
        :information            (i) インフォメーションマークを表示します。
        :exclamation            (!) 感嘆符を表示します。
        :question               (?) 疑問符を表示します。
        :button1                ボタン 1 をデフォルト選択にします。
        :button2                ボタン 2 をデフォルト選択にします。
        :button3                ボタン 3 をデフォルト選択にします。
        :button4                ボタン 4 をデフォルト選択にします。
        :button5                ボタン 5 をデフォルト選択にします。
  :BUTTON1 : ボタン 1 のテキストを変更します。
  :BUTTON2 : ボタン 2 のテキストを変更します。
  :BUTTON3 : ボタン 3 のテキストを変更します。
  :BUTTON4 : ボタン 4 のテキストを変更します。
  :BUTTON5 : ボタン 5 のテキストを変更します。
  :NO-WRAP : MESSAGE が長すぎるときに折り返すかを制御します。
        t       長くとも折り返さない。
        nil     長ければ折り返す。

ボタンを押したときの戻り値は、それぞれ以下のとおりです。

  :ok     [OK] を選択
  :cancel [キャンセル] を選択
  :yes    [はい] を選択
  :no     [いいえ] を選択
  :abort  [中止] を選択
  :retry  [再試行] を選択
  :ignore [無視] を選択

使用例：
  ;;; [はい][いいえ][キャンセル] を表示し選択させます。
  (message-box "メールを送信しますか?" nil
    '(:yes-no-cancel :question :button1))
  => :yes

  ;;; ダイアログの結果を case で場合わけしてみる
  (case (message-box "メールを送信しますか?" nil
                     '(:yes-no-cancel :question :button1))
    (:yes (den8-draft-send t))
    (:no t)
    (t nil))


■meta-prefix
[       type]: Function
[  arguments]: meta-prefix
[    package]: editor
[    seealso]: esc-map
[       file]: keymap.l
[    section]: キーマップ
[description]: 
ESC プレフィックスです。 [ESC]

meta-prefix の関数セルは普通のコマンドではなく esc-map というキーマッ
プを保持しています。


■min
[       type]: Function
[  arguments]: min NUMBER &rest MORE-NUMBERS
[    package]: lisp
[    seealso]: max
[       file]: builtin.l
[    section]: 数値
[description]: 
引数の中で最小の数値を返します。

使用例：
  (min 3)
  => 3
  (min -2 0 3)
  => -2
  (min 2.5 1)
  => 1


■minibuffer-message
[       type]: Function
[  arguments]: minibuffer-message FMT &rest ARGS
[    package]: editor
[    seealso]: clear-minibuffer-message , minibuffer-prompt , format
[   referred]: message
[       file]: misc.l
[    section]: ミニバッファ
[description]: 
書式に従ってミニバッファにメッセージを表示します。 
ミニバッファにカーソルが表示されない以外は minibuffer-prompt と同じ？

  FMT  : format 同様の書式
  ARGS : 出力書式へのパラメタ


■minibuffer-prompt
[       type]: Function
[  arguments]: minibuffer-prompt FMT &rest ARGS
[    package]: editor
[   referred]: clear-minibuffer-message , minibuffer-message
[       file]: misc.l
[    section]: ミニバッファ
[description]: 
書式に従ってミニバッファにメッセージを表示します。
その後read-charを使ってキーボードから文字を読み込めば、
凝ったミニバッファからの入力が可能になります。

  FMT  : format同様の書式が指定できます。
  ARGS : 出力書式へのパラメタとなります。

使用例：
  ;;; 以下のようにすると、パスワード入力のようにエコーバックしない。
  minibuffer入力が可能
  (defun test1 ()
    (interactive)
    (let ((ans ""))
      (loop
        (minibuffer-prompt "From ~d: " 12)
        (let ((c (read-char *keyboard*)))
          (case c
            (#\RET (return ans))
            (#\C-g (quit))
            (t (setq ans (format nil "~a~c" ans c))))))))  

参考：
  wip/ftp.lのgetpass


■minibuffer-window
[       type]: Function
[  arguments]: minibuffer-window
[    package]: editor
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
ミニバッファのウインドウを取得します。

使用例：
  ;;; ミニバッファに移動する。
  (set-window (minibuffer-window))


■minibuffer-window-p
[       type]: Function
[  arguments]: minibuffer-window-p WINDOW
[    package]: editor
[   referred]: delete-window
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
ウィンドウがミニバッファかどうかを返します。

  WINDOW：ミニバッファかどうかを調べるウィンドウ 

  t     ミニバッファである
  nil   ミニバッファではない

使用例：
  ;;; ミニバッファでは別のバッファに変更できないので別のウィンドウに移動する。
  (if (minibuffer-window-p (selected-window))
      (other-window))
  => t


■minor-mode-map
[       type]: Function
[  arguments]: minor-mode-map &optional BUFFER
[    package]: editor
[    seealso]: set-minor-mode-map
[       file]: builtin.l
[    section]: モード
[description]: 
set-minor-mode-mapで設定したキーマップを取得します。


■minusp
[       type]: Function
[  arguments]: minusp NUMBER
[    package]: lisp
[    seealso]: plusp
[       file]: builtin.l
[    section]: 数値
[description]: 
NUMBER がゼロより小さければ t 、そうでなければ nil を返します。

使用例：
  (minusp 0)
  => nil
  (minusp -1)
  => t
  (minusp -0.00001)
  => t


■mismatch
[       type]: Function
[  arguments]: mismatch SEQUENCE1 SEQUENCE2 &key :from-end :test :test-not (:key #'identity) (:start1 0) (:start2 0) :end1 :end2
[    package]: lisp
[       file]: sequence.l
[    section]: シーケンス
[description]: 
SEQUENCE1 と SEQUENCE2 を比較し、一致しない要素のインデックスを返します。

  :start1  SEQUENCE1 の比較開始位置
  :start2  SEQUENCE2 の比較開始位置
  :end1    SEQUENCE1 の比較終了位置
  :end2    SEQUENCE2 の比較終了位置

:start1 と :start2 の値が異なる場合、SEQUENCE1 内でのインデックスを返します。

使用例:
  (mismatch "abcd" "abxd")
  => 2

備考:
  :from-end は実装されていないようです。


■mod
[       type]: Function
[  arguments]: mod NUMBER DIVISOR
[    package]: lisp
[    seealso]: floor , rem
[       file]: builtin.l
[    section]: 数値
[description]: 
(floor NUMBER DIVISOR)の戻り値の二つ目を返します。

使用例：
  (mod 13 4)
  => 1
  (mod -13 4)
  => 3


■mode-line-format
[       type]: BufferLocal
[    package]: editor
[    seealso]: update-mode-line , title-bar-format
[    section]: ウィンドウ
[description]: 
モードラインのフォーマットを設定します。
タイトルバーのフォーマットと同様ですので、title-bar-formatを参照して下さい。


■mode-name
[       type]: BufferLocal
[    package]: editor
[    seealso]: buffer-mode
[    section]: 変数と定数
[description]: 
モードの名前を格納しているローカル変数です。
？mode-nameとbuffer-modeは必ずローカル変数になるのでしょうか？


■mode-specific-indent-command
[       type]: BufferLocal
[    package]: editor
[    seealso]: indent-region
[    section]: モード
[description]: 
indent-regionを参照のこと

使用例：
  ;;; 適当なモードで以下をevalしてみると、
  ;;; "ラベル:" のような行は行頭からになり、それ以外の行は8桁目からになる。
  (progn
    (make-local-variable 'mode-specific-indent-command)
    (setq mode-specific-indent-command
        #'(lambda () (save-excursion
                       (goto-bol)
                       (delete-horizontal-spaces)
                       (or (looking-at "^\\w+:") (indent-to 8))))))


■modify-text-attributes
[       type]: Function
[  arguments]: modify-text-attributes TAG &key :foreground :background :bold :underline :strike-out :prefix :extend :start :end :test :test-not :key
[    package]: editor
[    seealso]: set-text-attribute
[   referred]: find-text-attribute-point , modify-text-attributes-if , modify-text-attributes-if-not
[       file]: builtin.l
[    section]: テキスト
[description]: 
set-text-attribute で付けた領域の属性を変更します。
属性は引き継がれません。
例えば、set-text-attribute では :underline t としてから、
modify-text-attributes で :strike-out t としても、
下線と取り消し線の両方が表示される訳ではありません。

  TAG           set-text-attributeで指定したタグ
  :bold         ボールドで表示するかどうか
  :underline    下線付きで表示するかどうか
  :strike-out   取り消し線を表示するかどうか
  :foreground   文字色を整数で指定
  :background   背景色を整数で指定
  :prefix       使い方は不明
  :extend       行末の改行文字以降も変えるかどうか

使用例：
  ;;; バッファ全体をに下線を付けてから取り消し線にする。
  (set-text-attribute (point-min) (point-max) 'all :bold t :foreground 1)
  => t
  (modify-text-attributes 'all :strike-out t)
  => t
  (delete-text-attributes 'all)
  => t


■modify-text-attributes-if
[       type]: Function
[  arguments]: modify-text-attributes-if TEST &key :foreground :background :bold :underline :strike-out :prefix :extend :start :end :key
[    package]: editor
[    seealso]: modify-text-attributes-if-not , modify-text-attributes , set-text-attribute
[       file]: builtin.l
[    section]: テキスト
[description]: 
テキスト属性のうち、タグが TEST を満たすものすべてについて、属性を変更します。
属性は引き継がれません。
範囲を指定した場合、開始点が範囲に含まれるもののみ変更されます。

  :bold        ボールドで表示するかどうか
  :underline   下線付きで表示するかどうか
  :strike-out  取り消し線を表示するかどうか
  :foreground  文字色を整数で指定
  :background  背景色を整数で指定
  :prefix      行番号部分に表示する文字
  :extend      行末の改行文字以降も変えるかどうか
  :start       検索開始位置
  :end         検索終了位置
  :key         TEST に渡す前にタグに適用する関数


■modify-text-attributes-if-not
[       type]: Function
[  arguments]: modify-text-attributes-if-not TEST &key :foreground :background :bold :underline :strike-out :prefix :extend :start :end :key
[    package]: editor
[    seealso]: modify-text-attributes , modify-text-attributes-if
[       file]: builtin.l
[    section]: テキスト
[description]: 
テキスト属性のうち、タグが TEST を満たさないものすべてについて、属性を変更します。
属性は引き継がれません。
範囲を指定した場合、開始点が範囲に含まれるもののみ変更されます。

  :bold        ボールドで表示するかどうか
  :underline   下線付きで表示するかどうか
  :strike-out  取り消し線を表示するかどうか
  :foreground  文字色を整数で指定
  :background  背景色を整数で指定
  :prefix      行番号部分に表示する文字
  :extend      行末の改行文字以降も変えるかどうか
  :start       検索開始位置
  :end         検索終了位置
  :key         TEST に渡す前にタグに適用する関数


■mouse-menu-popup
[       type]: Function
[  arguments]: mouse-menu-popup &optional APPS
[    package]: editor
[   referred]: apps-popup
[       file]: mouse.l
[    section]: メニュー
[description]: 
ポップアップメニューを表示します。[RBtnUp]

  APPS  : メニューの表示位置を指定します。
     nil      マウスカーソル位置
     non-nil  カーソル位置


■msgbox
[       type]: Function
[  arguments]: msgbox FMT &rest ARGS
[    package]: editor
[    seealso]: message-box , format
[   referred]: message
[       file]: misc.l
[    section]: ダイアログ
[description]: 
メッセージボックスを表示します。
[OK] ボタンとインフォメーションアイコンが表示されます。

  FMT  : format の出力書式と同じものを指定できます。
  ARGS : 出力書式へのパラメタとなります。

戻り値は :ok となります。

使用例：
  ;;; 出力書式で整形してみる。
  (msgbox "このバッファは ~A です。" buffer-mode)
  => :ok


■multiple-value-bind
[       type]: Special Form
[  arguments]: multiple-value-bind ({VAR}*) VALUES-FORM {declaration}* {FORM}*
[    package]: lisp
[    seealso]: values , multiple-value-list , multiple-value-setq
[   referred]: multiple-value-call , multiple-value-prog1
[       link]: http://www.geocities.jp/m_hiroi/
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
フォームが返す多値を受け取ります。広井さんの"xyzzy Lisp Programming"の
解説が分かり易いので掲載の許可を頂きました。以下を参照して下さい。

--- 引用開始  ---
複数の値を受け取るには、マクロ multiple-value-bind を使うと簡単です。 

multiple-value-bind (&rest vars) values-form &rest form

multiple-value-bind は、多値を返す関数 values-form を評価し、その結果を 
vars で定義した変数にセットします。変数は局所変数として設定されるので、
multiple-value-bind を実行している間だけ有効です。簡単な例を示しましょう。
Common Lisp には、整数でない値を整数に変換する関数 floor, ceiling, 
truncate, round が定義されています。これらの関数は２つの値（多値）を返します。

  (truncate 10 3)
  => 3

  (multiple-value-bind
  (q r)
  (truncate 10 3)
  (format nil "商 ~D, 余り ~D~%" q r))
  => "商 3, 余り 1"

関数 truncate は割り算を行って商と余りを返します。ふつうに truncate を呼
び出すと商を返すだけですが、multiple-value-bind を使うと、商のほかに余り
も受け取ることができます。q と r は truncate が返す値を受け取る変数です。
次に、truncate を評価して結果を変数にセットします。あとは、残りの form 
を順番に評価していきます。 multiple-value-bind は最後に評価した form の
値を返します。

もしも、返される値よりも変数の個数が多い場合、残りの変数には nil がセッ
トされます。逆に、返される値が変数よりも多い場合、余分な値は捨てられます。
次の例を見てください。

  (multiple-value-bind (q)
  (truncate 10 3)
  (list q))
  => (3)
  
  (multiple-value-bind (q r s)
  (truncate 10 3)
  (list q r s))
  => (3 1 nil)

最初の例では、変数 q しか定義されていないので、 q には商がセットされます
が余りは捨てられます。次の例では、変数 s が定義されていますが、truncate 
は２つの値しか返さないので、 s には nil がセットされます。
--- 引用終了 ---


■multiple-value-call
[       type]: Special Form
[  arguments]: multiple-value-call FUNCTION {FORM}*
[    package]: lisp
[    seealso]: multiple-value-bind , apply , values
[   referred]: multiple-value-list
[       file]: builtin.l
[    section]: 制御構造
[description]: 
FORM の戻り値を引数として FUNCTION を呼びます。
apply と違って多値で返された二番目以降の戻り値も渡します。

使用例：
  (multiple-value-call #'+ (values 1 2 3) (values 4 5))
  => 15


■multiple-value-list
[       type]: Macro
[  arguments]: multiple-value-list FORM
[    package]: lisp
[    seealso]: values , multiple-value-call , multiple-value-bind , multiple-value-setq
[       file]: evalmacs.l
[    section]: 変数と定数
[description]: 
関数が返した多値をリストで返します。

使用例：
  (defun foo () (values 1 2 3))
  => foo
  (foo)
  => 1
     2
     3
  (multiple-value-list (foo))
  => (1 2 3)


■multiple-value-prog1
[       type]: Special Form
[  arguments]: multiple-value-prog1 FORM {FORM}*
[    package]: lisp
[    seealso]: prog1 , values , multiple-value-bind
[       file]: builtin.l
[    section]: 制御構造
[description]: 
フォームを順番に評価して最初のフォームの結果を多値で返します。

prog1 に似ていますが、最初のフォームが多値を返した場合でも prog1 の戻
り値は多値になりません。


■multiple-value-setq
[       type]: Special Form
[  arguments]: multiple-value-setq VARIABLES FORM
[    package]: lisp
[    seealso]: multiple-value-bind , multiple-value-list
[   referred]: values
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
返された多値を個々の変数に設定します。
変数の個数よりもフォームが返した値の数が多いときには余った分は捨てられま
す。少ない場合には、足りない分だけnilが設定されます。

  VARIABLES : 変数のリスト
  FORM      : 評価するフォーム

使用例：
  ;;; valuesで多値を返した場合
  (setq a (values 1 2)) => 1
  a                     => 1
  (multiple-value-setq (a b) (values 1 2))
                        => 1
  a                     => 1
  b                     => 2


■namestring
[       type]: Function
[  arguments]: namestring PATHNAME
[    package]: lisp
[    seealso]: file-namestring , merge-pathnames
[       file]: builtin.l
[    section]: 文字列
[description]: 
PATHNAMEの内容に応じて適切なフルパスを返すような動きをする。与えたのがフ
ルパスでなければ、先頭に(default-directory)を補ってフルパスらしくします。
使用例：
  (default-directory)
  =>"C:/Applications/xyzzy/"

  (namestring "abc.txt")
  =>"C:/Applications/xyzzy/abc.txt"

  (namestring "Z:/zzz.txt")
  =>"Z:/zzz.txt"


■narrow-to-region
[       type]: Function
[  arguments]: narrow-to-region FROM TO
[    package]: editor
[    seealso]: hide-restricted-region , save-restriction , widen , point-min , point-max
[       file]: builtin.l
[    section]: ポジション
[description]: 
指定した範囲以外を移動・編集できないようにします。[C-x n]
save-restrictionのブロックが終了するか、widenすると元に戻ります。
point-min, point-maxの値も変わります。

使用例：
  C-SPCでマークを付けて、どっかに移動して、C-x n(narrow-to-region)とする
  と、指定したリージョンの外には移動できなくなります。私は置換のときに置き
  換える範囲を制限したり、キーボードマクロの範囲を制限したりするのによく使
  います。あとは、Lispコードの中で特定の範囲だけいじるときなんかにも使いま
  す。


■nbutlast
[       type]: Function
[  arguments]: nbutlast LIST &optional (N 1)
[    package]: lisp
[    seealso]: butlast
[       file]: list.l
[    section]: リスト
[description]: 
リストの最後のN要素分を除いたリストを返します。
引数 LIST は破壊されます。

使用例：
  ;;; 最後の要素を取り除きます。
  (setq foo '(1 2 3))
  => (1 2 3)
  (nbutlast foo)
  => (1 2)
  foo
  => (1 2)


■nconc
[       type]: Function
[  arguments]: nconc &rest LISTS
[    package]: lisp
[    seealso]: append
[   referred]: mapcan , mapcon
[       file]: builtin.l
[    section]: リスト
[description]: 
複数のリストを引数にとってそれらを結合したリストを返します。
引数は破壊されます。

使用例：
  ;;; リストをくっつけてみる。
  (setq x '(a b c))
  (setq y '(d e f))
  (nconc x y)
  => (a b c d e f) 
  x
  => (a b c d e f)
  y
  => (d e f)


■need-buffer-save-p
[       type]: Function
[  arguments]: need-buffer-save-p BUFFER
[    package]: editor
[    seealso]: need-not-save
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファが保存が必要かを返します。
need-not-saveと関連しています。

  t     バッファの保存が必要
  nil   バッファの保存が必要ではない


■need-not-save
[       type]: BufferLocal
[    package]: editor
[    seealso]: need-buffer-save-p , setup-temp-buffer
[    section]: 変数と定数
[description]: 
保存する必要があるかどうかを設定します。
個々のバッファ毎や特定のモードだけしたくないのであれば、使用例の様にロー
カル変数にします。例えば、*scratch*の様に書き捨てたりするバッファでは、
保存の必要はないので、tになっています。

  t     保存の必要はない
  nil   保存する

使用例：
  ;;; 現在のバッファは保存の必要はなし。
  (make-local-variable 'need-not-save)
  => t
  (setq need-not-save t)
  => t


■negative-argument
[       type]: Function
[  arguments]: negative-argument RAW &optional ARG
[    package]: editor
[    seealso]: universal-argument , digit-argument
[       file]: cmds.l
[    section]: 関数
[description]: 
後に続くコマンドに負の前置引数を渡します。[ESC -]


■new-file
[       type]: Function
[  arguments]: new-file
[    package]: editor
[    seealso]: get-buffer-create , create-new-buffer
[       file]: files.l
[    section]: ファイルシステム
[description]: 
ファイルに関連付けられていない新しいバッファ *untitled* を作ります。


■new-pseudo-frame
[       type]: Function
[  arguments]: new-pseudo-frame NAME &optional SAVE-P SELECTED-FN DELETED-FN
[    package]: editor
[    seealso]: select-pseudo-frame , delete-pseudo-frame , *select-pseudo-frame-hook*
[   referred]: ed::pseudo-frame
[       file]: pframe.l
[    section]: ウィンドウ
[description]: 
新しいフレームを作って返します。[C-x 6 2]

  NAME        : フレームの名前
  SAVE-P      : セッション保存時にこのフレームを保存するかどうか
  SELECTED-FN : このフレームを選択した時に実行される関数
  DELETED-FN  : このフレームを削除した時に実行される関数

フレームは構造体として定義されており、これらの引数はそれぞれ
同名のスロットに設定されます。

インタラクティブに呼んだ場合 NAME は自動的に割り振られ、SAVE-P は t に設定されます。
前置引数をつけて呼べば NAME を対話的に入力できます。


■newline
[       type]: Function
[  arguments]: newline &optional (ARG 1)
[    package]: editor
[    seealso]: newline-and-indent
[       file]: cmds.l
[    section]: テキスト
[description]: 
改行を挿入します。[RET], [C-m]


■newline-and-indent
[       type]: Function
[  arguments]: newline-and-indent &optional (ARG 1)
[    package]: editor
[    seealso]: newline , indent-relative
[   referred]: delete-indentation
[       file]: cmds.l
[    section]: ポジション
[description]: 
改行後、文字が存在する直前の行と同じ桁数だけインデントをします。
モードに依存したインデントコマンドは使用しません。[LFD], [C-j]


■next-buffer
[       type]: Function
[  arguments]: next-buffer
[    package]: editor
[    seealso]: previous-buffer , *next-buffer-in-tab-order* , other-buffer
[   referred]: get-next-buffer
[       file]: buffer.l
[    section]: バッファ
[description]: 
次のバッファに切替えます。 [Home]
エディタ上で現在選択されているウィンドウの中のバッファが変わるだけです。

バッファタブの順番にそってnext-bufferしたいのならば、
*next-buffer-in-tab-order*を参照して下さい。


■next-error
[       type]: Function
[  arguments]: next-error &optional ARG
[    package]: editor
[    seealso]: *error-regexp-list* , first-error
[       file]: errors.l
[    section]: エラー
[description]: 
次のエラーの該当行にジャンプします。[F11], [C-x `]


■next-line
[       type]: Function
[  arguments]: next-line &optional (N 1)
[    package]: editor
[    seealso]: next-virtual-line , previous-line , forward-line , goal-column
[   referred]: next-line-add-newlines
[       file]: cmds.l
[    section]: ポジション
[description]: 
N行後の物理行に移動します。 
移動の前後で goal-column を保存します。

戻り値:
  1行でも移動できたときは t 、それ以外は nil です。


■next-line-add-newlines
[       type]: Variable
[    package]: editor
[    seealso]: next-line
[    section]: ポジション
[description]: 
バッファの最後尾でnext-line系の移動をしたときの動作を設定します。

  t   空行を挿入します
  nil 何もしません

使用例：
  (setq next-line-add-newlines t)


■next-page
[       type]: Function
[  arguments]: next-page &optional (ARG 1)
[    package]: editor
[    seealso]: previous-page , *page-scroll-half-window* , *page-scroll-keep-window-position* , *next-screen-context-lines*
[       file]: page.l
[    section]: ウィンドウ
[description]: 
指定ページ分画面を下スクロールします。[C-v], [PageDown]
*page-scroll-half-window* が non nil なら半画面ずつスクロールします。


■next-pseudo-frame
[       type]: Function
[  arguments]: next-pseudo-frame
[    package]: editor
[    seealso]: previous-pseudo-frame , other-pseudo-frame , switch-pseudo-frame
[    section]: ウィンドウ
[description]: 
other-pseudo-frame の別名です。


■next-virtual-line
[       type]: Function
[  arguments]: next-virtual-line &optional (N 1)
[    package]: editor
[    seealso]: next-line
[       file]: cmds.l
[    section]: ポジション
[description]: 
N行後の表示行に移動します。 [C-n], [Down]
  t    最終行以外の場合
  nil  最終行の場合


■next-window
[       type]: Function
[  arguments]: next-window WINDOW &optional MINIBUF
[    package]: editor
[    seealso]: previous-window , set-window
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
WINDOW の次のウィンドウを返します。

  MINIBUF : ミニバッファウィンドウを候補に入れるか
       nil    無視する
   non-nil    候補に入れる


■next-word
[       type]: Function
[  arguments]: next-word &optional (ARG 1)
[    package]: editor
[    seealso]: forward-word
[       file]: cmds.l
[    section]: ポジション
[description]: 
カーソルを前方の単語の先頭に移動します。


■next-xyzzy-window
[       type]: Function
[  arguments]: next-xyzzy-window
[    package]: editor
[    seealso]: previous-xyzzy-window , list-xyzzy-windows
[       file]: builtin.l
[    section]: プロセス
[description]: 
次のxyzzyに移動します。
移動順は起動した順です。


■nil
[       type]: Variable
[    package]: lisp
[    seealso]: t
[    section]: 変数と定数
[description]: 
偽を表す定数です。


■nintersection
[       type]: Function
[  arguments]: nintersection LIST1 LIST2 &rest REST &key :test :test-not :key
[    package]: lisp
[    seealso]: intersection
[       file]: list.l
[    section]: リスト
[description]: 
LIST1 と LIST2 の両方に含まれる要素のリストを作って返します。
intersection と違い引数 LIST1 は破壊されます。

使用例:
  (setq x '(1 3 5 7 9))
  => (1 3 5 7 9)
  (setq y '(2 3 5 7 11))
  => (2 3 5 7 11)
  (nintersection x y)
  => (3 5 7)
  x
  => (1 3 5 7)
  y
  => (2 3 5 7 11)


■ninth
[       type]: Function
[  arguments]: ninth X
[    package]: lisp
[    seealso]: nth
[       file]: list.l
[    section]: リスト
[description]: 
list の 9 番目の要素を返します。

  (ninth X) = (nth 8 X)

使用例：
  (ninth '(1 2 3 4 5 6 7 8 9 0))
  => 9


■no-or-yes-p
[       type]: Function
[  arguments]: no-or-yes-p FMT &rest ARGS
[    package]: lisp
[    seealso]: yes-or-no-p , y-or-n-p , yes-no-or-cancel-p
[       file]: misc.l
[    section]: ダイアログ
[description]: 
「はい」「いいえ」のボタン付メッセージボックスを表示します。
デフォルトは「いいえ」です。

  t     「はい」を選択
  nil   「いいえ」を選択

使用例：
  ;;; ダイアログを表示して選択させる。
  (no-or-yes-p "foo")
  => t          ; 「はい」を選択


■not
[       type]: Function
[  arguments]: not X
[    package]: lisp
[    seealso]: null
[   referred]: complement
[       file]: evalmacs.l
[    section]: その他
[description]: 
否定を返します。
non nilならばnilを返し、nilならばtを返します。機能としてはnullと同じです。


■not-modified
[       type]: Function
[  arguments]: not-modified
[    package]: editor
[    seealso]: set-buffer-modified-p
[       file]: buffer.l
[    section]: バッファ
[description]: 
バッファの変更フラグをクリアします。[ESC ~]
つまり変更されてないことになります。
(set-buffer-modified-p nil)のinteractive版です。


■notany
[       type]: Function
[  arguments]: notany PREDICATE SEQUENCE &rest MORE-SEQUENCES
[    package]: lisp
[    seealso]: notevery , some
[       file]: sequence.l
[    section]: シーケンス
[description]: 
SEQUENCEの先頭の要素から順番にPREDICATEを適用していき、PREDICATEが
非nilな値を返すと、 nil をすぐに返します。
PREDICATEを満たす要素が見つからない時は t を返します。

MORE-SEQUNCESが与えられた時、SEQUENCEの中で最も短いものの終わりまで実行されます。


■notevery
[       type]: Function
[  arguments]: notevery PREDICATE SEQUENCE &rest MORE-SEQUENCES
[    package]: lisp
[    seealso]: notany , every
[       file]: sequence.l
[    section]: シーケンス
[description]: 
SEQUENCEの先頭の要素から順番にPREDICATEを適用していき、PREDICATEが
nil を返すと、t をすぐに返します。
全ての要素がPREDICATEを満たす場合、 nil を返します。

MORE-SEQUNCESが与えられた時、SEQUENCEの中で最も短いものの終わりまで実行されます。


■nreconc
[       type]: Function
[  arguments]: nreconc X Y
[    package]: lisp
[    seealso]: revappend
[       file]: builtin.l
[    section]: リスト
[description]: 
X を反転させて Y を結合したリストを返します。
引数 X は破壊されます。

  (nreconc x y) == (nconc (nreverse x) y)

nreconcの方が効率が良いようです。


■nreverse
[       type]: Function
[  arguments]: nreverse SEQUENCE
[    package]: lisp
[    seealso]: reverse
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCE を逆順にした新しいシーケンスを作成して返します。
引数 SEQUENCE は破壊されます。

使用例：
  (setq lst '(a b c))
  => (a b c)
  (nreverse lst)
  => (c b a)
  lst
  => (a)


■nset-difference
[       type]: Function
[  arguments]: nset-difference LIST1 LIST2 &rest REST &key :test :test-not :key
[    package]: lisp
[    seealso]: set-difference
[       file]: list.l
[    section]: リスト
[description]: 
LIST1 から LIST2 にも含まれる要素を除き、そのリストを返します。
set-difference と違い引数 LIST1 は破壊されます。

使用例:
  (setq x '(1 3 5 7 9))
  => (1 3 5 7 9)
  (setq y '(2 3 7))
  => (2 3 7)
  (nset-difference x y)
  => (1 5 9)
  x
  => (1 5 9)


■nset-exclusive-or
[       type]: Function
[  arguments]: nset-exclusive-or LIST1 LIST2 &rest REST &key :test :test-not :key
[    package]: lisp
[    seealso]: set-exclusive-or
[       file]: list.l
[    section]: リスト
[description]: 
LIST1 と LIST2 のいずれか一方にのみ含まれる要素のリストを作って返します。
set-exclusive-or と違い引数 LIST2 は破壊されます。

使用例:
  (setq x '(1 3 5 7 9))
  => (1 3 5 7 9)
  (setq y '(2 3 5 7 11))
  => (2 3 5 7 11)
  (nset-exclusive-or x y)
  => (9 1 2 11)
  x
  => (1 3 5 7 9)
  y
  => (2 11)


■nstring-capitalize
[       type]: Function
[  arguments]: nstring-capitalize STRING &key :start :end
[    package]: lisp
[    seealso]: string-capitalize
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING の内部の単語の先頭を大文字に、それ以外を小文字にした文字列を返します。
引数 STRING は破壊されます。

使用例：  
  (setq foo "tHis iS a pEn.")
  => "tHis iS a pEn."
  (nstring-capitalize foo)
  => "This Is A Pen."
  foo
  => "This Is A Pen."


■nstring-downcase
[       type]: Function
[  arguments]: nstring-downcase STRING &key :start :end
[    package]: lisp
[    seealso]: string-downcase
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING を小文字にした文字列を返します。引数 STRING は破壊されます。

使用例：  
  (setq foo "XyZzY")
  => "XyZzY"
  (nstring-downcase foo)
  => "xyzzy"
  foo
  => "xyzzy"  


■nstring-upcase
[       type]: Function
[  arguments]: nstring-upcase STRING &key :start :end
[    package]: lisp
[    seealso]: string-upcase
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING を大文字にした文字列を返します。引数 STRING は破壊されます。

使用例：
  (setq foo "xyzzy")
  => "xyzzy"
  (nstring-upcase foo)
  => "XYZZY"
  foo
  => "XYZZY"


■nsublis
[       type]: Function
[  arguments]: nsublis ALIST TREE &key :test :test-not :key
[    package]: lisp
[    seealso]: sublis , nsubst
[       file]: builtin.l
[    section]: リスト
[description]: 
TREE の中で ALIST の :key との :test を満たすものを VALUE に置き換えたリストを返します。
引数 TREE は破壊されます。

使用例：
  ;;; fooの変換テーブルの内容に基づいてbarを変換します。
  (setq foo '((1 . #\a) (2 . #\b) (3 . #\c)))
  => ((1 . #\a) (2 . #\b) (3 . #\c))
  (setq bar '(1 (2 3) ((4 5 6) (7 8 9))))
  => (1 (2 3) ((4 5 6) (7 8 9)))
  (nsublis foo bar)
  => (#\a (#\b #\c) ((4 5 6) (7 8 9)))
  bar
  => (#\a (#\b #\c) ((4 5 6) (7 8 9)))


■nsubst
[       type]: Function
[  arguments]: nsubst NEW OLD TREE &key :test :test-not :key
[    package]: lisp
[    seealso]: subst , nsublis , nsubst-if , nsubst-if-not , nsubstitute
[       file]: builtin.l
[    section]: リスト
[description]: 
TREE の中で OLD を NEW に置き換えたTREEを返します。
引数 TREE は破壊されます。

使用例：
  ;;; 階層のあるツリーをnsubstしてみる。aは破壊される。
  (setq a '((1 2) ((1 3) (1 4))))       => ((1 2) ((1 3) (1 4)))
  (nsubst 5 1 a)                        => ((5 2) ((5 3) (5 4)))
  a                                     => ((5 2) ((5 3) (5 4)))


■nsubst-if
[       type]: Function
[  arguments]: nsubst-if NEW TEST TREE &key :key
[    package]: lisp
[    seealso]: subst-if , nsubst-if-not , nsubst , nsubstitute-if
[       file]: builtin.l
[    section]: リスト
[description]: 
TREEの中でTESTを満たすものがあればNEWに置き換えたものを返します。
TREEが破壊される点を除いてsubst-ifと同じです。

  NEW  : 置き換える要素
  TEST : 置き換えるかどうかを判定するテスト
         non-nilを返したら置き換えます。
  TREE : 対象のツリー

TESTの引数についてはsubst-ifを参照して下さい。

使用例：
  ;;; 適当なツリーを用意して、その要素が奇数ならば0に置き換える。
  (setq a '((1 2) ((1 3) (1 (1 3)))))
  => ((1 2) ((1 3) (1 (1 3))))
  (nsubst-if 0 #'(lambda (x) (and (integerp x) (oddp x))) a)
  => ((0 2) ((0 0) (0 (0 0))))
  a
  => ((0 2) ((0 0) (0 (0 0))))


■nsubst-if-not
[       type]: Function
[  arguments]: nsubst-if-not NEW TEST TREE &key :key
[    package]: lisp
[    seealso]: subst-if , nsubst-if , nsubst , nsubstitute-if-not
[       file]: builtin.l
[    section]: リスト
[description]: 
TREEの中でTESTを満たさないものがあればNEWに置き換えたものを返します。
TREEが破壊される点を除いてsubst-if-notと同じです。

  NEW  : 置き換える要素
  TEST : 置き換えるかどうかを判定するテスト
         nilを返したら置き換えます。
  TREE : 対象のツリー

TESTの引数についてはsubst-ifを参照して下さい。

使用例：
  ;;; 適当なツリーを用意して、数字以外のものがあれば0に変換する。
  (setq a '((123 "abc") '(456 "123") (789 #\a)))
  => ((123 "abc") '(456 "123") (789 #\a))
  (nsubst-if-not 0 #'(lambda (x) (or (listp x) (integerp x))) a)
  => ((123 0) (0 (456 0)) (789 0))
  a
  => ((123 0) (0 (456 0)) (789 0))


■nsubstitute
[       type]: Function
[  arguments]: nsubstitute NEWITEM OLDITEM SEQUENCE &key :from-end :test :test-not :start :end :count :key
[    package]: lisp
[    seealso]: nsubst , nsubstitute , nsubstitute-if , nsubstitute-if-not , substitute , nsbulis
[   referred]: sublis
[       file]: sequence.l
[    section]: シーケンス
[description]: 
SEQUENCE に対して OLDITEM との :test を満足する要素を NEWITEM に置き換えたシーケンスを返します。
引数 SEQUENCE は破壊されます。

  :test     : テストを行う2項演算子
  :start    : 開始位置。デフォルトは0で非負の整数
  :end      : 終了位置。デフォルトはnilで、nilの場合はSEQUENCEの長さを指定した
              場合と等しい動作。
  :count    : 置き換える最大の回数。
  :from-end : nil ならば先頭から、non-nil で末尾から置換を行う。 :count
              が与えられた時のみ意味を持つ。


■nsubstitute-if
[       type]: Function
[  arguments]: nsubstitute-if NEWITEM TEST SEQUENCE &key :from-end :start :end :count :key
[    package]: lisp
[    seealso]: nsubst-if , nsubstitute , nsubstitute-if-not , substitute-if
[       file]: sequence.l
[    section]: シーケンス
[description]: 
SEQUENCEに対してTESTを満足する要素をNEWITEMに置き換えたシーケンスを返します。
引数 SEQUENCE は破壊されます。

  TEST      : テストを行う単項演算子
  :start    : 開始位置。デフォルトは0で非負の整数
  :end      : 終了位置。デフォルトはnilで、nilの場合はSEQUENCEの長さを指定した
              場合と等しい動作。
  :count    : 置き換える最大の回数。
  :from-end : nil ならば先頭から、 non-nil で末尾から置換を行う。 :count
              が与えられた時のみ意味を持つ。


■nsubstitute-if-not
[       type]: Function
[  arguments]: nsubstitute-if-not NEWITEM TEST SEQUENCE &key :from-end :start :end :count :key
[    package]: lisp
[    seealso]: nsubst-if-not , nsubstitute , nsubstitute-if , substitute-if-not
[       file]: sequence.l
[    section]: シーケンス
[description]: 
SEQUENCEに対してTESTを満足しない要素をNEWITEMに置き換えたシーケンスを返します。
引数 SEQUENCE は破壊されます。

  TEST      : テストを行う単項演算子
  :start    : 開始位置。デフォルトは0で非負の整数
  :end      : 終了位置。デフォルトはnilで、nilの場合はSEQUENCEの長さを指定した
              場合と等しい動作。
  :count    : 置き換える最大の回数。
  :from-end : nil ならば先頭から、 non-nil で末尾から置換を行う。 :count
              が与えられた時のみ意味を持つ。


■nth
[       type]: Function
[  arguments]: nth N LIST
[    package]: lisp
[    seealso]: nthcdr , elt , first , second , third , fourth , fifth , sixth , seventh , eighth , ninth , tenth
[       file]: builtin.l
[    section]: リスト
[description]: 
リストの N 番目の要素を返します。

  N    : リストのインデックスを指定します。0を基底とします。
  LIST : 要素を返すリストです。

N がリストの長さを越えていれば nil を返します。 N が負数であればエラーを
返します。

  (nth n x) == (car (nthcdr n x))

使用例：
  (nth 2 '(1 2 3 4))
  => 3
  (nth 10 '(1 2 3 4))
  => nil
  (nth -3 '(1 2 3 4))
  => 範囲外の値です: -3


■nthcdr
[       type]: Function
[  arguments]: nthcdr N LIST
[    package]: lisp
[    seealso]: nth
[       file]: builtin.l
[    section]: リスト
[description]: 
リストの N 番目の cdr を返します。

  N    : リストのインデックスを指定します。0を基底とします。
  LIST : 要素を返すリストです。

N がリストの長さを越えていれば nil を返します。 N が負数であればエラーを
返します。

使用例：
  (nthcdr 1 '(1 2 3 4))
  => (2 3 4)
  (nthcdr 10 '(1 2 3 4))
  => nil
  (nthcdr -3 '(1 2 3 4))
  => 範囲外の値です: -3


■null
[       type]: Function
[  arguments]: null OBJECT
[    package]: lisp
[    seealso]: not , endp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTが()ならば t 、それ以外なら nil を返します。

  (null x) == (typep x 'null) == (eq x '())


■number-of-function-bar-labels
[       type]: Function
[  arguments]: number-of-function-bar-labels
[    package]: editor
[    seealso]: set-number-of-function-bar-labels
[       file]: builtin.l
[    section]: その他
[description]: 
ファンクションバーのラベルの数を返します。非表示の場合でも数値を返します。


■numberp
[       type]: Function
[  arguments]: numberp OBJECT
[    package]: lisp
[    seealso]: integerp , floatp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTが数値ならばt、それ以外ならnilを返します。

  (numberp x) == (typep x 'number)


■numerator
[       type]: Function
[  arguments]: numerator RATIONAL
[    package]: lisp
[    seealso]: denominator , /
[       file]: builtin.l
[    section]: 数値
[description]: 
分数の分子を返します。


■nunion
[       type]: Function
[  arguments]: nunion LIST1 LIST2 &rest REST &key :test :test-not :key
[    package]: lisp
[    seealso]: union
[       file]: list.l
[    section]: リスト
[description]: 
LIST1 と LIST2 を併せたリストを作って返します。
union と違い LIST1 は破壊されます。

使用例:
  (setq x '(1 3 5 7 9))
  => (1 3 5 7 9)
  (setq y '(2 3 5 7 11))
  => (2 3 5 7 11)
  (nunion x y)
  => (1 9 2 3 5 7 11)
  x
  => (1 9 2 3 5 7 11)
  y
  => (2 3 5 7 11)


■oddp
[       type]: Function
[  arguments]: oddp INTEGER
[    package]: lisp
[    seealso]: evenp
[       file]: builtin.l
[    section]: 数値
[description]: 
INTEGERが奇数ならばt、そうでなければnilを返します。

使用例：  
  (oddp 1)
  => t
  (oddp 0)
  => nil
  (oddp -35)
  => t


■open
[       type]: Function
[  arguments]: open FILENAME &key :direction :if-exists :if-does-not-exist :encoding :share
[    package]: lisp
[    seealso]: close , clear-input , xyzzyで提供されているストリームの種類 , with-open-file , with-open-stream
[       file]: builtin.l
[    section]: 入出力
[description]: 
ファイルへのストリームを作成して返します。ストリームのクローズには close 
を使いますが、 with-open-stream を使えば close の手間が省ける上に安全です。

  FILENAME           : ストリームを作成するファイル名を指定します。
  :direction         : ストリームの入出力の方向を指定します。
        :input          入力（省略時）
        :output         出力
        :io             入出力
        :probe          ファイルテスト？
                        戻り値のストリームは無効になっています。
  :if-exists         : ファイルが存在する場合の動作を指定します。
        :error          エラーを出力します。（省略時）
        :skip           エラーは出力せず、nilを返します。
        :append         既存ファイルに追加します。
                        ストリームの位置はファイル終端になります。
        :overwrite      上書きします。
        :new-version    ファイルを作成します。
                        既にあれば上書きされます。
        ---- 以下詳細不明 ----
        :supersede      更新？
        :rename         リネーム用にストリームを開く？
        :rename-and-delete  リネーム用にストリームを開く？
  :if-does-not-exist : ファイルが存在しない場合の動作を指定します。
        :error          エラーを出力します。（省略時）
        :create         エラーは出力せず、入力ファイルを作成します。
  :encoding          : エンコーディングのモードを指定します。
        :binary         バイナリモードです。
        :text           テキストモードです。（省略時は:text）
        :canonical      :text と同じ意味になります。
        :raw            改行コードの扱いが、LF のみになります。
                        それ以外は :text と同じです。
  :share             : ファイルの共有モードを指定します。
        省略時　　　　　:direction が :input または :probe なら :read に、
                        それ以外は共有不可になります。
        :read           読み取りの共有が可能になります。
        :write          書き込みの共有が可能になります。
        :read-write     読み書きの共有が可能になります。

使用例：
  ;;; ストリーム経由でファイルに書き出してみる。
  (setq foo (open "abc.txt" :direction :output))
  => #<file-output stream: C:/applications/xyzzy/abc.txt>
  (princ "test" foo)
  => "test"
  (close foo)
  => t


■open-filer
[       type]: Function
[  arguments]: open-filer
[    package]: editor
[    seealso]: filer
[       file]: filer.l
[    section]: ファイラ
[description]: 
ファイラを開きます。[C-c C-f]
filerのinteractive版です。


■open-line
[       type]: Function
[  arguments]: open-line &optional (ARG 1)
[    package]: editor
[    seealso]: split-line
[       file]: cmds.l
[    section]: テキスト
[description]: 
カーソル位置を変えないで改行を挿入します。[C-o]


■open-network-stream
[       type]: Function
[  arguments]: open-network-stream BUFFER HOSTNAME SERVICE &key :incode :outcode :eol-code
[    package]: editor
[    seealso]: connect , make-process
[       file]: builtin.l
[    section]: プロセス
[description]: 
ホストのポートとのTCP接続を開きます。
成功すれば接続をBUFFERのサブプロセスとして返します。

使用例：
  ;;; http://www.yahoo.co.jp/を取得してみる。
  (progn
    (defun filter (proc in) (insert in))
    (setq proc (open-network-stream (selected-buffer) "www.yahoo.co.jp" 80))
    (process-send-string proc "GET / HTTP/1.0\n\n")
    (set-process-filter proc 'filter))
  => HTTP/1.1 200 OK
     Server: ...


■open-rectangle
[       type]: Function
[  arguments]: open-rectangle P1 P2
[    package]: editor
[    seealso]: clear-rectangle , open-rectangle-selection , operate-on-rectangle
[       file]: rectangl.l
[    section]: リージョン
[description]: 
P1 と P2 で指定される矩形領域に #\SPC を挿入します。


■open-rectangle-selection
[       type]: Function
[  arguments]: open-rectangle-selection
[    package]: editor
[    seealso]: clear-rectangle-selection , open-rectangle , operate-on-rectangle-selection
[       file]: select.l
[    section]: リージョン
[description]: 
矩形選択されたセレクションの領域に #\SPC を挿入します。


■open-session-dialog
[       type]: Function
[  arguments]: open-session-dialog
[    package]: editor
[    seealso]: load-session
[       file]: session.l
[    section]: バッファ
[description]: 
ダイアログからセッションファイル名を指定してセッションを開きます。
[C-x 6 F]


■open-stream-p
[       type]: Function
[  arguments]: streamp OBJECT
[    package]: lisp
[    seealso]: streamp
[       file]: builtin.l
[    section]: 入出力
[description]: 
OBJECTが開いたストリームか否かを返します。
  t    OBJECTは開いたストリームです。
  nil  OBJECTはストリームでないか、閉じています。


■operate-on-rectangle
[       type]: Function
[  arguments]: operate-on-rectangle P1 P2 C1 C2 &key :copy :delete :clear :open :string
[    package]: editor
[    seealso]: operate-on-rectangle-selection
[   referred]: clear-rectangle , delete-rectangle , open-rectangle , string-rectangle
[       file]: rectangl.l
[    section]: リージョン
[description]: 
P1 と P2 で指定されるリージョン中の、 C1 と C2 で定まる矩形領域に対し
てキーワードで指定された操作を行います。

  :copy     コピーする
  :delete   削除する
  :clear    #\SPC で上書き
  :open     #\SPC を挿入
  :string   削除して各行に STRING を挿入

C1, C2 には nil を指定することもできます。この場合、リージョンの開始位
置と終了位置の表示桁が使われます。

-rectangle 系のコマンドの多くはこれを用いて実装されています。


矩形についての補足：
  例えば次の図で / がリージョンの場合 * の部分が操作の対象となります。
         C1             C2                     C1             C2
  -------│-------------│--------      -------│-------------│--------
  -------│------/////////////////      -------│------*******│--------
  ////////////////////////////////      -------│*************│--------
  ////////////////////////////////      -------│*************│--------
  ////////////////////////////////      -------│*************│--------
  /////////////////////////-------      -------│*************│--------
  -------│-------------│--------      -------│-------------│--------
  
  C1, C2 を明示的に指定することはあまりなく、次のいずれかの形になる場合がほとんどでしょう。
  --------------------      --------------------
  ------------////////      ------********//////
  /////*******////////      //////********//////
  /////*******////////      //////********//////
  /////*******////////      //////********//////
  /////*******////////      //////********//////
  /////---------------      //////********------
  --------------------      --------------------


■operate-on-rectangle-selection
[       type]: Function
[  arguments]: operate-on-rectangle-selection &key :copy :delete :clear :open :string
[    package]: editor
[    seealso]: operate-on-rectangle , copy-rectangle-selection , kill-rectangle-selection , delete-rectangle-selection , clear-rectangle-selection , open-rectangle-selection , string-rectangle-selection , *dont-clear-selection*
[       file]: select.l
[    section]: リージョン
[description]: 
矩形選択されたセレクションの領域に対してキーワードで指定された操作を行
います。

  :copy     コピーする
  :delete   削除する
  :clear    #\SPC で上書き
  :open     #\SPC を挿入
  :string   削除して各行に STRING を挿入


■or
[       type]: Macro
[  arguments]: or &rest FORMS
[    package]: lisp
[    seealso]: and
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
フォームがnilの間だけ順番に評価します。
フォームが一つでもnon-nilならば、そこで評価を中断してフォームの値を返し
て終了します。全てのフォームがnilならば、nilを返します。

  ;;; exp1 がnilならexp2を実行し、
  ;;; exp2 がnilならexp3を実行し、
  ;;; exp3 がnilなら......
  ;;; 最後に実行したexpの値を返す。
  (or exp1 exp2 exp3 ...)

ルールに従って一つだけ値を定める場合に向いていると思います。

  (or (get-buffer-file-name) ; バッファにファイル名があればそれを使う。
      *foo*                  ; ファイル名がなければ、変数*foo*の値を使う。
      (read-string "foo: ")) ; *foo*にも値が無ければ入力してもらう。


■os-build-number
[       type]: Function
[  arguments]: os-build-number
[    package]: editor
[       file]: builtin.l
[    section]: システム
[description]: 
Windows NT 4.00.13811 + Service Pack 3 の場合

使用例：  
  (os-build-number)
  => 1381


■os-csd-version
[       type]: Function
[  arguments]: os-csd-version
[    package]: editor
[       file]: builtin.l
[    section]: システム
[description]: 
Windows NT 4.00.1381 + Service Pack 3 の場合

使用例：
  (os-csd-version)
  => "Service Pack 3"


■os-major-version
[       type]: Function
[  arguments]: os-major-version
[    package]: editor
[    seealso]: machine-name
[       file]: builtin.l
[    section]: システム
[description]: 
OSのメジャーバージョンを返します。

使用例：
  (os-major-version)
  => 4


■os-minor-version
[       type]: Function
[  arguments]: os-minor-version
[    package]: editor
[    seealso]: machine-name
[       file]: builtin.l
[    section]: システム
[description]: 
OSのマイナーバージョンを返します。

使用例：
  (os-minor-version)
  => 0


■os-platform
[       type]: Function
[  arguments]: os-platform
[    package]: editor
[    seealso]: machine-name , si:getenv
[       file]: builtin.l
[    section]: システム
[description]: 
OSの種類を返します。OSが95とNTで動作を変えたいときなどに使います。返され
る値は文字列ではなくシンボルです。

参考：
  OS            シンボル
  ----          ----
  Windows???    win32s
  Windows95     windows-95
  Windows98     windows-98
  WindowsMe     windows-me
  WindowsNT     windows-nt
  Windows2000   windows-2000
  WindowsXP     windows-xp

使用例：
  (os-platform)
  => windows-nt


■other-buffer
[       type]: Function
[  arguments]: other-buffer &optional BUFFER
[    package]: editor
[    seealso]: bury-buffer , next-buffer
[       file]: builtin.l
[    section]: バッファ
[description]: 
最近、表示されていたバッファを返します。


■other-pseudo-frame
[       type]: Function
[  arguments]: other-pseudo-frame
[    package]: editor
[    seealso]: previous-pseudo-frame , next-pseudo-frame , switch-pseudo-frame
[       file]: pframe.l
[    section]: ウィンドウ
[description]: 
次のフレームに移動します。[C-x 6 o]


■other-window
[       type]: Function
[  arguments]: other-window &optional (ARG 1 F) NO-ERROR
[    package]: editor
[    seealso]: move-previous-window , selected-window , count-windows
[       file]: window.l
[    section]: ウィンドウ
[description]: 
分割されたウィンドウの中を移動します。[C-x o]

  ARG      : ARG番目のウィンドウに移動します。
             負数であれば、ARG番前のウィンドウに移動します。
  NO-ERROR : (count-windows)以上の数値を指定した場合の動作を制御します。
        nil     (count-windows)以上の数値を指定するとエラーを発生します。
        t       (count-windows)以上の数値を指定してもtを返す。


■overwrite-char
[       type]: Function
[  arguments]: overwrite-char C &optional (ARG 1)
[    package]: editor
[       file]: cmds.l
[    section]: テキスト
[description]: 
文字を上書きします。

使用例：
  ;;; 半角空白で上書きする。
  (overwrite-char #\SPC)
  => t


■overwrite-mode
[       type]: Function
[  arguments]: overwrite-mode &optional (ARG () SV)
[    package]: editor
[    seealso]: toggle-over
[       file]: cmds.l
[    section]: モード
[description]: 
上書き用マイナーモードを制御します。 toggle-over と同じです。


■overwrite-rectangle
[       type]: Function
[  arguments]: overwrite-rectangle
[    package]: editor
[       file]: rectangl.l
[    section]: リージョン
[description]: 
コピーしている矩形を貼り付けます。既存のテキストに上書きされます。


■package-name
[       type]: Function
[  arguments]: package-name PACKAGE
[    package]: lisp
[    seealso]: package-nicknames , find-package
[   referred]: defpackage
[       file]: builtin.l
[    section]: パッケージ
[description]: 
パッケージの名称を取得します。

使用例：
  (package-name (find-package "ed"))
  => "editor"


■package-use-list
[       type]: Function
[  arguments]: package-use-list PACKAGE
[    package]: lisp
[    seealso]: package-used-by-list , use-package
[       file]: builtin.l
[    section]: パッケージ
[description]: 
指定されたパッケージが使用しているパッケージを返します

  PACKAGE : パッケージそのものもしくはパッケージ名の文字列

使用例：
  (package-use-list "user")
  =>(#<package: lisp> #<package: editor>)


■package-used-by-list
[       type]: Function
[  arguments]: package-used-by-list PACKAGE
[    package]: lisp
[    seealso]: use-package , package-use-list
[       file]: builtin.l
[    section]: パッケージ
[description]: 
指定されたパッケージが使用されているパッケージを返します

  PACKAGE : パッケージそのものもしくはパッケージ名の文字列

使用例:
  (package-used-by-list (find-package "lisp"))
  =>(#<package: system> #<package: editor> #<package: user>)


■packagep
[       type]: Function
[  arguments]: packagep OBJECT
[    package]: lisp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTがpackageならt、それ以外ならnilを返します。

使用例：
  ;;; 指定された文字列のパッケージがあるかを調べる。
  (setq pkg (find-package "win32"))     => nil
  (packagep pkg)                        => nil
  (setq pkg (find-package "winapi"))    => #<package: winapi>
  (packagep pkg)                        => t


■pairlis
[       type]: Function
[  arguments]: pairlis KEYS DATA &optional A-LIST
[    package]: lisp
[       file]: builtin.l
[    section]: リスト
[description]: 
二つのリスト KEYS と DATA から要素を一つずつ組み合わせた連想リストを作って返します。
A-LIST が与えられればそれに加えて返します。

  '(1 2 3 4 5) ─┬→ '((5 . e) (4 . d) (3 . c) (2 . b) (1 . a))
  '(a b c d e) ─┘

使用例：
  (pairlis '(one two) '(1 2) '((three . 3)))
  => ((two . 2) (one . 1) (three . 3))


■parse-integer
[       type]: Function
[  arguments]: parse-integer STRING &key :start :end :radix :junk-allowed
[    package]: lisp
[   referred]: read-from-string
[       file]: builtin.l
[    section]: 入出力
[description]: 
文字列から整数を読み取ります。
C言語のatoiに相当します。

  STRING  : 対象の文字列
  :start  : 読み取り開始位置
  :end    : 読み取り終了位置
  :radix  : 基数
  :junk-allowed
          : non-nilなら前後の空白を無視します

多値で二つの値を返します。
一つ目は読み込んだ整数値です。読み込めなかった場合はnilを返します。
二つ目は読んだ最後の文字の次の文字のインデックスです。文字列の最後まで読
んだ場合は文字列の長さになります。

例:
  (parse-integer "16")
  =>16
  =>2
  (parse-integer "016")
  =>16
  =>3
  (parse-integer " 16 ")
  =>不正な数値の形式です: " 16 "
  (parse-integer " 16 " :junk-allowed t)
  =>16
  =>3

備考:
  Common Lispの同名の関数と動作が異なります。
  Common Lispのparse-integerは:junk-allowedがnilでも前後の空白を無視し、
  non-nilのときは前後の空白のみならず数字以外の文字も無視します。


■parse-point-syntax
[       type]: Function
[  arguments]: parse-point-syntax &optional POINT
[    package]: editor
[    seealso]: syntax-table , html-highlight-mode , set-syntax-string , set-syntax-comment-column , set-syntax-start-c++-comment , set-syntax-end-c++-comment , set-syntax-start-comment , set-syntax-end-comment , set-syntax-start-multi-comment , set-syntax-end-multi-comment , set-syntax-start-column-comment , set-syntax-tag
[       file]: builtin.l
[    section]: シンタックス
[description]: 
指定された位置のシンタックスを返します。

  :string  set-syntax-string で指定されたキャラクタに囲まれた領域           
  :comment set-syntax-comment-column
           set-syntax-start-c++-comment
           set-syntax-end-c++-comment
           set-syntax-start-comment
           set-syntax-end-comment
           set-syntax-start-multi-comment
           set-syntax-end-multi-comment
           set-syntax-start-column-comment
           で指定された領域
  :tag     set-syntax-tag で指定されたキャラクタに囲まれた領域
           (ただし html-highlight-mode がnon-nilのときのみ)
  nil      上記以外の領域


■paste-from-clipboard
[       type]: Function
[  arguments]: paste-from-clipboard
[    package]: editor
[    seealso]: paste-rectangle-from-clipboard , si:*paste-hook*
[   referred]: copy-to-clipboard
[       file]: select.l
[    section]: リージョン
[description]: 
クリップボードの内容を貼り付けます。[S-Insert]


■paste-rectangle-from-clipboard
[       type]: Function
[  arguments]: paste-rectangle-from-clipboard
[    package]: editor
[    seealso]: paste-from-clipboard
[   referred]: copy-to-clipboard
[       file]: select.l
[    section]: リージョン
[description]: 
paste-from-clipboardとは異なり、クリップボードの内容を矩形で貼り付けます。
[S-C-Insert]


■path-equal
[       type]: Function
[  arguments]: path-equal PATHNAME1 PATHNAME2
[    package]: lisp
[    seealso]: sub-directory-p
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
PATHNAME1とPATHNAME2が同じパスを指していればt、そうでなければnilを返します。

使用例：
  (path-equal "C:/Windows/" "c:/windows")
  => t


■pathname-device
[       type]: Function
[  arguments]: pathname-device PATHNAME
[    package]: lisp
[    seealso]: pathname-type , pathname-name , pathname-directory , pathname-host
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
PATHNAMEのドライブ名を返します。
使用例：
  (setq a "//SAMURAI/Applications/xyzzy/xyzzy.exe")
  => "//SAMURAI/Applications/xyzzy/xyzzy.exe"

  (pathname-device a)
  => nil

  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  => "C:/Applications/xyzzy/xyzzy.exe"

  (pathname-device a)
  "C"


■pathname-directory
[       type]: Function
[  arguments]: pathname-directory PATHNAME
[    package]: lisp
[    seealso]: pathname-type , pathname-name , pathname-device , pathname-host , directory-namestring
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
PATHNAMEのディレクトリ名を返します。各階層ごとの名前を要素とするリスト形
式で返されます。
使用例：
  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =>"C:/Applications/xyzzy/xyzzy.exe"

  (pathname-directory a)
  =>("Applications" "xyzzy")


■pathname-host
[       type]: Function
[  arguments]: pathname-host PATHNAME
[    package]: lisp
[    seealso]: pathname-type , pathname-name , pathname-directory , pathname-device
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
PATHNAMEのホスト名を返します。
使用例：
  (setq a "//SAMURAI/Applications/xyzzy/xyzzy.exe")
  =>"//SAMURAI/Applications/xyzzy/xyzzy.exe"

  (pathname-host a)
  =>"SAMURAI"

  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =>"C:/Applications/xyzzy/xyzzy.exe"

  (pathname-host a)
  =>nil


■pathname-match-p
[       type]: Function
[  arguments]: pathname-match-p PATHNAME WILDNAME
[    package]: lisp
[    seealso]: wild-pathname-p , *brackets-is-wildcard-character*
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
PATHNAME が WILDNAME で指定されたワイルドカードにマッチするかどうかを
返します。

  PATHNAME : 検査対象のパス文字列
  WILDNAME : ワイルドカード文字列
             先頭文字が | の場合は否定の意味となる。
             *brackets-is-wildcard-character* の値が non-nil の場合は
             文字列中の [...] をワイルドカードと見なす。

戻り値：
  t    PATHNAME が WILDNAME にマッチする。
  nil  PATHNAME が WILDNAME にマッチしない。

使用例：
  (setq p (merge-pathnames "xyzzy.exe" (si:system-root)))
  =>"C:/Applications/xyzzy/xyzzy.exe"

  (setq w (merge-pathnames "xyzzy.*" (si:system-root)))
  =>"C:/Applications/xyzzy/xyzzy.*"

  (wild-pathname-p p)
  =>nil

  (wild-pathname-p w)
  =>t

  (pathname-match-p p w)
  =>t

  (pathname-match-p p (concat "|" w))
  =>nil

  (setq w "*/xyzzy.ini")
  =>"*/xyzzy.ini"

  (pathname-match-p p w)
  =>nil

  (pathname-match-p p (concat "|" w))
  =>t


■pathname-name
[       type]: Function
[  arguments]: pathname-name PATHNAME
[    package]: lisp
[    seealso]: pathname-type , pathname-directory , pathname-device , pathname-host , file-namestring
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
PATHNAMEのファイル名（拡張子無し）を返します。
使用例：
  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =>"C:/Applications/xyzzy/xyzzy.exe"

  (pathname-name a)
  =>"xyzzy"


■pathname-type
[       type]: Function
[  arguments]: pathname-type PATHNAME
[    package]: lisp
[    seealso]: pathname-name , file-namestring
[   referred]: pathname-device , pathname-directory , pathname-host
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
ファイル名の拡張子を取り出します。拡張子がなければnilを返します。

  PATHNAME : 拡張子を取り出すファイル名を指定します。

使用例：
  ;;; foo.lzh
  (pathname-type "foo.lzh")
  =>"lzh"
  (pathname-type "foo/bar/zzz.txt")
  =>"txt"


■peek-char
[       type]: Function
[  arguments]: peek-char &optional PEEK-TYPE INPUT-STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P
[    package]: lisp
[    seealso]: read-char
[       file]: builtin.l
[    section]: 入出力
[description]: 
ストリームから文字を覗き見ます。read-charしてunread-charするようなもんです。

  PEEK_TYPE      : 覗き見る文字の種類を指定します。
        nil        全ての種類の文字を受け付けます。
        文字       指定された文字とEOFのみを受け付けます。
        上記以外   空白以外を受け付けます。
                   空白には 水平タブ 改行 垂直タブ 改ページ 行頭復帰 スペース が該当します。
                   キーでは TAB C-i LFD C-j RET C-m SPC が該当します。
  INPUT-STREAM   : 入力元のストリームを指定します。
  EOF-ERROR-P    : EOFをエラーとするかどうかを指定します。
        t          エラーとします。
        nil        エラーとせず、nilを返します。
  EOF-VALUE      : EOFのときにnilの代わりに返す文字を指定します。
  RECURSIVE-P    : 結果に影響しません。

戻り値は文字です。

使用例：
  ;;; 標準入力の文字を除き見る。
  (peek-char nil *standard-input* nil nil)


■perform-replace
[       type]: Function
[  arguments]: perform-replace PATTERN REPLACEMENT QUERY REGEXP INTERACTIVE-P NOERROR
[    package]: editor
[    seealso]: replace-buffer , replace-string , substitute-string
[   referred]: scan-buffer
[       file]: search.l
[    section]: 検索・正規表現
[description]: 
バッファを検索して文字列を置換します。特に判断がいらないのならば
scan-bufferするよりも簡単です。replace-bufferを使って実装されています。
  
  PATTERN       : 置換前文字列です。
  REPLACEMENT   : 置換後文字列です。\1, \2 ... \9も使用できます。
  QUERY         : 確認あり？
  REGEXP        : 正規表現？
  INTERACTIVE-P : 対話的かどうか？
                  undoの記録の仕方と、メッセージの出し方が違うだけ
  NOERROR       : 文字列が見つからないときエラーを出す？

互換性：
  muleにはなさそう。


■phase
[       type]: Function
[  arguments]: phase Z
[    package]: lisp
[       file]: number.l
[    section]: 数値
[description]: 
複素数の偏角を求めます。
戻り値はラジアン単位です。

  (phase -1)
  =>3.141593


■pipe-command
[       type]: Function
[  arguments]: pipe-command CMD
[    package]: editor
[    seealso]: execute-shell-command
[       file]: process.l
[    section]: プロセス
[description]: 
CMD を実行し、プロセスの終了を待って標準出力を *Shell output* バッファ
に出力します。[C-x @]


■plain-error
[       type]: Function
[  arguments]: plain-error &rest REST
[    package]: lisp
[       file]: misc.l
[    section]: エラー
[description]: 
（詳細不明）


■plusp
[       type]: Function
[  arguments]: plusp NUMBER
[    package]: lisp
[    seealso]: minusp
[       file]: builtin.l
[    section]: 数値
[description]: 
NUMBERがゼロより大きければt、そうでなければnilを返します。

使用例：
  (plusp 0)
  => nil
  (plusp 1)
  => t
  (plusp 0.00001)
  => t


■point
[       type]: Function
[  arguments]: point
[    package]: editor
[   referred]: region-beginning , region-end , what-cursor-position
[       file]: builtin.l
[    section]: ポジション
[description]: 
この関数は、ポイントの位置を integer として返します。 
goto-char でその位置に飛ぶことが出来ます。バッファの先頭ではpoint-minに
等しく、バッファの最後ではpoint-maxに等しいです。

使用例：
  (point)
  => 175


■point-marker
[       type]: Function
[  arguments]: point-marker
[    package]: editor
[    seealso]: set-marker
[   referred]: make-marker
[       file]: cmds.l
[    section]: ポジション
[description]: 
新しいマーカーを作成し、現在のカーソル位置にセットして返します。


■point-max
[       type]: Function
[  arguments]: point-max
[    package]: editor
[    seealso]: point-min , narrow-to-region
[   referred]: goto-char
[       file]: builtin.l
[    section]: ポジション
[description]: 
カレントバッファの一番大きなポイント値を返します。narrow-to-region等で、
clipping 制限が用いられてない限り、カレントバッファの大きさになります。 

使用例：
  (point-max)
  => 189568


■point-min
[       type]: Function
[  arguments]: point-min
[    package]: editor
[    seealso]: point-max , narrow-to-region
[   referred]: goto-char
[       file]: builtin.l
[    section]: ポジション
[description]: 
カレントバッファの一番小さなポイント値を返します。narrow-to-region等で、
clipping 制限が用いられてない限り 0 になります。 

使用例：
  (point-min)
  => 0


■point-to-register
[       type]: Function
[  arguments]: point-to-register R
[    package]: editor
[    seealso]: jump-to-register
[       file]: register.l
[    section]: ポジション
[description]: 
新しいマーカーを作って現在位置にセットし、レジスタ R に格納します。
[C-x r SPC]


■pop
[       type]: Macro
[  arguments]: pop PLACE
[    package]: lisp
[       file]: setf.l
[    section]: リスト
[description]: 
リストの先頭要素を取り除きます。取り除いた要素を返します。

  PLACE : setfに適用できるものでなければなりません。

使用例：
  (setq x '(a (b c d) e f))     => (a (b c d) e f)
  (pop (cdr (second x)))        => c
  x                             => (a (b d) e f)

互換性：
  Common Lispとxyzzyにあり。
  muleはなさそう。


■pop-to-buffer
[       type]: Function
[  arguments]: pop-to-buffer BUFFER &optional POPUP-WINDOWS VERT-P
[    package]: editor
[    seealso]: split-window , split-window-vertically
[       file]: window.l
[    section]: ウィンドウ
[description]: 
指定されたバッファを表示します。POPUP-WINDOWS が指定された場合画面を分割
してバッファを表示します。ウィンドウが既に分割されていたら、新たに分割せ
ずにそのウィンドウに移動し表示します。

表示幅が指定された場合には、縦分割が指定されていない場合、モード行を表示
している状態で、およそ指定された数値分の行数が表示できる大きさのウィンド
ウができます。
縦分割が指定された場合には、上下ではなく左右に分割し、行番号を表示してい
ない状態で、およそ指定された数値分の列数が表示できる大きさのウインドウが
できます。

  BUFFER        : バッファ、または、バッファの名前を指定します。
  POPUP-WINDOWS : 分割する行数／列数を指定します。
        t             ニ分割します。
        整数          指定行数／列数で分割します。
        nil           ウィンドウが分割されていない場合でも新たに
                      分割しません。
  VERT-P        : 縦方向に分割します。
        non-nil       左右にニ分割します。
        nil           上下にニ分割します。

使用例：
  ;;; den8の場合
  (defvar *den8-summary-window-ratio* 1/4)

  (defun den8-viewer ()
    (let ((view (switch-to-buffer "*Den8 View*")))     ; Viewを作る
      (let ((sum (switch-to-buffer "*Den8 Summary*"))) ; Summaryを作る
           <初期化・省略> ))
    (delete-other-windows)        ; 自分以外の全部のウインドウを消す
    (den8-popup-summary-buffer))  ; ２分割して、上下にサマリと内容を表示

  (defun den8-popup-summary-buffer ()
    (pop-to-buffer den8-summary-buffer
       (truncate (* (screen-height) *den8-summary-window-ratio*))))


■popup-list
[       type]: Function
[  arguments]: popup-list LIST CALLBACK &optional POINT
[    package]: editor
[    seealso]: dabbrev-popup , popup-string
[       file]: builtin.l
[    section]: その他
[description]: 
ポップアップリストを表示します。選択された項目を引数にコールバッ
ク関数が呼び出されます。

使用例：
  (defun func ()
    (popup-list
       '("123" "abc" "xyz")
       #'(lambda (x) (msgbox "\"~A\" selected" x))))
  => func


■popup-string
[       type]: Function
[  arguments]: popup-string STRING POINT &optional TIMEOUT
[    package]: editor
[    seealso]: popup-list , continue-popup , track-popup-menu
[       file]: builtin.l
[    section]: その他
[description]: 
文字列をポップアップさせます。ツールチップのポップみたいな表示です。

  STRING  : ポップアップさせる文字列を指定します。
  POINT   : 文字列を表示する位置をポイントで指定します。
  TIMEOUT : 表示を止めるまでの秒数を指定します。


■pos-not-visible-in-window-p
[       type]: Function
[  arguments]: pos-not-visible-in-window-p POINT &optional WINDOW
[    package]: editor
[    seealso]: pos-visible-in-window-p
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
指定されたポイントPOINTがウィンドウの表示範囲内にないかを返します。

  t     表示範囲内にない。
  nil   表示範囲内にある。


■pos-visible-in-window-p
[       type]: Function
[  arguments]: pos-visible-in-window-p POINT &optional WINDOW
[    package]: editor
[    seealso]: pos-not-visible-in-window-p
[       file]: window.l
[    section]: ウィンドウ
[description]: 
ポイントがウィンドウの表示範囲内にあるかを返します。

  t     表示範囲内にある。
  nil   表示範囲内にない。


■position
[       type]: Function
[  arguments]: position ITEM SEQUENCE &key :from-end :test :test-not :start :end :key
[    package]: lisp
[    seealso]: position-if , position-if-not , find , member
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCE の中で ITEM との :test を満たすものがあればそのインデックスを返します。
なければ nil を返します。

使用例：
  ;;; リストの中から'aのインデックスを調べる
  (position 'a '(e c a b))
  => 2


■position-if
[       type]: Function
[  arguments]: position-if PREDICATE SEQUENCE &key :from-end :start :end :key
[    package]: lisp
[    seealso]: position , position-if-not
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCEの中でPREDICATEを満たすものがあればそのインデックスを返します。
なければnilを返します。


■position-if-not
[       type]: Function
[  arguments]: position-if-not PREDICATE SEQUENCE &key :from-end :start :end :key
[    package]: lisp
[    seealso]: position , position-if
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCEの中でPREDICATEを満たさないものがあればそのインデックスを返します。
なければnilを返します。


■post-buffer-modified-hook
[       type]: Variable
[    package]: editor
[    seealso]: enable-post-buffer-modified-hook , post-buffer-modified-hook-enabled-p
[    section]: 変数と定数
[description]: 
バッファが修正されたときに実行されます。

設定された関数は以下の5引数で呼び出されます。
  BUFFER    : 修正されたバッファ
  OPERATION : 修正された操作の種類
               :insert  文字の挿入
               :delete  文字の削除
               :modify  修正(downcase-wordなど)
  FROM      : 開始位置のポイント
  TO        : 終了位置のポイント
              OPERATIONが:deleteの場合はFROMとTOは同じ値になります。
  UNDO-P    : 修正された状況
               undo     undo
               redo     redo
               nil      その他

注意：
  enable-post-buffer-modified-hookでフックを有効にしないと実行されません。
  対話的でなくても実行されます。
  同じバッファに修正を行うとread-only-bufferエラーになります。
  なんらかのエラーが発生するとフックが無効になります。
  ウィンドウ・バッファを削除したり、
  戻るときにウィンドウ・バッファが切り替わってたりすると、
  きっと良くないことが起こるので、あまり無茶なことはしない方が無難です。

使用例：
  (enable-post-buffer-modified-hook t)
  (defun buffer-modified-hook (buffer operation from to undo-p)
    (message "ope:~A  undo:~A from:~d to:~d" operation undo-p from to))
  (add-hook 'post-buffer-modified-hook 'buffer-modified-hook)


■post-buffer-modified-hook-enabled-p
[       type]: Function
[  arguments]: post-buffer-modified-hook-enabled-p &optional BUFFER
[    package]: editor
[    seealso]: enable-post-buffer-modified-hook , post-buffer-modified-hook
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
バッファでpost-buffer-modified-hookが有効かを判定します。
[xyzzy:06354]を参照
xyzzy 0.2.1.186〜 


■pre-selection-p
[       type]: Function
[  arguments]: pre-selection-p
[    package]: editor
[    seealso]: selection-point , selection-mark , get-selection-type , start-selection
[       file]: builtin.l
[    section]: ポジション
[description]: 
セレクションが存在すれば t しなければ nil を返します。


■preceding-char
[       type]: Function
[  arguments]: preceding-char
[    package]: editor
[    seealso]: following-char , char-before
[       file]: builtin.l
[    section]: テキスト
[description]: 
カーソルの前の文字を返します。
バッファの先頭にカーソルがある場合には、#\NULを返します。

使用例：
  ;;; カーソルの直前が#\LFDか？つまりカーソルは行頭にあるか？
  (char= (preceding-char) #\LFD)
  => t


■prepend-to-register
[       type]: Function
[  arguments]: prepend-to-register R START END &optional DELETE
[    package]: editor
[    seealso]: append-to-register
[       file]: register.l
[    section]: リージョン
[description]: 
START と END で指定されるリージョンを、レジスタ R に格納されているテキ
ストの先頭へ追加します。
R にテキストが入っていないとエラーになります。
DELETE が non-nil ならば同時にリージョンをを削除します。


■previous-buffer
[       type]: Function
[  arguments]: previous-buffer
[    package]: editor
[    seealso]: next-buffer
[       file]: buffer.l
[    section]: バッファ
[description]: 
一つ前のバッファに切替えます。next-bufferの反対です。[S-Home]


■previous-line
[       type]: Function
[  arguments]: previous-line &optional (N 1)
[    package]: editor
[    seealso]: forward-line , next-line , previous-virtual-line
[       file]: cmds.l
[    section]: ポジション
[description]: 
N行前に移動します。
移動の前後で goal-column を保存します。
(previous-line n) と (next-line (- n)) は同じです。

使用例:
  (previous-line)


■previous-page
[       type]: Function
[  arguments]: previous-page
[    package]: editor
[    seealso]: next-page
[   referred]: *next-screen-context-lines* , *page-scroll-half-window*
[       file]: page.l
[    section]: ウィンドウ
[description]: 
1ページ分画面を上スクロールします。[ESC v], [PageUp], [C-z]
*page-scroll-half-window* が non nil なら半画面ずつスクロールします。


■previous-pseudo-frame
[       type]: Function
[  arguments]: previous-pseudo-frame
[    package]: editor
[    seealso]: next-pseudo-frame , other-pseudo-frame , switch-pseudo-frame
[       file]: pframe.l
[    section]: ウィンドウ
[description]: 
前のフレームに移動します。[C-x 6 p]


■previous-virtual-line
[       type]: Function
[  arguments]: previous-virtual-line &optional (N 1)
[    package]: editor
[    seealso]: previous-line
[       file]: cmds.l
[    section]: ポジション
[description]: 
N行前の表示行に移動します。 [C-p], [Up]
  t    先頭行以外の場合
  nil  先頭行の場合


■previous-window
[       type]: Function
[  arguments]: previous-window WINDOW &optional MINIBUF
[    package]: editor
[    seealso]: next-window , set-window
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
WINDOW の前のウィンドウを返します。
  
  MINIBUF : ミニバッファウィンドウを候補に入れるか
       nil    無視する
   non-nil    候補に入れる


■previous-word
[       type]: Function
[  arguments]: previous-word &optional (ARG 1)
[    package]: editor
[    seealso]: backward-word
[       file]: cmds.l
[    section]: ポジション
[description]: 
カーソルを後方の単語の先頭に移動します。


■previous-xyzzy-window
[       type]: Function
[  arguments]: previous-xyzzy-window
[    package]: editor
[    seealso]: next-xyzzy-window , list-xyzzy-windows
[       file]: builtin.l
[    section]: プロセス
[description]: 
前のxyzzyに移動します。
移動順は起動した順の逆です。


■prin1
[       type]: Function
[  arguments]: prin1 OBJECT &optional STREAM
[    package]: lisp
[    seealso]: princ
[       file]: stream.l
[    section]: 入出力
[description]: 
オブジェクトをストリームに出力します。

  OBJECT : 出力するオブジェクトを指定します。
  STREAM : ストリームを指定します。

STREAMを省略されたときは、標準出力に出力します。princでの出力とよく似て
いますが、エスケープ文字を出力することや文字列が引用符で囲まれる点が異な
ります。

使用例：
  ;;; princとprin1の出力の違い
  (princ "abc") => abc  (prin1 "abc") => "abc"
  (princ #\a)   => a    (prin1 #\a)   => #\a


■princ
[       type]: Function
[  arguments]: princ OBJECT &optional STREAM
[    package]: lisp
[    seealso]: prin1
[       file]: stream.l
[    section]: 入出力
[description]: 
オブジェクトをストリームに出力します。

  OBJECT : 出力するオブジェクトを指定します。
  STREAM : ストリームを指定します。

STREAMを省略されたときは、標準出力に出力します。prin1での出力とよく似て
いますが、エスケープ文字を出力しないことや文字列が引用符で囲まれない点が
異なります。
※CLtL2(Common Lisp the Language, 2nd edition)によると人間に読み易いよう
  に意図しているそうです。

使用例：
  ;;; princとprin1の出力の違い
  (princ "abc") => abc  (prin1 "abc") => "abc"
  (princ #\a)   => a    (prin1 #\a)   => #\a


■print-buffer
[       type]: Function
[  arguments]: print-buffer &optional BUFFER
[    package]: editor
[    seealso]: print-dialog
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファを印刷します。


■print-dialog
[       type]: Function
[  arguments]: print-dialog &optional BUFFER
[    package]: editor
[    seealso]: print-buffer
[       file]: builtin.l
[    section]: ダイアログ
[description]: 
指定されたバッファBUFFERの印刷用のダイアログを表示します。


■process-buffer
[       type]: Function
[  arguments]: process-buffer PROCESS
[    package]: editor
[    seealso]: buffer-process
[       file]: builtin.l
[    section]: プロセス
[description]: 
プロセスが結び付けられているバッファを返します。


■process-eol-code
[       type]: Function
[  arguments]: process-eol-code PROCESS
[    package]: editor
[    seealso]: set-process-eol-code
[       file]: builtin.l
[    section]: プロセス
[description]: 
PROCESSに設定された改行コードを返します。


■process-exit-code
[       type]: Function
[  arguments]: process-exit-code PROCESS
[    package]: editor
[    seealso]: signal-process , process-status
[       file]: builtin.l
[    section]: プロセス
[description]: 
指定されたプロセスPROCESSの終了コードを取得します。


■process-filter
[       type]: Function
[  arguments]: process-filter PROCESS
[    package]: editor
[    seealso]: set-process-filter
[   referred]: process-marker
[       file]: builtin.l
[    section]: プロセス
[description]: 
PROCESSに設定されたFILTER用の関数を返します。


■process-incode
[       type]: Function
[  arguments]: process-incode PROCESS
[    package]: editor
[    seealso]: set-process-incode
[       file]: builtin.l
[    section]: プロセス
[description]: 
PROCESSに設定された入力用の文字エンコーディングを指定します。


■process-marker
[       type]: Function
[  arguments]: process-marker PROCESS
[    package]: editor
[    seealso]: make-marker , make-process , delete-marker , process-filter
[       file]: builtin.l
[    section]: プロセス
[description]: 
プロセスに関連付けられたマーカーを返します。
プロセスの出力はマーカー位置に挿入され、
マーカー位置は挿入したテキスト長だけ進みます。

process-filter をセットした場合は、マーカーに対する処理は起こりません。
必要な場合は、通常 process-filter で自分で処理します。
プロセスに関連付けられたマーカーは、 delete-marker で削除することはできません。


■process-outcode
[       type]: Function
[  arguments]: process-outcode PROCESS
[    package]: editor
[    seealso]: set-process-outcode
[       file]: builtin.l
[    section]: プロセス
[description]: 
PROCESSに設定された出力用の文字エンコーディングを指定します。


■process-send-n
[       type]: Function
[  arguments]: process-send-n
[    package]: editor
[    seealso]: process-send-y
[       file]: process.l
[    section]: プロセス
[description]: 
バッファに結び付けられているプロセスに "n\n" を送ります。


■process-send-string
[       type]: Function
[  arguments]: process-send-string PROCESS STRING
[    package]: editor
[    seealso]: make-process
[   referred]: command-output-send-input , set-process-filter
[       file]: builtin.l
[    section]: プロセス
[description]: 
プロセスに文字列を送ります。

  PROCESS : 文字列を送りつけるプロセスを指定します。 
  STRING  : 送りつける文字列を指定します。

使用例：
  ;;; sort.exeを起動して、"abc" "aab" "aac"を送りつける。
  (setq proc (make-process "sort"))
  => #<process 135271372>
  (process-send-string proc "abc\n") => t
  (process-send-string proc "aab\n") => t
  (process-send-string proc "aac\n") => t
  (process-send-string proc "^Z")    => t
  aab
  aac
  abc


■process-send-y
[       type]: Function
[  arguments]: process-send-y
[    package]: editor
[    seealso]: process-send-n
[       file]: process.l
[    section]: プロセス
[description]: 
バッファに結び付けられているプロセスに "y\n" を送ります。


■process-sentinel
[       type]: Function
[  arguments]: process-sentinel PROCESS
[    package]: editor
[    seealso]: set-process-sentinel
[       file]: builtin.l
[    section]: プロセス
[description]: 
PROCESSに設定されたSENTINEL用の関数を返します。


■process-status
[       type]: Function
[  arguments]: process-status PROCESS
[    package]: editor
[    seealso]: kill-process , make-process
[   referred]: process-exit-code
[       file]: builtin.l
[    section]: プロセス
[description]: 
指定されたプロセスの状態を返します。

  :run  動作中
  :exit 停止


■processp
[       type]: Function
[  arguments]: processp OBJECT
[    package]: editor
[       file]: builtin.l
[    section]: データ型
[description]: 
指定されたOBJECTがプロセスかを返します。

  t     OBJECTはプロセス
  nil   OBJECTはプロセスではない


■proclaim
[       type]: Function
[  arguments]: proclaim DECL-SPEC
[    package]: lisp
[    seealso]: declaim , declare
[       file]: typespec.l
[    section]: 変数と定数
[description]: 
変数をスペシャル変数にします。
declare との違いは、関数であるため引数が評価されることと、効果が大域的で
ある点です。

以下の形で使用します。

  (proclaim '(special var1 var2...))

xyzzy では special 以外の指定をしても効果はありません。


■prog
[       type]: Macro
[  arguments]: prog VARLIST &body BODY
[    package]: lisp
[    seealso]: prog* , let , tagbody
[   referred]: go
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
let と block と tagbody を合わせた制御構造です。

VARLIST によって局所変数を作り BODY を評価する点は let と同じですが、
BODY の中で return が使える点、ラベルを作ってジャンプできる点が異なります。

例：
  (let ((x 1)) (return x))
  => `return-from'のキャッチャを参照できません: nil

  (prog ((x 1)) (return x))
  => 1

  (prog ((x 0))
    tag
    (princ x)
    (incf x)
    (if (= x 10)
        (return x)
      (go tag)))
  -> 0123456789
  => 10


■prog*
[       type]: Macro
[  arguments]: prog* VARLIST &body BODY
[    package]: lisp
[    seealso]: tagbody , prog , let*
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
prog とよく似ていますが、 VARLIST の中で先に定義した他の変数を参照でき
る点が異なります。


■prog1
[       type]: Macro
[  arguments]: prog1 FIRST &body BODY
[    package]: lisp
[   referred]: multiple-value-prog1 , prog2
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
フォームを順番に評価して最初のフォームの結果を返します。

使用例：
  (prog1 (print "The first form")
         (print "The second form")
         (print "The third form"))
  -> "The first form"
  -> "The second form"
  -> "The third form"
  => "The first form"


■prog2
[       type]: Macro
[  arguments]: prog2 FIRST SECOND &body BODY
[    package]: lisp
[    seealso]: progn , prog1
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
フォームを順番に評価して二番目のフォームの結果を返します。

使用例：
  (prog2 (print "The first form")
         (print "The second form")
         (print "The third form"))
  -> "The first form"
  -> "The second form"
  -> "The third form"
  => "The second form"


■progn
[       type]: Special Form
[  arguments]: progn {FORM}*
[    package]: lisp
[   referred]: prog2
[       file]: builtin.l
[    section]: 制御構造
[description]: 
フォームを順番に評価して最後のフォームの結果を返します。

使用例：
  (progn (print "The first form")
         (print "The second form")
         (print "The third form"))
  -> "The first form"
  -> "The second form"
  -> "The third form"
  => "The third form"


■provide
[       type]: Function
[  arguments]: provide MODULE-NAME
[    package]: lisp
[    seealso]: require , *modules*
[       file]: evalmacs.l
[    section]: 評価
[description]: 
ある機能を持ったモジュールがロードされた事を示すためにファイルの先頭に書
いておく「おまじない」です。ここに書いたモジュール名が変数*modules*に登
録されます。

requireがモジュールのロードをする際にこの変数がチェックされてロード済だ
ったらもうロードしません。汎用的なモジュールを書く場合には使うようにしま
しょう。

互換性：
  Common Lispにはあり。
  muleにはなさそう。

使用例：
  ;;; lispmode.lより
  (provide "lispmode")


■psetq
[       type]: Macro
[  arguments]: psetq {VAR FORM}*
[    package]: lisp
[    seealso]: setq , psetf
[       file]: evalmacs.l
[    section]: 変数と定数
[description]: 
変数に値を設定します。

  (psetq 変数1 値1 変数2 値2 ... 変数N 値N)

上記の様に変数と値の組を任意の数だけ並べることができます。 

setqと似ていますがsetqが頭から順に変数に値を設定していくのに対し、psetq
は値を全て評価した上で設定します。

使用例：
  ; psetq の場合
  (let ((from 1)
        (to 100))
    (psetq from to to from)
    (values from to))
  =>100
  =>1

  ; setq の場合
  (let ((from 1)
        (to 100))
    (setq from to to from)
    (values from to))
  =>100
  =>100


■pseudo-frame-selector
[       type]: Function
[  arguments]: pseudo-frame-selector
[    package]: editor
[    seealso]: switch-pseudo-frame , select-pseudo-frame
[       file]: pframe.l
[    section]: ウィンドウ
[description]: 
ダイアログからフレームを選択します。


■push
[       type]: Macro
[  arguments]: push ITEM PLACE
[    package]: lisp
[    seealso]: pushnew
[       file]: setf.l
[    section]: リスト
[description]: 
リストの先頭に要素を追加します。

  ITEM  : リストに追加する要素です。
  PLACE : pushする場所はsetfに適用できるものでなければなりません。

使用例：
  ;;; リストの途中にpushしてみる。
  (setq x '(a (b c d) e f))     => (a (b c d) e f)
  (push 99 (cdr (second x)))    => (99 c d)
  x                             => (a (b 99 c d) e f)

互換性：
  Common Lispとxyzzyにあり。
  muleは無さそう。


■pushnew
[       type]: Macro
[  arguments]: pushnew ITEM PLACE &KEY :test :test-not :key
[    package]: lisp
[    seealso]: push , adjoin
[       file]: setf.l
[    section]: リスト
[description]: 
push とほぼ同じですが、リストの最上位に現れている要素でなければリストの
先頭に追加されます。追加するかどうかは、 :test もしくは :test-not で指定
される比較テストを使ってリストの全要素についてチェックして決められます。

  ITEM      : 登録する内容です。
  PLACE     : 登録する場所です。
  :test     : 比較関数です。標準では#'eql？
  :test-not : 比較関数です。
  :key      : キー判定用の関数です。標準では#'identity？

使用例：
  (setq *a* nil)                ;; この時 *a* の値は nil
  (pushnew 'a *a*)  => (a)      ;; この時 *a* の値は (a)
  (pushnew 'b *a*)  => (b a)    ;; この時 *a* の値は (b a)
  (pushnew 'a *a*)  => (b a)    ;; この時 *a* の値は (b a)

互換性：
  Common Lispとxyzzyにあり。
  muleは無さそう。


■quietly-read-abbrev-file
[       type]: Function
[  arguments]: quietly-read-abbrev-file &optional FILE
[    package]: editor
[    seealso]: abbrev-mode
[       file]: abbrev.l
[    section]: モード
[description]: 
Q.現在、モードを切り替えて且つ abbrev を有効にするには、
  ┌───────────────────────────────┐
  │M-x: sql-mode,                                                │
  │M-x: abbrev-mode                                              │
  │M-x: read-abbrev-file,                                        │
  │Read-abbrev-file: C:/xyzzy/.abbrev_defs                       │
  └───────────────────────────────┘
  のように４段階踏まなくてはなりません。最初の M-x: sql-mode の時か、
  ファンクションキーに割り当てて一度に行う方法はないもんでしょうか？

A.[xyzzy:02017]赤塚慶さん
  .xyzzy に
  ┌───────────────────────────────┐
  │; 起動時に abbrev file を読み込む                             │
  │(quietly-read-abbrev-file)                                    │
  └───────────────────────────────┘
  とかいておくと、  .abbrev_defs を呼んでくれます。

  [xyzzy:02020]亀井哲弥さん
  これに加えて、
  ┌───────────────────────────────┐
  │(add-hook 'ed::*sql-mode-hook* #'(lambda () (abbrev-mode t))) │
  └───────────────────────────────┘
  も書いておけば、M-x sql-mode だけでいけると思います(たぶん)。


■quit
[       type]: Function
[  arguments]: quit
[    package]: editor
[    seealso]: error
[       file]: cmds.l
[    section]: エラー
[description]: 
コマンドの実行などを中止します。[C-g]

実行に時間がかかりすぎる場合や無限ループに陥ったときなどに使われます。


■quote
[       type]: Special Form
[  arguments]: quote OBJECT
[    package]: lisp
[    seealso]: ``'(backquote) , function
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
OBJECTを評価せずに返します。
single quoteで代用されます。

使用例：
  ;;; quoteと'を使ってみる。
  (quote x)             => x
  'x                    => x
  (eq (quote x) 'x)     => t


■quote-char
[       type]: Function
[  arguments]: quote-char &optional (ARG 1)
[    package]: editor
[       file]: cmds.l
[    section]: 文字
[description]: 
プロンプトを表示して、入力に従ってバッファに文字を挿入します。[C-q]
制御文字の入力などに使われます。
文字コードによる入力も可能です。


■quote-region
[       type]: Function
[  arguments]: quote-region FROM TO
[    package]: editor
[    seealso]: *quotation-prefix*
[       file]: region.l
[    section]: リージョン
[description]: 
指定されたリージョンの先頭に引用を表す接頭子を挿入します。
引用を表す接頭子として *quotation-prefix* を挿入します。


■quote-string
[       type]: Function
[  arguments]: quote-string STRING TARGET-CHAR QUOTE-CHAR
[    package]: editor
[    seealso]: substitute-string
[       file]: builtin.l
[    section]: 文字列
[description]: 
文字列中の特定文字の前にエスケープ文字をつけます。

  STRING      : 置換する文字列
  TARGET-CHAR : エスケープされる文字
  QUOTE-CHAR  : エスケープ文字

使用例：
  ;;;   スペースの前に'をつけます。
  (quote-string  "a b  c"  #\SPC #\')
  => "a' b' ' c"


■quoted-printable-decode-region
[       type]: Function
[  arguments]: quoted-printable-decode-region FROM TO
[    package]: editor
[    seealso]: si:quoted-printable-decode , quoted-printable-decode-region-to-file
[       file]: encdec.l
[    section]: リージョン
[description]: 
リージョンをQuoted-Printableデコードします。


■quoted-printable-decode-region-to-file
[       type]: Function
[  arguments]: quoted-printable-decode-region-to-file FILENAME FROM TO
[    package]: editor
[    seealso]: si:quoted-printable-decode , quoted-printable-decode-region
[       file]: encdec.l
[    section]: リージョン
[description]: 
リージョンをQuoted-Printableデコードしてファイルに保存します。


■random
[       type]: Function
[  arguments]: random NUMBER &optional STATE
[    seealso]: *random-state* , make-random-state
[       file]: builtin.l
[    section]: 数値
[description]: 
0以上NUMBER未満の乱数を返します。

  STATE: 乱数の状態変数です。破壊的に処理されます。


■rassoc
[       type]: Function
[  arguments]: rassoc ITEM A-LIST &key :test :test-not :key
[    package]: lisp
[    seealso]: rassoc-if , rassoc-if-not , assoc
[       file]: builtin.l
[    section]: リスト
[description]: 
連想リスト A-LIST の中で cdr 部が ITEM との :test を満たす最初のペアを返します。

使用例：
  (rassoc 'a '((a . b) (b . c) (c . a) (z . a)))
  => (c . a)


■rassoc-if
[       type]: Function
[  arguments]: rassoc-if PREDICATE A-LIST &key :key
[    package]: lisp
[    seealso]: rassoc , rassoc-if-not
[       file]: builtin.l
[    section]: リスト
[description]: 
連想リスト A-LIST の中で cdr 部が PREDICATE を満たす最初のペアを返します。

使用例：
  (rassoc-if #'numberp '((a . b) (1 . c) (2 . 4)))
  => (2 . 4)


■rassoc-if-not
[       type]: Function
[  arguments]: rassoc-if-not PREDICATE A-LIST &key :key
[    package]: lisp
[    seealso]: rassoc , rassoc-if
[       file]: builtin.l
[    section]: リスト
[description]: 
連想リスト A-LIST の中で cdr 部が PREDICATE を満たさない最初のペアを返します。

使用例：
  (rassoc-if-not #'numberp '((a . b) (1 . c) (2 . d)))
  => (a . b)


■rational
[       type]: Function
[  arguments]: rational NUMBER
[    package]: lisp
[    seealso]: rationalize
[       file]: builtin.l
[    section]: 数値
[description]: 
実数を有理数に変換します。もしも、 NUMBER がすでに有理数だったら、そのま
ま返します。 rational の場合は、浮動小数点数を全く誤差を含まないものとし
て扱い、その浮動小数点数を数学的に有理数化します。
  
  ;;; 0.5 は2進数でちょうど表せる
  (rational 0.5)
  =>1/2
  ;;; 0.1 は2進数では誤差を含む
  (rational 0.1)
  =>13421773/134217728
  ;;; 倍精度だとまた違う
  (rational 0.1d0)
  =>3602879701896397/36028797018963968


■rationalize
[       type]: Function
[  arguments]: rationalize NUMBER
[    package]: lisp
[    seealso]: rational , float
[       file]: builtin.l
[    section]: 数値
[description]: 
実数を有理数に変換します。もしも、 NUMBER がすでに有理数だったら、そのま
ま返します。 rationalize の場合は、浮動小数点数を表示される範囲までの精
度で扱い、近似して有理数化します。


■rationalp
[       type]: Function
[  arguments]: rationalp OBJECT
[    package]: lisp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTがratioかintegerならt、それ以外ならnilを返します。

  (rationalp x) == (typep x 'rational)


■re-search-backward
[       type]: Function
[  arguments]: re-search-backward REGEXP &optional NOERROR
[    package]: editor
[    seealso]: re-search-forward
[       file]: search.l
[    section]: 検索・正規表現
[description]: 
正規表現による後方検索をします。[ESC C-s]

  REGEXP  : 正規表現による検索文字列
  NOERROR : 文字列が見つからなかったときの動作を指定します。
        t   nil を返します。
        nil エラーメッセージを出力します。


■re-search-backward-again
[       type]: Function
[  arguments]: re-search-backward-again
[    package]: editor
[    seealso]: ed::*last-search-regexp* , re-search-forward-again
[       file]: search.l
[    section]: 検索・正規表現
[description]: 
前回の正規表現検索パターンで後方検索します。


■re-search-forward
[       type]: Function
[  arguments]: re-search-forward REGEXP &optional NOERROR
[    package]: editor
[    seealso]: re-search-backward
[       file]: search.l
[    section]: 検索・正規表現
[description]: 
正規表現による前方検索をします。[ESC s]

  REGEXP  : 正規表現による検索文字列
  NOERROR : 文字列が見つからなかったときの動作を指定します。
        t   nil を返します。
        nil エラーメッセージを出力します。


■re-search-forward-again
[       type]: Function
[  arguments]: re-search-forward-again
[    package]: editor
[    seealso]: ed::*last-search-regexp* , re-search-backward-again
[   referred]: repeat-backward-search , repeat-forward-search
[       file]: search.l
[    section]: 検索・正規表現
[description]: 
前回の正規表現検索パターンで前方検索します。


■read
[       type]: Function
[  arguments]: read &optional INPUT-STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P
[    package]: lisp
[   referred]: buffer-stream-point , read-as-string , read-delimited-list , read-into , read-line-into , read-preserving-whitespace , write
[       file]: builtin.l
[    section]: 入出力
[description]: 
INPUT-STREAM から Lisp のオブジェクトを読み込んで返します。

  INPUT-STREAM : 入力元のストリーム
  EOF-ERROR-P  : EOFの状態でread-charしたときにどうするか？
        t               エラーとする。
        nil             エラーとせず、nilを返します。
  EOF-VALUE    : EOFの状態でreadしたときにnilの代わりに返す文字を指定します。
  RECURSIVE-P  : （詳細不明）


■read-as-string
[       type]: Function
[  arguments]: read-as-string STREAM &optional EOF-ERROR-P EOF-VALUE
[    package]: editor
[    seealso]: read
[       file]: builtin.l
[    section]: 入出力
[description]: 
ストリームからトークンを読み込んで文字列として返します。
マクロ文字やエスケープ文字は読み取りません。


■read-buffer-name
[       type]: Function
[  arguments]: read-buffer-name PROMPT &key :default :history
[    package]: editor
[    seealso]: interactive
[   referred]: read-exist-buffer-name
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
ミニバッファにプロンプトを表示してユーザーがバッファ名を入力するのを待ち
ます。ユーザーの入力したバッファを返します。入力したバッファが存在しない
場合は、文字列をそのまま返します。
(interactive "B") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します

使用例:
  ;;; ミニバッファからバッファ名を読み込む
  (read-buffer-name "Buffer: ")   ; ←*scratch* と入力
  =>#<buffer: *scratch*>


■read-char
[       type]: Function
[  arguments]: read-char &optional INPUT-STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P
[    package]: lisp
[    seealso]: read-char-no-hang , write-char
[   referred]: peek-char
[       file]: builtin.l
[    section]: 入出力
[description]: 
指定された入力ストリームから一文字読み込んで、文字を返します。

  INPUT-STREAM : 入力ストリーム
  EOF-ERROR-P  : EOFの状態でread-charしたときにどうするか？
        t               エラーとする。
        nil             エラーとせず、nilを返します。
  EOF-VALUE    : EOFの状態でread-charしたときにnilの代わりに返す文字を指定します。
  RECURSIVE-P  : （詳細不明）

使用例：
  (read-char *keyboard*) <-- "a"を入力
  => #\a

補足：
  蛇足ですが、EOFはEnd Of Fileの略です。ファイルやストリームをすっかり読
  み終わってしまった状態を指します。


■read-char-encoding
[       type]: Function
[  arguments]: read-char-encoding PROMPT &key :history
[    package]: editor
[    seealso]: read-exact-char-encoding , *char-encoding-list* , interactive
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
ミニバッファにプロンプトを表示してユーザーが文字エンコーディングを入力す
るのを待ちます。ユーザーの入力した文字エンコーディングを返します。補完の
リストは *char-encoding-list* を参照しているようです。
(interactive "z") に相当します。

  PROMPT     : プロンプト
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します

使用例:
  ;;; ミニバッファから文字エンコーディングを読み込む
  (read-char-encoding "Encoding: ") ; ←utf8n と入力
  =>#.(make-utf8-encoding "utf8n" "Unicode (UTF-8N)" :signature nil :windows t :byte-order nil :cjk :jp)


■read-char-no-hang
[       type]: Function
[  arguments]: read-char-no-hang &optional INPUT-STREAM EOF-ERROR-P EOF-VALUE
[    package]: lisp
[    seealso]: read-char , listen
[       file]: builtin.l
[    section]: 入出力
[description]: 
read-char と同じです。ただし、入力がなければ待たずに nil を返します。


■read-command-name
[       type]: Function
[  arguments]: read-command-name PROMPT &key :default :history
[    package]: editor
[    seealso]: interactive
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
ミニバッファにプロンプトを表示してユーザーがコマンドを入力するのを待ちま
す。ユーザーの入力したコマンドのシンボルを返します。(「コマンド」は「interactive宣言された関数」の意味で使ってます)
(interactive "C") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します


■read-delimited-list
[       type]: Function
[  arguments]: read-delimited-list CHAR &optional INPUT-STREAM RECURSIVE-P
[    package]: lisp
[    seealso]: read
[       file]: builtin.l
[    section]: 入出力
[description]: 
指定した文字が現れるまで Lisp オブジェクトを読み込み、結果のリストを返します。

  CHAR         : リストの終わりを表す文字
  INPUT-STREAM : 入力元のストリーム
  RECURSIVE-P  : nil ならトップレベル、non-nil なら再帰呼び出しとして読み込む


■read-directory-name
[       type]: Function
[  arguments]: read-directory-name PROMPT &key :default :title :history
[    package]: editor
[    seealso]: interactive
[   referred]: directory-name-dialog , file-name-dialog
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
ミニバッファにプロンプトを表示してユーザーがディレクトリ名を入力するのを
待ちます。入力中は TAB キーでディレクトリ名を補完できます。 "~" はユーザ
ーのホームディレクトリに、 ".." は親ディレクトリに変換されます。ユーザー
の入力したディレクトリ名を返します。
(interactive "D") に相当します。

  PROMPT     : プロンプト
  :default   : 初期表示するディレクトリ名
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します

使用例：
  ;;; ミニバッファからディレクトリ名を読み取る。
  (read-directory-name "directory: ")
  => "C:/applications/xyzzy/etc"


■read-exact-char-encoding
[       type]: Function
[  arguments]: read-exact-char-encoding PROMPT &key :history
[    package]: editor
[    seealso]: read-char-encoding
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
read-char-encodingとほぼ同じですが、自動判定が候補から除外されます。
(interactive "Z") に相当します。


■read-exist-buffer-name
[       type]: Function
[  arguments]: read-exist-buffer-name PROMPT &key :default :history
[    package]: editor
[    seealso]: read-buffer-name , interactive
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
read-buffer-name とほとんど同じですが、 read-exist-buffer-name はすでに
存在するバッファ名しか指定できません。
(interactive "b") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します


■read-exist-file-name
[       type]: Function
[  arguments]: read-exist-file-name PROMPT &key :default :title :history
[    package]: editor
[    seealso]: read-file-name , interactive
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
read-file-name とほとんど同じですが、 read-exist-file-name はすでに存在
しているファイルしか指定できません。
(interactive "f") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :title     : 一画面ファイラのタイトル
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します


■read-file
[       type]: Function
[  arguments]: read-file FILENAME &optional ENCODING NOMSG
[    package]: editor
[    seealso]: find-file , insert-file-contents , insert-file
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
バッファをクリアして FILENAME の内容を書き込みます。[C-x C-r]
バッファ名およびバッファに関連付けられたファイルは変更しません。

  ENCODING : エンコーディングを指定します。
  NOMSG    : non-nil ならステータスバーに経過メッセージを表示しません。


■read-file-name
[       type]: Function
[  arguments]: read-file-name PROMPT &key :default :title :history
[    package]: editor
[    seealso]: read-exist-file-name , read-file-name-list , interactive
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
ミニバッファにプロンプトを表示してユーザーがファイル名を入力するのを待ち
ます。入力中は TAB キーでファイル名を補完できます。 "~" はユーザーのホー
ムディレクトリに、 ".." は親ディレクトリに変換されます。ユーザーの入力し
たファイル名を返します。
(interactive "F") に相当します。

  PROMPT     : プロンプト
  :default   : 初期表示するファイル名
  :title     : 一画面ファイラのタイトル
  :history   : 履歴情報
               minibuffer-history-variable プロパティを持つシンボルを指定します

使用例：
  ;;; ミニバッファからファイル名を読み取る。
  (read-file-name "filename: ")
  => "C:/applications/xyzzy/xyzzy.exe"


■read-file-name-list
[       type]: Function
[  arguments]: read-file-name-list PROMPT &key :default :title :history
[    package]: editor
[    seealso]: read-file-name , interactive
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
read-file-name とほとんど同じですが、 read-file-name-list は複数のファイ
ルを指定できます。複数のファイルを指定した場合は、そのリストを返します。
(interactive "l") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :title     : 一画面ファイラのタイトル
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します


■read-from-string
[       type]: Function
[  arguments]: read-from-string STRING &optional EOF-ERROR-P EOF-VALUE &key :start :end :preserve-whitespace
[    package]: lisp
[    seealso]: parse-integer
[       file]: stream.l
[    section]: 入出力
[description]: 
文字列を読み、多値で2つの値を返します。1つ目の戻り値は Lisp Reader が読
み込んだオブジェクトそのもの、2つ目の戻り値は文字列中において読まなかっ
た最初の文字の位置です。文字列を最後まで読んだ場合、2つ目の戻り値はその
文字列の長さと等しくなります。

  STRING               : 読む対象である文字列
  EOF-ERROR-P          : EOFの状態でread-from-stringしたときにどうするか？
                non-nil    エラーとします。(デフォルト)
                nil        エラーとせず、nilを返します。
  EOF-VALUE            : EOFの状態でread-from-stringしたときにnilの代わ
                         りに返す文字を指定します。
  :start               : 読み始める位置(デフォルトは0)
  :end                 : 読み終わる位置(デフォルトは文字列の長さ)
  :preserve-whitespace : (詳細不明)                non-nil                    nil        

■read-function-name
[       type]: Function
[  arguments]: read-function-name PROMPT &key :default :history
[    package]: editor
[    seealso]: interactive
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
ミニバッファにプロンプトを表示してユーザーが関数名を入力するのを待ちます。
ユーザーの入力した関数のシンボルを返します。(interactive "a") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します


■read-integer
[       type]: Function
[  arguments]: read-integer PROMPT
[    package]: editor
[    seealso]: interactive
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
ミニバッファにプロンプトを表示してユーザーが整数を入力するを待ちます。
ユーザーの入力した整数を返します。
(interactive "n") に相当します。

  PROMPT     : プロンプト

使用例：
  ;;; ミニバッファから数値を読み取る。
  (read-integer "num: ")
  => 123


■read-into
[       type]: Function
[  arguments]: read-into STRING &optional INPUT-STREAM EOF-ERROR-P EOF-VALUE MAX-LENGTH
[    package]: editor
[    seealso]: read
[   referred]: read-line-into
[       file]: builtin.l
[    section]: 入出力
[description]: 
指定された入力ストリームから文字列を読み込み、指定された文字列に格納します。
結果の書き込みは破壊的に行われます。

  STRING       : 結果を格納する文字列。フィルポインタを持たなければならない
  INPUT-STREAM : 入力元のストリーム
  EOF-ERROR-P  : non-nil なら、入力ストリームが終端に達しているとエラー
  EOF-VALUE    : 入力ストリームが最初から終端に達していた場合の戻り値
  MAX-LENGTH   : 読み込む長さの上限。デフォルトは STRING の本来の長さ

INPUT-STREAM が終端に達していた場合を除いて戻り値は STRING です。

使用例：
  (let ((x (make-vector 2 :element-type 'character :fill-pointer 0)))
    (read-into x (make-string-input-stream "abcdef")))
  => "ab"

  (let ((x (make-vector 10 :element-type 'character :fill-pointer 0)))
    (read-into x (make-string-input-stream "abcdef")))
  => "abcdef"

  (let ((x (make-vector 10 :element-type 'character :fill-pointer 0)))
    (read-into x (make-string-input-stream "abcdef") t nil 3))
  => "abc"


■read-line
[       type]: Function
[  arguments]: read-line &optional INPUT-STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P
[    package]: lisp
[   referred]: read-line-into
[       file]: builtin.l
[    section]: 入出力
[description]: 
指定された入力ストリームから一行読み込んで文字列として返します。

  INPUT-STREAM : 入力元のストリーム
  EOF-ERROR-P  : nil 以外の場合、入力ストリームが終端に達しているとエラー
  EOF-VALUE    : 入力ストリームが最初から終端に達していた場合の戻り値

二つ目の戻り値として、改行文字を読み込んだ場合は nil を、に達した場合
は t を返します。

RECURSIVE-P は、与えることはできますが使用されません。


■read-line-into
[       type]: Function
[  arguments]: read-line-into STRING &optional INPUT-STREAM EOF-ERROR-P EOF-VALUE
[    package]: editor
[    seealso]: read-line , read-into , read
[       file]: builtin.l
[    section]: 入出力
[description]: 
指定された入力ストリームから一行読み込んで、指定された文字列に格納します。
格納先の文字列は破壊されます。

  STRING       : 結果を埋め込む先の文字列。
                 フィルポインタを持ち、かつアジャスタブルでなければならない
  INPUT-STREAM : 入力元のストリーム
  EOF-ERROR-P  : non-nil なら、入力ストリームが終端に達しているとエラー
  EOF-VALUE    : 入力ストリームが最初から終端に達していた場合の戻り値

INPUT-STREAM が終端に達していた場合を除いて戻り値は STRING です。
また二つ目の戻り値として、改行文字を読み込んだ場合は nil を、終端に達
した場合は t を返します。

使用例：
  (let ((x (make-vector 2 :element-type 'character :fill-pointer 0 :adjustable t)))
    (read-line-into x (make-string-input-stream "abcdef")))
  => "abcdef"
  => t

  (let ((x (make-vector 2 :element-type 'character :fill-pointer 0 :adjustable t)))
    (read-line-into x (make-string-input-stream "abc\ndef")))
  => "abc"
  => nil


■read-preserving-whitespace
[       type]: Function
[  arguments]: read-preserving-whitespace &optional IN-STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P
[    package]: lisp
[    seealso]: read
[       file]: builtin.l
[    section]: 入出力
[description]: 
ストリームから Lisp のオブジェクトを読み込んで返します。
read とほぼ同じですが、読んだ最後の文字が空白文字だった場合、その文字を
ストリームへ戻します。


■read-registry
[       type]: Function
[  arguments]: read-registry SECTION KEY &optional ROOT
[    package]: editor
[   referred]: write-registry
[       file]: builtin.l
[    section]: システム
[description]: 
レジストリから読み込みます。

  SECTION : セクションを指定します。
  KEY     : キーを指定します。
  ROOT    : ルートキーを指定します。
     nil             HKEY_CURRENT_USER\Software\Free Software\Xyzzy
     :current-user   HKEY_CURRENT_USER
     :classes-root   HKEY_CLASSES_ROOT
     :local-machine  HKEY_LOCAL_MACHINE
     :users          HKEY_USERS

使用例：
  ;;; HKEY_CURRENT_USER/software/Microsoft/devstudio/5.0/Recent File List/project1 の値を読む
  (read-registry "software\\Microsoft\\devstudio\\5.0\\Recent File List" "project1"  :current-user)


■read-sexp
[       type]: Function
[  arguments]: read-sexp PROMPT
[    package]: editor
[    seealso]: interactive
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
ミニバッファにプロンプトを表示してユーザーがS式を入力するのを待ちます。
ユーザーの入力したS式と文字数を多値で返します。
(interactive "x") に相当します。

  PROMPT     : プロンプト

使用例：
  ;;; ミニバッファからS式を入力する。
  (read-sexp "sexp: ")
  => (+ 3 3)
  => 7


■read-string
[       type]: Function
[  arguments]: read-string PROMPT &key :default :history
[    package]: editor
[    seealso]: completing-read , interactive
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
ミニバッファにプロンプトを表示してユーザーが文字列を入力するのを待ちます。
ユーザーの入力した文字列を返します。
(interactive "s") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します

使用例：
  ;;; ミニバッファからURLを入力する。
  (read-string "URL: ")
  => "http://www.yahoo.co.jp"


■read-symbol-name
[       type]: Function
[  arguments]: read-symbol-name PROMPT &key :default :history
[    package]: editor
[    seealso]: interactive
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
ミニバッファにプロンプトを表示してユーザーがシンボルを入力するのを待ちます。
ユーザーの入力したシンボルを返します。(interactive "S") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します


■read-variable-name
[       type]: Function
[  arguments]: read-variable-name PROMPT &key :default :history
[    package]: editor
[    seealso]: interactive
[       file]: builtin.l
[    section]: ミニバッファ
[description]: 
ミニバッファにプロンプトを表示してユーザーが変数を入力するのを待ちます。
ユーザーの入力した変数のシンボルを返します。(interactive "v") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します


■readtable-case
[       type]: Function
[  arguments]: readtable-case READTABLE
[    package]: lisp
[    seealso]: si:*set-readtable-case , *readtable*
[       file]: builtin.l
[    section]: 入出力
[description]: 
READTABLE の case sensitivity を返します。
この値はシンボルの read および print の際の挙動に影響します。

戻り値
  :upcase       read の際にアルファベットを大文字に変換
                print の際に小文字を含むシンボル名をエスケープ
  :downcase     read の際にアルファベットを小文字に変換
                print の際に大文字を含むシンボル名をエスケープ
  :preserve     大文字小文字の変換・エスケープをしない (デフォルト)
  :invert       read 時は :preserve と同じ？
                print の際にアルファベットを含むシンボル名をエスケープ

リードテーブルの case sensitivity を変更するには si:*set-readtable-case
または setf を使います。

例:
  (let ((*readtable* (copy-readtable *readtable*)))
    (dolist (rtc '(:upcase :downcase :preserve :invert))
      (setf (readtable-case *readtable*) rtc)
      (print (read-from-string "Foo"))))
  -> FOO
  -> foo
  -> Foo
  -> |Foo|
  => nil


■readtablep
[       type]: Function
[  arguments]: readtablep OBJECT
[    package]: lisp
[    seealso]: *readtable*
[       file]: builtin.l
[    section]: 入出力
[description]: 
OBJECT がリードテーブルなら t 、それ以外なら nil を返します。


■realp
[       type]: Function
[  arguments]: realp OBJECT
[    package]: lisp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECT が real number なら t 、それ以外なら nil を返します。


■realpart
[       type]: Function
[  arguments]: realpart NUMBER
[    package]: lisp
[    seealso]: imagpart , complex
[       file]: builtin.l
[    section]: 数値
[description]: 
複素数の実数部を取得します。

使用例：
  (setq a (complex 1 3))
  =>#C(1 3)

  (realpart a)
  =>1


■recenter
[       type]: Function
[  arguments]: recenter &optional ARG
[    package]: editor
[       file]: window.l
[    section]: ウィンドウ
[description]: 
バッファをスクロールして画面上の表示位置を調整します。[C-l]
引数を指定しなければ現在行が画面の中央に位置します。
(recenter 0) で現在行がウインドウの一番上に来ます。

  ARG : 調整後のカーソル位置
   nil          画面中央の行に移動。
   数字の場合   正の数なら、ウィンドウの上からの行数。
                負の数なら、ウィンドウの下からの行数。

戻り値
  カーソルが移動した時はt
            移動しなかった時はnil


■redo
[       type]: Function
[  arguments]: redo
[    package]: editor
[    seealso]: undo , buffer-can-redo-p
[       file]: builtin.l
[    section]: バッファ
[description]: 
元に戻した処理を再度実行します。[C-_],[S-End],[F12]

buffer-can-redo-p が t の時のみ実行可能です。


■reduce
[       type]: Function
[  arguments]: reduce FUNCTION SEQUENCE &key :from-end :start :end :initial-value
[    package]: lisp
[       file]: sequence.l
[    section]: シーケンス
[description]: 
2項演算子であるFUNCTIONで、SEQUENCEに対して畳み込みを行います。
  
  FUNCTION  : 2項演算子。
  :from-end : nil なら先頭から、non-nil なら最後の要素から畳み込みを行います。
  :start    : 畳み込みを行う SEQUENCE の開始インデックスです。デフォルトは 0 です。 
              :from-end が non-nil なら終了インデックスになります。
  :END      : 畳み込みを行う SEQUENCE の終了インデックスです。デフォルトは nil です。
              :from-end が non-nil なら開始インデックスになります。
  :INITIAL-VALUE : non-nil ならばこの値を初期値として使用します。

 (reduce #'- '(1 2 3)) = (- (- 1 2) 3)
 (reduce #'- '(1 2 3) :initial-value 10) = (- (- (- 10 1) 2) 3)
 (reduce #'- '(1 2 3) :from-end t :initial-value 10) = (- 1 (- 2 (- 3 10)))


■refresh-screen
[       type]: Function
[  arguments]: refresh-screen &optional F
[    package]: editor
[    seealso]: do-events , sit-for , sleep-for
[   referred]: get-window-line
[       file]: builtin.l
[    section]: その他
[description]: 
画面をリフレッシュします。
キー入力の方が画面の再描画よりも優先されます。従って、外部プロセスから非
同期に入力される文字列をバッファに出力したり、処理の途中でダイアログを表
示すると、画面が追いついていない場合があります。そのような場合に実行します。


■refresh-tool-bars
[       type]: Function
[  arguments]: refresh-tool-bars
[    package]: editor
[       file]: builtin.l
[    section]: メニュー
[description]: 
ツールバーをリフレッシュします。
lisp/optprop.lの中から共通設定の変更内容を、ツールバーに反映するために用
いられています。


■regexp-keyword-list
[       type]: Variable
[    package]: editor
[    seealso]: 正規表現の表記
[   referred]: compile-regexp-keyword-list
[    section]: 検索・正規表現
[description]: 
正規表現を用いたキーワードの色分け機能です。キーワード長は256文
字程度らしいです。

使用例：
  (defvar *c-number-formats*
    (compile-regexp-keyword-list
     '(("\\(^\\|\\_S\\)\\(?:[0-9]+\\.[0-9]*\\|\\.[0-9]+\\)\\(?:e[-+]?[0-9]+\\)?[fl]?\\($\\|\\_S\\)"
        t (:keyword 0 :bold) nil -1 -2)
       ("\\_<[0-9]+e[-+]?[0-9]+[fl]?\\_>" t 1)
       ("\\_<\\([1-9][0-9]*\\|0[0-7]*\\|0x[0-9a-f]+\\)\\(u?l\\|l?u\\|u?i64\\)?\\_>"
        t (:color 1 2 :underline)))))
  (make-local-variable 'regexp-keyword-list)
  (setq regexp-keyword-list *c-number-formats*)

形式：
  (compile-regexp-keyword-list
   '((regexp1 case-fold color [ context [ begin [ end ] ] ] )
     (regexp2 case-fold color [ context [ begin [ end ] ] ] )
     ...
     (regexpN case-fold color [ context [ begin [ end ] ] ] )))

パラメタ：
  regexp  
      正規表現
  case-fold
      non-nil  正規表現のマッチングで大文字小文字を区別しない
      nil      正規表現のマッチングで大文字小文字を区別する
  color
      下の何れかの形式で指定します。
      keyword-color
          0-2       キーワードの1-3の色
          3-5       キーワードの1-3の色でそのキーワードだけ反転 
          6-8       キーワードの1-3の色でその行の端から端まで反転
          9         単なるbold 
          10-18     0-8と同じ色でbold
          :string   文字列の色 
          :comment  コメントの色 
          :tag      タグの色 
      (:keyword keyword-color [attributes])
          keyword-color
              keyword-colorの値
          attributes
              :bold        ボールド 
              :underline   アンダーライン 
              :strike-out  取り消し線 
              :line        一行まるごと 
      (:color foreground [background [attributes]]) 
          foreground
              0-15  前景色
          background 
              0     指定しない
              1-15  背景色
  context
      キーワードが有効な文脈を指定します。下のシンボルもしくは
      シンボルのリストを指定します。指定しない場合には、nilが指
      定されたものとして動作します。
      :string   文字列内部で有効
      :tag      タグの内部で有効
      :comment  コメントの内部で有効
      nil       上記以外で有効
      t         全ての文脈で有効
  begin
      マッチしたテキストの色を付ける部分の開始位置を指定します。
      0-9ならば(match-beginning begin)の位置からです。-1--9なら
      ば(match-end (- begin))の位置からです。指定しないかnilの場合に
      は(match-beginning 0)の位置からです。
  end
      マッチしたテキストの色を付ける部分の終了位置を指定します。
      0-9ならば(match-end end)の位置までです。-1--9ならば
      (match-beginning (- end))の位置までです。指定しないかnilの場合に
      は(match-end 0)の位置までです。


■regexp-quote
[       type]: Function
[  arguments]: regexp-quote REGEXP
[    package]: editor
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
REGEXPのメタ文字をエスケープした表現を返します。
例えば、「正規表現のメタ文字を含む文字列」を含む
正規表現で検索したい場合に便利です。
使用例：
  (regexp-quote "a+b*")
  =>"a\\+b\\*"


■regexpp
[       type]: Function
[  arguments]: regexpp OBJECT
[    package]: editor
[    seealso]: compile-regexp
[       file]: builtin.l
[    section]: データ型
[description]: 
指定されたOBJECTがコンパイル済み正規表現かを返します。

  t     OBJECTはコンパイル済み正規表現
  nil   OBJECTはコンパイル済み正規表現ではない


■region-beginning
[       type]: Function
[  arguments]: region-beginning
[    package]: editor
[    seealso]: region-end , selection-mark , mark , point
[       file]: builtin.l
[    section]: ポジション
[description]: 
リージョンの開始のポイントを返します。

  ; markやpointとの関係
  (= (region-beginning) (min (mark) (point)))
  =>t


■region-end
[       type]: Function
[  arguments]: region-end
[    package]: editor
[    seealso]: region-beginning , selection-point , mark , point
[       file]: builtin.l
[    section]: ポジション
[description]: 
リージョンの終端のポイントを返します。

  ; markやpointとの関係
  (= (region-end) (max (mark) (point)))
  =>t


■register-history-variable
[       type]: Function
[  arguments]: register-history-variable VAR
[    package]: editor
[    seealso]: define-history-variable , unregister-history-variable
[       file]: history.l
[    section]: 変数と定数
[description]: 
すでに定義された変数 VAR をヒストリ変数に登録します。
ファイルに書き込まれるため、変数の内容は readable である必要があります。
readable であるとは、具体的に言うと「文字、文字列、数値、シンボルと
それらのリストで構成されるデータ」のことです。
  VAR : ヒストリ変数に登録する変数のシンボル、もしくはそれらのリスト


■rem
[       type]: Function
[  arguments]: rem NUMBER DIVISOR
[    package]: lisp
[    seealso]: truncate , mod
[       file]: builtin.l
[    section]: 数値
[description]: 
(truncate NUMBER DIVISOR)の戻り値の二つ目を返します。

使用例：  
  (rem 13 4)
  => 1
  (rem -13 4)
  => -1


■remhash
[       type]: Function
[  arguments]: remhash KEY HASH-TABLE
[    package]: lisp
[    seealso]: make-hash-table
[       file]: builtin.l
[    section]: ハッシュ
[description]: 
ハッシュテーブルの中からキーが一致するものを削除します。

  KEY        : 削除するキーを指定します。
  HASH-TABLE : ハッシュテーブルを指定します。

一致するキーが存在すれば削除してtを返します。
なければnilを返します。

使用例：
  (setq hash-table (make-hash-table))
  => #<hash table>
  (setf (gethash 'a hash-table) 1)
  => 1
  (remhash 'b hash-table)
  => nil
  (remhash 'a hash-table)
  => t


■remove
[       type]: Function
[  arguments]: remove ITEM SEQUENCE &key :from-end :test :test-not :start :end :count :key
[    package]: lisp
[    seealso]: delete , remove-if , remove-if-not , remove-duplicates
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCE の中で ITEM と一致するものを削除したシーケンスを返します。
引数 SEQUENCE は保存されます。

  :count    : 削除する文字数を制限します。
  :from-end : :countが指定された場合にのみ意味を持ちます。
         nil    SEQUENCEの先頭から削除します。
         t      SEQUENCEの後尾から削除します。

使用例：
  ;;; removeとdeleteを使ってみる。
  (setq foo "abcabcdef")        => "abcabcdef"
  (remove #\b foo)              => "acacdef"
  foo                           => "abcabcdef"
  (delete #\b foo)              => "acacdef"
  foo                           => "acacdef"


■remove-duplicates
[       type]: Function
[  arguments]: remove-duplicates SEQUENCE &key :from-end :test :test-not (:start 0) :end (:key #'identity)
[    package]: lisp
[    seealso]: remove , delete-duplicates
[       file]: sequence.l
[    section]: シーケンス
[description]: 
SEQUENCE の中から重複する要素を削除したシーケンスを返します。
remove 同様、引数 SEQUENCE は保存されます。

  :from-end  non-nil ならシーケンスの終わりから重複する要素を削除していきます。


■remove-if
[       type]: Function
[  arguments]: remove-if PREDICATE SEQUENCE &key :from-end :start :end :count :key
[    package]: lisp
[    seealso]: remove , remove-if-not , delete-if
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCE の中で PREDICATE を満たすものを削除したシーケンスを返します。
引数 SEQUENCE は保存されます。


■remove-if-not
[       type]: Function
[  arguments]: remove-if-not PREDICATE SEQUENCE &key :from-end :start :end :count :key
[    package]: lisp
[    seealso]: remove , remove-if , delete-if-not
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCEの中でPREDICATEを満たさないものを削除したシーケンスを返します。
元のSEQUENCEは保存されます。


■remove-trail-slash
[       type]: Function
[  arguments]: remove-trail-slash STRING
[    package]: editor
[    seealso]: append-trail-slash
[   referred]: directory-namestring
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
STRINGの末尾に"/"があれば削除した文字列を返します。
使用例：
  (remove-trail-slash "ffjfj")
  =>"ffjfj"

  (remove-trail-slash "ffjfj/")
  =>"ffjfj"


■remprop
[       type]: Function
[  arguments]: remprop SYMBOL INDICATOR
[    package]: lisp
[    seealso]: get
[       file]: builtin.l
[    section]: シンボル
[description]: 
シンボルのプロパティを削除します。

  SYMBOL    : プロパティを返すシンボル
  INDICATOR : プロパティのインジゲーター

使用例：
  ;;; 関数の説明を削除してみる。
  (defun foo (x) "increment" (1+ x))            => foo
  (get 'foo 'lisp::function-documentation)      => "increment"
  (remprop 'foo 'lisp::function-documentation)  => t
  (get 'foo 'lisp::function-documentation)      => nil


■rename
[       type]: Function
[  arguments]: rename FILENAME &optional NOWARN
[    package]: editor
[    seealso]: rename-buffer , set-buffer-file-name , rename-file
[       file]: buffer.l
[    section]: バッファ
[description]: 
バッファに関連づけられたファイル名を変更します。バッファ名も同時に変更されます。
変更に成功したらnil以外の値を、失敗したらnilを返します。[C-x C-n]

使用例：
  ;;; カレントバッファのファイル名が"c:/foo.baz"に変更されます。
  ;;; 同時に、バッファ名も"foo.baz"になります。
  (rename "c:/foo.baz")


■rename-buffer
[       type]: Function
[  arguments]: rename-buffer BUFFER-NAME &optional BUFFER
[    package]: editor
[    seealso]: rename , buffer-name
[   referred]: rename-file
[       file]: builtin.l
[    section]: バッファ
[description]: 
ファイル名は変えずにバッファ名だけを変更します。


■rename-file
[       type]: Function
[  arguments]: rename-file FILE NEW-NAME &key :if-exists :if-access-denied
[    package]: lisp
[    seealso]: rename , rename-buffer
[   referred]: copy-file , delete-file
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
ファイル名を変更します。
  
  FILE              : 変更前のファイル名を指定します。
  NEW-NAME          : 変更後のファイル名を指定します。
  :if-exists        : ファイルが存在する場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
        :overwrite      上書きします。
        :newer          新しければ上書きします。
  :if-access-denied : アクセスが拒否された場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
        :force          強制的にファイル名の変更を試みます。

変更できたかどうかで戻り値が変わります。

  t   変更に成功
  nil 変更に失敗

使用例：
  (rename-file "C:/xyzzy/test.txt" "C:/xyzzy/test2.txt")
  => t


■rename-pseudo-frame
[       type]: Function
[  arguments]: rename-pseudo-frame NAME
[    package]: editor
[       file]: pframe.l
[    section]: ウィンドウ
[description]: 
現在選択しているフレームの名前を NAME に変更します。


■repeat-backward-search
[       type]: Function
[  arguments]: repeat-backward-search
[    package]: editor
[    seealso]: repeat-forward-search , search-forward-again , re-search-forward-again
[       file]: search.l
[    section]: 検索・正規表現
[description]: 
前回検索した文字列を再度後方検索します。[S-F5]

前回の検索が正規表現によるものであれば正規表現を使って、そうでなければ
そのように実行されます。


■repeat-complex-command
[       type]: Function
[  arguments]: repeat-complex-command SEXP
[    package]: editor
[    seealso]: execute-extended-command
[       file]: cmds.l
[    section]: ミニバッファ
[description]: 
execute-extended-command（いわゆるM-x）でのコマンド実行をそのままの引数
で再度実行します。[ESC p]


■repeat-forward-search
[       type]: Function
[  arguments]: repeat-forward-search
[    package]: editor
[    seealso]: repeat-backward-search , search-forward-again , re-search-forward-again
[       file]: search.l
[    section]: 検索・正規表現
[description]: 
前回検索した文字列を再度前方検索します。[F5]

前回の検索が正規表現によるものであれば正規表現を使って、そうでなければ
そのように実行されます。


■replace
[       type]: Function
[  arguments]: replace SEQUENCE1 SEQUENCE2 &key :start1 :end1 :start2 :end2
[    package]: lisp
[    seealso]: substitute-string
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCE1 を SEQUENCE2 で置換します。元の SEQUENCE は置き換えられます。
SEQUENCE1 の :start1-:end1 の位置に、 SEQUENCE2 の :start2-:end2 を挿入
します。

使用例：
  (setq foo (make-sequence 'string 8 :initial-element #\a))
  => "aaaaaaaa"
  (setq bar (make-sequence 'string 3 :initial-element #\b))
  => "bbb"
  (replace foo bar)
  => "bbbaaaaa"
  (replace foo bar :start1 4 :end1 5)
  => "bbbabaaa"


■replace-buffer
[       type]: Function
[  arguments]: replace-buffer PATTERN REPLACEMENT &key :case-fold :tail :regexp :left-bound :right-bound :once :literal :last-match
[    package]: editor
[    seealso]: replace-string , perform-replace , substitute-string , gresreg , 正規表現の表記
[   referred]: replace-match
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
バッファ中の文字列を検索して置換します。replace-stringもperform-replace
もこれを使って実装されています。

使用例：
 ;;;  英字と漢字の間に空白を１つあける
 (replace-buffer "\\([A-Za-z0-9_]\\) *\\([\X8200-\X9fff\Xe000-\Xfcff]\\)"
    "\\1 \\2" :regexp t)


■replace-match
[       type]: Function
[  arguments]: replace-match STRING &key :literal
[    package]: editor
[    seealso]: replace-buffer , match-data , store-match-data
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
直前の検索結果に基づいて、 STRING にあるメタ文字を解釈しつつ文字列を置き換
えます。 :literal が nil 以外の場合は、メタ文字を意識しません。

メタ文字：
   \0, \&    一致した文字列全体
   \1 〜 \9  正規表現検索での\(\)に対応する文字列

使用例：
  ;;; <!--文字列-->を[文字列]に置き換える場合
  (when (scan-buffer "<!--\\(.+\\)-->" :regexp t)
    (replace-match "[\\1]"))
  => t


■replace-string
[       type]: Function
[  arguments]: replace-string PATTERN REPLACEMENT &optional NOERROR
[    package]: editor
[    seealso]: query-replace , replace-buffer , substitute-string
[   referred]: perform-replace
[       file]: search.l
[    section]: 検索・正規表現
[description]: 
バッファを検索して文字列で置換します。perform-replaceを使って実装されて
います。 [M-r]

  PATTERN     : 置換前文字列です。
  REPLACEMENT : 置換後文字列です。
  NOERROR     : 文字列が見つからないときにエラーを出す？

replace系の関数の系譜：
  replace-string         ：interactiveな関数として宣言されている。
    └perform-replace    ：普通はこれで十分の筈
        └replace-buffer ：いろいろと細かく設定したければこれで行う。

使用例：
  (defun test-proc ()
    (interactive)
    (replace-string "aaa" "xxx"))   ;; aaaをxxxに置換


■require
[       type]: Function
[  arguments]: require MODULE-NAME &optional PATHNAME
[    package]: lisp
[    seealso]: load-library , provide , *modules* , 各種ロード関係の関数の違い
[       file]: evalmacs.l
[    section]: 評価
[description]: 
指定したモジュールを読み込みます。既に読込済みであれば何もしません。

互換性：
  Common Lispにはあり。
  muleにはなさそう。

使用例：
  (require "foreign")


■resolve-shortcut
[       type]: Function
[  arguments]: resolve-shortcut PATHNAME
[    package]: editor
[    seealso]: create-shortcut
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
ショートカットからファイル名を求めます。

  PATHNAME : ショートカットを指定します。

使用例：
  (resolve-shortcut "d:/winnt/profiles/henmi2/personal/my documentsへのショートカット.lnk")
  => "G:/My Documents"


■rest
[       type]: Function
[  arguments]: rest LIST
[    package]: lisp
[    seealso]: cdr
[       file]: evalmacs.l
[    section]: リスト
[description]: 
cdrの別名です。 
全く同じ動きをします。 

使用例： 
  ;;; cdrと同じ動きをする。 
  (cdr '(1 2 3))
  => (2 3)
  (rest '(1 2 3))
  => (2 3)
  (symbol-function 'cdr)
  => #<function: cdr>
  (symbol-function 'rest)
  => #<function: cdr>
 
参考： 
  ;;; evalmacs.lの定義
  (si:*fset 'rest #'cdr)


■restore-window-configuration-register
[       type]: Function
[  arguments]: restore-window-configuration-register R
[    package]: editor
[    seealso]: save-window-configuration-to-register
[       file]: register.l
[    section]: ウィンドウ
[description]: 
レジスタ R に保存したウィンドウ状態に戻します。[C-x r c]
R に window-configuration が入っていないとエラーになります。


■return
[       type]: Macro
[  arguments]: return &optional RESULT
[    package]: lisp
[    seealso]: return-from
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
指定された値でブロックから脱出します。
catchしてくれるブロックがないと例外が発生します。

  (return RESULT) = (return-from nil RESULT)

使用例：
  ;;; ループからの脱出の場合
  (loop (if (yes-or-no-p "quit?") (return 123)))
  => 123

  ;;; ブロックが無いのでcatchできない場合
  (if (yes-or-no-p "quit?") (return 123))
  => `return-from'のキャッチャを参照できません: nil


■return-from
[       type]: Special Form
[  arguments]: return-from NAME [RESULT]
[    package]: lisp
[   referred]: block , return
[       file]: builtin.l
[    section]: 制御構造
[description]: 
ブロックから脱出します。


■revappend
[       type]: Function
[  arguments]: revappend X Y
[    package]: lisp
[    seealso]: nreconc
[       file]: builtin.l
[    section]: リスト
[description]: 
X を反転させて Y を結合したリストを返します。
引数 X は保存されます。

  (revappend x y) == (append (reverse x) y)
  
revappendの方が効率が良いようです。


■reverse
[       type]: Function
[  arguments]: reverse SEQUENCE
[    package]: lisp
[    seealso]: nreverse
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCE を逆順にした新しいシーケンスを作成して返します。
引数 SEQUENCE は保存されます。


■reverse-region
[       type]: Function
[  arguments]: reverse-region FROM TO &optional TEMPORARY
[    package]: editor
[    seealso]: clear-reverse-region
[       file]: builtin.l
[    section]: リージョン
[description]: 
リージョンを反転表示します。
TEMPORARYがnon nilならば、次のキー入力で反転表示が元に戻ります。


■rewind-ime-composition
[       type]: Function
[  arguments]: rewind-ime-composition &optional NODELETE POP
[    package]: editor
[    seealso]: ime-push-composition-string
[       file]: kanji.l
[    section]: 文字列
[description]: 
直前に IME で変換した文字列を非確定状態に戻します。[C-c C-c]
変換直後でなければ、直前に変換した文字列を非確定状態で挿入します。


■rotatef
[       type]: Macro
[  arguments]: rotatef {PLACE}*
[    package]: lisp
[    seealso]: setf , shiftf
[       file]: setf.l
[    section]: 変数と定数
[description]: 
引数として与えられた値の格納場所の内容をローテーションさせます。

        ┌a ┐  ┌b ┐  ┌c ┐
実行前：│ 1│  │ 2│  │ 3│
        └┬┘  └┬┘  └┬┘
      ┌─┘  ┌─┘  ┌─┘
   (*)┘  ┌─┘  ┌─┘  ┌─(*)
          ↓      ↓      ↓
        ┌a ┐  ┌b ┐  ┌c ┐
実行後：│ 2│  │ 3│  │ 1│
        └─┘  └─┘  └─┘
使用例：
  ;;; a b cに数値を入れてrotatefする。
  (setq a 1 b 2 c 3)    => 3
  (list a b c)          => (1 2 3)
  (rotatef a b c)       => 1
  (list a b c)          => (2 3 1)


■round
[       type]: Function
[  arguments]: NUMBER &optional DIVISOR
[    package]: lisp
[    seealso]: floor , ceiling , truncate , fround
[       file]: builtin.l
[    section]: 数値
[description]: 
NUMBERを近い方の整数に丸めます。
ちょうど0.5の場合には偶数方向に丸められます。

使用例： 
  (round 2.5)
  => 2
  (round 2.6)
  => 3
  (round 3.5)
  => 4
  (round -2.5)
  => -2
  (round -2.6)
  => -3
  (multiple-value-list (round 2.5))
  => (2 0.5)


■row-major-aref
[       type]: Function
[  arguments]: row-major-aref ARRAY INDEX
[    package]: lisp
[    seealso]: aref , svref , array-row-major-index
[       file]: builtin.l
[    section]: 配列
[description]: 
ARRAY を一次元の配列とみなしたときに、INDEX 番目になる要素を返します。

使用例:
  (setf x (make-array '(2 3) :initial-contents '((a b c) (d e f))))
  => #2A((a b c) (d e f))
  (row-major-aref x 0)
  => a
  (row-major-aref x 2)
  => c
  (row-major-aref x 3)
  => d


■rplaca
[       type]: Function
[  arguments]: rplaca X Y
[    package]: lisp
[       file]: builtin.l
[    section]: リスト
[description]: 
リスト X の car を Y に置き換えて、置き換えた X を返します。
(progn (setf (car X) Y) X)と同じでしょうか。

使用例：
  ;;; 置き換えてみる。
  (setq g '(a b c)) 
  => (a b c)
  (rplaca (cdr g) 'd)
  => (d c) 
  g
  => (a d c)


■rplacd
[       type]: Function
[  arguments]: rplacd X Y
[    package]: lisp
[       file]: builtin.l
[    section]: リスト
[description]: 
リスト X の cdr を Y に置き換えて、置き換えた X を返します。
(progn (setf (cdr X) Y) X)と同じでしょうか。

使用例：
  ;;; 置き換えてみる。
  (setq x '(a b c)) 
  (rplacd x 'd)
  => (a . d) 
  x
  => (a . d)


■run-console
[       type]: Function
[  arguments]: run-console
[    package]: editor
[       file]: process.l
[    section]: プロセス
[description]: 
xyzzy の外部でコンソールを起動します。
変数 *eshell* または *shell* の値が実行されるコマンドとして使われます。


■run-hook-with-args
[       type]: Function
[  arguments]: run-hook-with-args HOOK &rest ARGS
[    package]: editor
[    seealso]: run-hooks
[   referred]: run-hook-with-args-until-success , run-hook-with-args-while-success
[       file]: builtin.l
[    section]: モード
[description]: 
run-hooksと同じように関数を実行します。run-hooksと異なり引数を
指定できます。


■run-hook-with-args-until-success
[       type]: Function
[  arguments]: run-hook-with-args-until-success HOOK &rest ARGS
[    package]: editor
[    seealso]: run-hook-with-args , run-hook-with-args-while-success
[   referred]: *before-save-buffer-hook* , *find-file-file-not-found-hook* , run-hooks
[       file]: builtin.l
[    section]: モード
[description]: 
run-hooksと同じように関数を実行します。run-hooksと異なり戻り値
がnon-nilになるまで順番に実行します。


■run-hook-with-args-while-success
[       type]: Function
[  arguments]: run-hook-with-args-while-success HOOK &rest ARGS
[    package]: editor
[    seealso]: run-hook-with-args , run-hook-with-args-until-success
[   referred]: *query-kill-buffer-hook* , run-hooks
[       file]: builtin.l
[    section]: モード
[description]: 
run-hooksと同じように関数を実行します。run-hooksと異なり戻り値
がnon-nilの間だけ順番に実行します。


■run-hooks
[       type]: Function
[  arguments]: run-hooks &rest HOOKLIST
[    package]: editor
[    seealso]: run-hook-with-args , run-hook-with-args-until-success , run-hook-with-args-while-success
[   referred]: add-hook
[       file]: builtin.l
[    section]: モード
[description]: 
フック変数を順番に実行します。フック変数の詳細はadd-hookを参照して下さい。

  HOOKLIST : フック変数を指定します。複数個並べて書けます。
             並べて書いた順番に実行します。

フック変数の実行には引数をつけることが出来ません。
どうしてもつけたい場合には、run-hook-with-argsを使いましょう。

使用例：
  ;;; c-mode.l
  (run-hooks 'c-mode-hook)


■safe-caaaar
[       type]: Function
[  arguments]: safe-caaaar X
[    package]: lisp
[    seealso]: safe-car
[       file]: list.l
[    section]: リスト
[description]: 
safe-caaaar を返します。

  (safe-caaaar X) = (safe-car (safe-car (safe-car (safe-car X))))


■safe-caaadr
[       type]: Function
[  arguments]: safe-caaadr X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-caaadr を返します。

  (safe-caaadr X) = (safe-car (safe-car (safe-car (safe-cdr X))))


■safe-caaar
[       type]: Function
[  arguments]: safe-caaar X
[    package]: lisp
[    seealso]: safe-car
[       file]: list.l
[    section]: リスト
[description]: 
safe-caaar を返します。

  (safe-caaar X) = (safe-car (safe-car (safe-car X)))


■safe-caadar
[       type]: Function
[  arguments]: safe-caadar X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-caadar を返します。

  (safe-caadar X) = (safe-car (safe-car (safe-cdr (safe-car X))))


■safe-caaddr
[       type]: Function
[  arguments]: safe-caaddr X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-caaddr を返します。

  (safe-caaddr X) = (safe-car (safe-car (safe-cdr (safe-cdr X))))


■safe-caadr
[       type]: Function
[  arguments]: safe-caadr X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-caadr を返します。

  (safe-caadr X) = (safe-car (safe-car (safe-cdr X)))


■safe-caar
[       type]: Function
[  arguments]: safe-caar X
[    package]: lisp
[    seealso]: safe-car
[       file]: list.l
[    section]: リスト
[description]: 
safe-caar を返します。

  (safe-caar X) = (safe-car (safe-car X))


■safe-cadaar
[       type]: Function
[  arguments]: safe-cadaar X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cadaar を返します。

  (safe-cadaar X) = (safe-car (safe-cdr (safe-car (safe-car X))))


■safe-cadadr
[       type]: Function
[  arguments]: safe-cadadr X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cadadr を返します。

  (safe-cadadr X) = (safe-car (safe-cdr (safe-car (safe-cdr X))))


■safe-cadar
[       type]: Function
[  arguments]: safe-cadar X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cadar を返します。

  (safe-cadar X) = (safe-car (safe-cdr (safe-car X)))


■safe-caddar
[       type]: Function
[  arguments]: safe-caddar X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-caddar を返します。

  (safe-caddar X) = (safe-car (safe-cdr (safe-cdr (safe-car X))))


■safe-cadddr
[       type]: Function
[  arguments]: safe-cadddr X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cadddr を返します。

  (safe-cadddr X) = (safe-car (safe-cdr (safe-cdr (safe-cdr X))))


■safe-caddr
[       type]: Function
[  arguments]: safe-caddr X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-caddr を返します。

  (safe-caddr X) = (safe-car (safe-cdr (safe-cdr X)))


■safe-cadr
[       type]: Function
[  arguments]: safe-cadr X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cadr を返します。

  (safe-cadr X) = (safe-car (safe-cdr X))


■safe-car
[       type]: Function
[  arguments]: safe-car X
[    package]: lisp
[    seealso]: car
[   referred]: safe-caaaar , safe-caaadr , safe-caaar , safe-caadar , safe-caaddr , safe-caadr , safe-caar , safe-cadaar , safe-cadadr , safe-cadar , safe-caddar , safe-cadddr , safe-caddr , safe-cadr , safe-cdaaar , safe-cdaadr , safe-cdaar , safe-cdadar , safe-cdaddr , safe-cdadr , safe-cdar , safe-cddaar , safe-cddadr , safe-cddar , safe-cdddar
[       file]: list.l
[    section]: リスト
[description]: 
(car X) は X が nil か cons でなければエラーになります
しかし safe-car はエラーを発生せずに nil を返します。

使用例：
  ;;; carとsafe-carの違い
  (car "abc")
  => 不正なデータ型です: "abc": cons
  (safe-car "abc")
  => nil


■safe-cdaaar
[       type]: Function
[  arguments]: safe-cdaaar X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cdaaar を返します。

  (safe-cdaaar X) = (safe-cdr (safe-car (safe-car (safe-car X))))


■safe-cdaadr
[       type]: Function
[  arguments]: safe-cdaadr X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cdaadr を返します。

  (safe-cdaadr X) = (safe-cdr (safe-car (safe-car (safe-cdr X))))


■safe-cdaar
[       type]: Function
[  arguments]: safe-cdaar X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cdaar を返します。

  (safe-cdaar X) = (safe-cdr (safe-car (safe-car X)))


■safe-cdadar
[       type]: Function
[  arguments]: safe-cdadar X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cdadar を返します。

  (safe-cdadar X) = (safe-cdr (safe-car (safe-cdr (safe-car X))))


■safe-cdaddr
[       type]: Function
[  arguments]: safe-cdaddr X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cdaddr を返します。

  (safe-cdaddr X) = (safe-cdr (safe-car (safe-cdr (safe-cdr X))))


■safe-cdadr
[       type]: Function
[  arguments]: safe-cdadr X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cdadr を返します。

  (safe-cdadr X) = (safe-cdr (safe-car (safe-cdr X)))


■safe-cdar
[       type]: Function
[  arguments]: safe-cdar X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cdar を返します。

  (safe-cdar X) = (safe-cdr (safe-car X))


■safe-cddaar
[       type]: Function
[  arguments]: safe-cddaar X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cddaar を返します。

  (safe-cddaar X) = (safe-cdr (safe-cdr (safe-car (safe-car X))))


■safe-cddadr
[       type]: Function
[  arguments]: safe-cddadr X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cddadr を返します。

  (safe-cddadr X) = (safe-cdr (safe-cdr (safe-car (safe-cdr X))))


■safe-cddar
[       type]: Function
[  arguments]: safe-cddar X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cddar を返します。

  (safe-cddar X) = (safe-cdr (safe-cdr (safe-car X)))


■safe-cdddar
[       type]: Function
[  arguments]: safe-cdddar X
[    package]: lisp
[    seealso]: safe-car , safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cdddar を返します。

  (safe-cdddar X) = (safe-cdr (safe-cdr (safe-cdr (safe-car X))))


■safe-cddddr
[       type]: Function
[  arguments]: safe-cddddr X
[    package]: lisp
[    seealso]: safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cddddr を返します。

  (safe-cddddr X) = (safe-cdr (safe-cdr (safe-cdr (safe-cdr X))))


■safe-cdddr
[       type]: Function
[  arguments]: safe-cdddr X
[    package]: lisp
[    seealso]: safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cdddr を返します。

  (safe-cdddr X) = (safe-cdr (safe-cdr (safe-cdr X)))


■safe-cddr
[       type]: Function
[  arguments]: safe-cddr X
[    package]: lisp
[    seealso]: safe-cdr
[       file]: list.l
[    section]: リスト
[description]: 
safe-cddr を返します。

  (safe-cddr X) = (safe-cdr (safe-cdr X))


■safe-cdr
[       type]: Function
[  arguments]: safe-cdr X
[    package]: lisp
[    seealso]: cdr
[   referred]: safe-caaadr , safe-caadar , safe-caaddr , safe-caadr , safe-cadaar , safe-cadadr , safe-cadar , safe-caddar , safe-cadddr , safe-caddr , safe-cadr , safe-cdaaar , safe-cdaadr , safe-cdaar , safe-cdadar , safe-cdaddr , safe-cdadr , safe-cdar , safe-cddaar , safe-cddadr , safe-cddar , safe-cdddar , safe-cddddr , safe-cdddr , safe-cddr
[       file]: list.l
[    section]: リスト
[description]: 
(cdr X) は X が nil か cons でなければエラーになります
しかし safe-cdr はエラーを発生せずに nil を返します。


■save-all-buffers
[       type]: Function
[  arguments]: save-all-buffers
[    package]: editor
[    seealso]: save-all-buffers-kill-xyzzy , save-some-buffers
[   referred]: save-buffer
[       file]: files.l
[    section]: ファイルシステム
[description]: 
すべてのバッファを保存します。
ファイル名があるバッファに対しては確認せずに保存します。
ファイル名がないバッファに対しては、ダイアログで保存するファイルを指定させます。


■save-all-buffers-kill-xyzzy
[       type]: Function
[  arguments]: save-all-buffers-kill-xyzzy
[    package]: editor
[    seealso]: save-buffers-kill-xyzzy , kill-xyzzy , save-some-buffers , save-all-buffers
[       file]: files.l
[    section]: ファイルシステム
[description]: 
すべてのバッファを保存して xyzzy を終了します。
save-all-buffers と kill-xyzzy の組み合わせです。


■save-buffer
[       type]: Function
[  arguments]: save-buffer &optional CHAR-ENCODING EOL-CODE
[    package]: editor
[    seealso]: emacs-write-file , write-file , *before-save-buffer-hook* , *after-save-buffer-hook* , *save-buffer-no-filenames-hook* , make-backup-files , buffer-truncated-p , buffer-modified-p , save-all-buffers , save-some-buffers
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
バッファの内容を、バッファに関連付けられたファイルに書き込みます。[C-x C-s]

バッファに変更が無かった場合は何もしません。
バッファに変更があり、関連付けられたファイルがない場合、エラーになります。

  CHAR-ENCODING : エンコーディングを指定します。
  EOL-CODE      : 改行コードを指定します。


■save-buffers-kill-xyzzy
[       type]: Function
[  arguments]: save-buffers-kill-xyzzy &optional VERBOSE
[    package]: editor
[    seealso]: save-all-buffers-kill-xyzzy , kill-xyzzy , save-some-buffers
[       file]: files.l
[    section]: ファイルシステム
[description]: 
開いているバッファを保存して xyzzy を終了します。
save-some-buffers と kill-xyzzy の組み合わせです。

  VERBOSE : non-nil の場合保存するファイルごとにダイアログを表示して確認します。


■save-excursion
[       type]: Special Form
[  arguments]: save-excursion {FORM}*
[    package]: editor
[    seealso]: save-window-excursion , save-restriction , set-goal-column
[       file]: builtin.l
[    section]: ポジション
[description]: 
処理の前後でカレントバッファとポイントを保存します。ウィンドウのレイアウ
トは保存しないので注意してください。

ウィンドウのレイアウトも保存したい場合には、save-window-excursionを使います。


■save-restriction
[       type]: Special Form
[  arguments]: save-restriction {FORM}*
[    package]: editor
[    seealso]: narrow-to-region , save-excursion
[       file]: builtin.l
[    section]: ポジション
[description]: 
narrow-to-regionする前の状態を保存します。ポイントやバッファの位置は保存
しません。ポイントやバッファの位置を保存したい場合には、save-excursionを
使用します。

特定の処理の前後でrestrictionの状態とポイントの両方を保存したい場合には、
以下の様にします。

  ;;; うまくいく書き方
  (save-excursion (save-restriction ... )) 

以下の様に書いてしまった場合、処理の中でrestrictionを掛けると内側の
save-excursionでのポイントの復元がうまくいかないことがあります。注意しま
しょう。

  ;;; うまくいかないことがある書き方
  (save-restriction (save-excursion ... ))

使用例：
    ;;; この時点では narrow-to-region してないとする。
    (save-restriction
      (narrow-to-region FROM-1 TO-1)             ; FROM-1からTO-1に制限する
      (save-restriction
        (narrow-to-region FROM-2 TO-2)           ; FROM-2からTO-2に制限する
        (msgbox "~A ~A" (point-min) (point-max))
      )                                          ; FROM-1からTO-1に制限されている
                                                 ; 状態に戻る
      (msgbox "~A ~A" (point-min) (point-max))
    )                                            ; 制限されなくなる
    (msgbox "~A ~A" (point-min) (point-max))


■save-session
[       type]: Function
[  arguments]: save-session FILENAME &optional NOWARN
[    package]: editor
[    seealso]: load-session
[   referred]: *buffer-info-variable-list* , *default-session-directory* , save-session-dialog
[       file]: session.l
[    section]: バッファ
[description]: 
現在のバッファと各フレームのウィンドウの状態をセッションファイルに保存
します。ただし file-visited でないバッファと save-p が nil なフレーム
は保存されません。 [C-x 6 s]

保存した状態は load-session で復元することができます。

  NOWARN : 指定されたファイルがすでに存在するときの動作
        non-nil   黙って上書きする
        nil       メッセージボックスを表示して確認する


■save-session-dialog
[       type]: Function
[  arguments]: save-session-dialog
[    package]: editor
[    seealso]: save-session
[       file]: session.l
[    section]: バッファ
[description]: 
ダイアログからセッションファイル名を指定してセッションを保存します。
[C-x 6 S]


■save-some-buffers
[       type]: Function
[  arguments]: save-some-buffers &optional VERBOSE (FN #'WRITE-FILE)
[    package]: editor
[    seealso]: save-all-buffers , save-buffers-kill-xyzzy , save-buffer
[   referred]: save-all-buffers-kill-xyzzy
[       file]: files.l
[    section]: ファイルシステム
[description]: 
開いているバッファを保存します。[C-x s]
  VERBOSE : non-nilの場合保存するファイルごとにダイアログを表示して確認します。


■save-window-configuration-to-register
[       type]: Function
[  arguments]: save-window-configuration-to-register R
[    package]: editor
[    seealso]: restore-window-configuration-register , current-window-configuration
[       file]: register.l
[    section]: ウィンドウ
[description]: 
レジスタ R に現在のウィンドウの状態を保存します。[C-x r w]
中身は current-window-configuration で得られるものと同じです。
保存した状態に戻すには restore-window-configuration-register を使います。


■save-window-excursion
[       type]: Special Form
[  arguments]: save-window-excursion {FORM}*
[    package]: editor
[    seealso]: save-excursion , with-selected-window
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
処理の前後でカレントウィンドウとウィンドウのレイアウトの状態を保存します。


■scan-buffer
[       type]: Function
[  arguments]: scan-buffer PATTERN &key :no-dup :case-fold :reverse :tail :regexp :limit :left-bound :right-bound :last-match
[    package]: editor
[    seealso]: match-beginning , match-end , perform-replace , make-marker , skip-chars-forward , 正規表現の表記
[   referred]: :case-fold , :no-dup , :regexp , :reverse , :right-bound , :tail , looking-at , match-data , match-string , store-match-data
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
バッファを検索します。

  PATTERN      : 検索パターンとして、[文字列]、[正規表現]、[コンパイル済
                 み正規表現]の何れかを指定する。
                 コンパイル済み正規表現の場合は :regexp の値は無視する。
                 また :case-fold 指定も無視され、compile-regexp 時の第2
                 引数の指定が用いられる。

  :no-dup      : 検索方向に対して次のポイントからの検索を指定する。
        nil     - 現在のポイントから検索する。
        non-nil - reverse が nil の場合は、次のポイントから検索する。
                  non-nil の場合は、前のポイントから検索する。

  :case-fold   : ASCII 文字の大文字小文字の区別の方法を指定する。
                 PATTERN が[コンパイル済み正規表現]の場合は、:case-fold
                 指定は意味をもたない。
        nil     - 大文字小文字を区別して検索する。
        :smart  - PATTERN に大文字が含まれていない場合、大文字小文字を区
                  別せずに検索する。
        上記以外- 大文字小文字を区別せずに検索する。

  :reverse     : 検索方向を指定する。
        nil     - バッファの末尾に向かって検索する。
        non-nil - バッファの先頭に向かって検索する。

  :tail        : 検索成功後の移動先ポイントをどこにするかを指定する。
        nil     - 検索成功後、マッチ範囲の先頭((match-beginning 0)のポイ
                  ント)に移動する。
                  bar を検索した場合、:tail が nil なら
                      foo bar baz qux quux ...
                          ^ ポイントはここに移動する。
        non-nil - 検索成功後、マッチ範囲の末尾((match-end 0)のポイント)
                  に移動する。
                  bar を検索した場合、:tail が non-nil なら
                     foo bar baz qux quux ...
                            ^ ポイントはここに移動する。

  :regexp      : PATTERN が [正規表現] であることを指定する。
                 PATTERN が[コンパイル済み正規表現]の場合は、:regexp 指
                 定は意味をもたない。
        nil     - PATTERN を[文字列]とみなす。
        non-nil - PATTERN を[正規表現]とみなす。

  :limit       : 検索範囲をポイント位置で制限する。 
                 文字数制限ではない。
        nil     - 制限なし。
        INTEGER - :reverse が nil の場合は、マッチ末尾文字のポイントが
                  INTEGER 未満となる範囲で検索する。non-nil の場合は、
                  マッチ先頭文字のポイントが INTEGER 以上となる範囲で検
                  索する。
        MARKER  - MARKER に設定されたポイントを上記 INTEGER と見なし検索
                  範囲を制限する。
                  MARKER にポイントが設定されていない((marker-point
                   MARKER) が nil)場合、scan-buffer は nil を返す。
        上記以外- type-error が発生される。

  :left-bound  : [文字列]検索時の左側境界マッチ条件を指定する。
                 正規表現検索の場合は無効。
        nil     - 左側境界に関わらずマッチ成立
        :symbol - マッチ範囲左側境界((match-beginning 0)のポイント)が、
                  以下の何れかの条件を満たせばマッチ成立
                    - バッファの先頭である
                    - バッファの末尾である
                  マッチ範囲左側境界のポイント、もしくは、その前のポイン
                  トの文字が、以下の何れかの条件を満たせばマッチ成立
                    - ASCII 文字でない
                    - syntax-table に word,symbol として登録されていない
                      ((syntax-word-p 文字), (syntax-symbol-p 文字) が
                       nil を返す。)
        上記以外- マッチ範囲左側境界((match-beginning 0)のポイント)が、
                  以下の何れかの条件を満たせばマッチ成立
                    - バッファの先頭である
                    - バッファの末尾である
                  マッチ範囲左側境界のポイント、もしくは、その前のポイン
                  トの文字が、以下の何れかの条件を満たせばマッチ成立
                    - ASCII 文字でない
                    - syntax-table に word として登録されていない
                      ((syntax-word-p 文字)がnilを返す。)

  :right-bound : [文字列]検索時の右側境界マッチ条件を指定する。
                 正規表現検索の場合は無効。
        nil     - 右側境界に関わらずマッチ成立
        :symbol - マッチ範囲右側境界((match-end 0)のポイント)が、以下の
                  何れかの条件を満たせばマッチ成立
                    - バッファの先頭である
                    - バッファの末尾である
                  マッチ範囲右側境界のポイント、もしくは、その前のポイン
                  トの文字が、以下の何れかの条件を満たせばマッチ成立
                    - ASCII 文字でない
                    - syntax-table に word,symbol として登録されていない
                      ((syntax-word-p 文字), (syntax-symbol-p 文字) が
                       nil を返す。)
        上記以外- マッチ範囲右側境界((match-end 0)のポイント)が、以下の
                  何れかの条件を満たせばマッチ成立
                    - バッファの先頭である
                    - バッファの末尾である
                  マッチ範囲右側境界のポイント、もしくは、その前のポイン
                  トの文字が、以下の何れかの条件を満たせばマッチ成立
                    - ASCII 文字でない
                    - syntax-table に word として登録されていない
                      ((syntax-word-p 文字) が nil を返す。)

  :last-match  : 使用効果不明
                 (perform-replace) でのみ用いられている。
                 (<last-match> . <last-match-char>) からなる。
                 <last-match> : 直前のscan-buffer成功時の
                     (match-beginning 0)のポイントを指定
                 <last-match-char>: 直前のscan-buffer成功時の
                     (match-end 0)の前のポイントの文字を指定

戻り値は以下のとおりです。

  t    検索に成功
  nil  検索に失敗

使用例：
  (scan-buffer 検索文字列 :regexp t)
  (scan-buffer 検索文字列 :tail t)
  (scan-buffer 検索文字列 :limit 3000)
  (scan-buffer 検索文字列 :reverse t)
  (scan-buffer 検索文字列 :regexp t :no-dup t)


■schar
[       type]: Function
[  arguments]: schar SIMPLE-STRING INDEX
[    package]: lisp
[    seealso]: char , simple-string
[       file]: builtin.l
[    section]: 文字列
[description]: 
SIMPLE-STRINGのINDEX番目の文字を返します。
INDEXは0を基底とします。

使用例：
  ;;; simpleでないstringでscharを使ってみる。
  (setq foo (make-vector 10 :initial-element #\a :element-type 'character :fill-pointer 3))
                        => "aaa"
  (schar foo 0)         => 不正なデータ型です: "aaa": simple-string
  (setq bar "aaa")      => "aaa"
  (schar bar 0)         => #\a


■screen-height
[       type]: Function
[  arguments]: screen-height
[    package]: editor
[    seealso]: screen-width , window-height
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
xyzzyのウィンドウ全体の高さが何行になるのかを返します。


■screen-width
[       type]: Function
[  arguments]: screen-width
[    package]: editor
[    seealso]: screen-height , window-width
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
xyzzyのウィンドウ全体の幅が何桁になるのかを返します。


■scroll-down-both-window
[       type]: Function
[  arguments]: scroll-down-both-window
[    package]: editor
[    seealso]: scroll-up-both-window , scroll-down-other-window
[       file]: cmds.l
[    section]: ウィンドウ
[description]: 
現在のウィンドウと、次のウィンドウを同時に下スクロールします。[S-C-Up]


■scroll-down-other-window
[       type]: Function
[  arguments]: scroll-down-other-window &optional (ARG 1)
[    package]: editor
[    seealso]: scroll-window , scroll-down-both-window
[   referred]: scroll-other-window
[       file]: cmds.l
[    section]: ウィンドウ
[description]: 
次のウィンドウを指定行数分上スクロールします。


■scroll-left
[       type]: Function
[  arguments]: scroll-left &optional ARG
[    package]: editor
[    seealso]: scroll-right , scroll-window-horizontally , scroll-window
[       file]: cmds.l
[    section]: ウィンドウ
[description]: 
ウィンドウを指定桁数分、左にスクロールします。[C-x <]
負の数値を指定すると逆方向にスクロールします。


■scroll-other-window
[       type]: Function
[  arguments]: scroll-other-window &optional ARG
[    package]: editor
[    seealso]: scroll-window , scroll-up-other-window , scroll-down-other-window
[       file]: cmds.l
[    section]: ウィンドウ
[description]: 
次のウィンドウをスクロールします。[ESC C-v]
ARG が nil なら下スクロールし、 non-nil であれば上スクロールします。


■scroll-right
[       type]: Function
[  arguments]: scroll-right &optional ARG
[    package]: editor
[    seealso]: scroll-left , scroll-window-horizontally , scroll-window
[       file]: cmds.l
[    section]: ウィンドウ
[description]: 
ウィンドウを指定桁数分、右にスクロールします。[C-x >]
負の数値を指定すると逆方向にスクロールします。


■scroll-up-both-window
[       type]: Function
[  arguments]: scroll-up-both-window
[    package]: editor
[    seealso]: scroll-down-both-window , scroll-up-other-window
[       file]: cmds.l
[    section]: ウィンドウ
[description]: 
現在のウィンドウと、次のウィンドウを同時に上スクロールします。[S-C-Down]


■scroll-up-other-window
[       type]: Function
[  arguments]: scroll-up-other-window &optional (ARG 1)
[    package]: editor
[    seealso]: scroll-window , scroll-up-both-window , scroll-other-window
[       file]: cmds.l
[    section]: ウィンドウ
[description]: 
次のウィンドウを指定行数分スクロールします。


■scroll-window
[       type]: Function
[  arguments]: scroll-window ARG
[    package]: editor
[    seealso]: scroll-other-window , scroll-window-horizontally
[   referred]: fast-scroll-down , fast-scroll-up , scroll-down-other-window , scroll-left , scroll-right , scroll-up-other-window
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
ウィンドウを指定行数分スクロールします。
負の数値を指定すると逆方向にスクロールします。

使用例：
  ;;; 0.3秒おきに1行ずつスクロールさせる。
  (dotimes (i 4) (scroll-window 1) (sit-for .3))
  => nil


■scroll-window-horizontally
[       type]: Function
[  arguments]: scroll-window-horizontally ARG
[    package]: editor
[    seealso]: scroll-window
[   referred]: scroll-left , scroll-right
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
ウィンドウを指定桁数分、右にスクロールします。
負の数値を指定すると逆方向にスクロールします。


■search-backward
[       type]: Function
[  arguments]: search-backward PATTERN &optional NOERROR
[    package]: editor
[    seealso]: search-forward
[       file]: search.l
[    section]: 検索・正規表現
[description]: 
後方検索をします。[C-r]

  PATTERN: 検索文字列
  NOERROR: 文字列が見つからなかったときの動作を指定します。
        t   nil を返します。
        nil エラーメッセージを出力します。


■search-backward-again
[       type]: Function
[  arguments]: search-backward-again
[    package]: editor
[    seealso]: ed::*last-search-string* , search-forward-again
[       file]: search.l
[    section]: 検索・正規表現
[description]: 
前回の検索語で後方検索します。


■search-forward
[       type]: Function
[  arguments]: search-forward PATTERN &optional NOERROR
[    package]: editor
[    seealso]: search-backward
[       file]: search.l
[    section]: 検索・正規表現
[description]: 
前方検索をします。[C-s]

  PATTERN: 検索文字列
  NOERROR: 文字列が見つからなかったときの動作を指定します。
        t   nil を返します。
        nil エラーメッセージを出力します。


■search-forward-again
[       type]: Function
[  arguments]: search-forward-again
[    package]: editor
[    seealso]: ed::*last-search-string* , search-backward-again , *wrap-search*
[   referred]: repeat-backward-search , repeat-forward-search
[       file]: search.l
[    section]: 検索・正規表現
[description]: 
前回の検索語で前方検索します。


■second
[       type]: Function
[  arguments]: second X
[    package]: lisp
[    seealso]: first , cadr , nth
[       file]: list.l
[    section]: リスト
[description]: 
cadrの別名です。
全く同じ動きをします。

使用例：
  ;;; cadrと同じ動きをする。
  (cadr '(1 2 3))
  => 2
  (second '(1 2 3))
  => 2
  (symbol-function 'cadr)
  => #<lexical-closure: cadr>
  (symbol-function 'second)
  => #<lexical-closure: cadr>
 
参考：
  ;;; list.lの定義
  (si:*fset 'second #'cadr)


■select-buffer
[       type]: Function
[  arguments]: select-buffer
[    package]: editor
[    seealso]: buffer-menu
[   referred]: buffer-selector
[       file]: buffer.l
[    section]: バッファ
[description]: 
バッファを選択するダイアログを表示します。 [F2]
デフォルトではC-p/C-nで上下し、C-mで選択します。
buffer-menuのようなバッファの削除などはできません。
※正確には*std-control-xxx-char*の設定に依ります。


■select-pseudo-frame
[       type]: Function
[  arguments]: select-pseudo-frame FRAME
[    package]: editor
[    seealso]: switch-pseudo-frame , pseudo-frame-selector , find-pseudo-frame , new-pseudo-frame , *select-pseudo-frame-hook*
[   referred]: ed::pseudo-frame
[       file]: pframe.l
[    section]: ウィンドウ
[description]: 
フレーム FRAME を選択します。

FRAME のスロット selected-fn に関数が設定されている場合、それを funcall します。
最後に *select-pseudo-frame-hook* を実行します。


■selected-buffer
[       type]: Function
[  arguments]: selected-buffer
[    package]: editor
[       file]: builtin.l
[    section]: バッファ
[description]: 
現在操作中のバッファ（カレントバッファ）を返します。

使用例：
  (selected-buffer)
  => #<buffer: reference.xml>

互換性：
  この関数はmuleにはありません。
  muleでのcurrent-bufferに相当します。


■selected-pseudo-frame
[       type]: Function
[  arguments]: selected-pseudo-frame
[    package]: editor
[    seealso]: find-pseudo-frame
[       file]: pframe.l
[    section]: ウィンドウ
[description]: 
現在選択しているフレームを返します。


■selected-window
[       type]: Function
[  arguments]: selected-window
[    package]: editor
[    seealso]: set-window
[   referred]: other-window
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
現在アクティブなウィンドウを返します。

使用例：
  ;;; 現在のウィンドウを返してみる。
  (selected-window)
  => #<window 54137832>


■selection-backward-char
[       type]: Function
[  arguments]: selection-backward-char &optional (ARG 1)
[    package]: editor
[       file]: select.l
[    section]: リージョン
[description]: 
後方の文字までをセレクションにします。[S-Left]


■selection-backward-word
[       type]: Function
[  arguments]: selection-backward-word &optional (ARG 1)
[    package]: editor
[    seealso]: selection-forward-word
[       file]: select.l
[    section]: リージョン
[description]: 
後方の単語までをセレクションにします。[S-C-Left]


■selection-beginning-of-buffer
[       type]: Function
[  arguments]: selection-beginning-of-buffer
[    package]: editor
[    seealso]: beginning-of-buffer , selection-end-of-buffer
[       file]: select.l
[    section]: リージョン
[description]: 
カーソル位置からバッファの先頭までをセレクションにします。
beginning-of-bufferと違いマーク自体は変化しません。


■selection-beginning-of-line
[       type]: Function
[  arguments]: selection-beginning-of-line
[    package]: editor
[    seealso]: beginning-of-line , selection-end-of-line
[       file]: select.l
[    section]: リージョン
[description]: 
行頭までをセレクションにします。


■selection-beginning-of-virtual-line
[       type]: Function
[  arguments]: selection-beginning-of-virtual-line
[    package]: editor
[    seealso]: beginning-of-virtual-line , selection-end-of-virtual-line
[       file]: select.l
[    section]: リージョン
[description]: 
表示行の先頭までをセレクションにします。


■selection-end-of-buffer
[       type]: Function
[  arguments]: selection-end-of-buffer
[    package]: editor
[    seealso]: end-of-buffer , selection-beginning-of-buffer
[       file]: select.l
[    section]: リージョン
[description]: 
バッファの最後までをセレクションにします。
end-of-bufferと違いマーク自体は変化しません。


■selection-end-of-line
[       type]: Function
[  arguments]: selection-end-of-line
[    package]: editor
[    seealso]: selection-beginning-of-line , end-of-line
[       file]: select.l
[    section]: リージョン
[description]: 
行末までをセレクションにします。


■selection-end-of-virtual-line
[       type]: Function
[  arguments]: selection-end-of-virtual-line
[    package]: editor
[    seealso]: end-of-virtual-line , selection-beginning-of-virtual-line
[       file]: select.l
[    section]: リージョン
[description]: 
表示行の末尾までをセレクションにします。


■selection-forward-char
[       type]: Function
[  arguments]: selection-forward-char &optional (ARG 1)
[    package]: editor
[       file]: select.l
[    section]: リージョン
[description]: 
前方の文字までをセレクションにします。[S-Right]


■selection-forward-word
[       type]: Function
[  arguments]: selection-forward-word &optional (ARG 1)
[    package]: editor
[    seealso]: selection-backward-word
[       file]: select.l
[    section]: リージョン
[description]: 
前方の単語までをセレクションにします。[S-C-Right]


■selection-mark
[       type]: Function
[  arguments]: selection-mark
[    package]: editor
[    seealso]: selection-point , region-beginning
[   referred]: pre-selection-p
[       file]: builtin.l
[    section]: ポジション
[description]: 
セレクションの開始のポイントを返します。


■selection-next-page
[       type]: Function
[  arguments]: selection-next-page &optional (ARG 1)
[    package]: editor
[    seealso]: selection-previous-page
[       file]: select.l
[    section]: リージョン
[description]: 
次ページまでをセレクションにします。[S-PageDown]


■selection-next-virtual-line
[       type]: Function
[  arguments]: selection-next-virtual-line &optional (ARG 1)
[    package]: editor
[       file]: select.l
[    section]: リージョン
[description]: 
次の表示行までをセレクションにします。[S-Down]


■selection-paragraph
[       type]: Function
[  arguments]: selection-paragraph
[    package]: editor
[       file]: paragrph.l
[    section]: リージョン
[description]: 
段落をセレクションにします。


■selection-point
[       type]: Function
[  arguments]: selection-point
[    package]: editor
[    seealso]: selection-mark , region-end
[   referred]: pre-selection-p
[       file]: builtin.l
[    section]: ポジション
[description]: 
セレクションの終端のポイントを返します。


■selection-previous-page
[       type]: Function
[  arguments]: selection-previous-page &optional (ARG 1)
[    package]: editor
[    seealso]: selection-next-page
[       file]: select.l
[    section]: リージョン
[description]: 
前ページまでをセレクションにします。[S-PageUp]


■selection-previous-virtual-line
[       type]: Function
[  arguments]: selection-previous-virtual-line &optional (ARG 1)
[    package]: editor
[       file]: select.l
[    section]: リージョン
[description]: 
前の表示行までをセレクションにします。[S-Up]


■selection-start-end
[       type]: Macro
[  arguments]: selection-start-end (START END) &body BODY
[    package]: editor
[    seealso]: ed::get-selection-start-end
[       file]: select.l
[    section]: リージョン
[description]: 
セレクションの開始位置、終了位置を取得します。
セレクションが存在すれば、
局所的にSTARTに開始位置、ENDに終了位置をセットされた環境を作り
BODYを順次評価します。

使用例:
  ;;; セレクションに含まれる文字列を返します。
  (selection-start-end (start end)
    (buffer-substring start end))
  =>"foo"


■selection-whole-buffer
[       type]: Function
[  arguments]: selection-whole-buffer
[    package]: editor
[       file]: select.l
[    section]: リージョン
[description]: 
バッファ全体をセレクションにします。


■self-insert-command
[       type]: Function
[  arguments]: self-insert-command &optional (ARG 1)
[    package]: editor
[    seealso]: *auto-fill-hook
[       file]: cmds.l
[    section]: テキスト
[description]: 
最後に入力されたキー *last-command-char* を挿入モードの如何により
insert / overwrite-char します。
括弧が入力された時に強調表示がなされるのもこの中での作用です。


■sequencep
[       type]: Function
[  arguments]: sequencep OBJECT
[    package]: lisp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECT が sequence なら t 、そうでなければnilを返します。


■set
[       type]: Function
[  arguments]: set SYMBOL VALUE
[    package]: lisp
[    seealso]: setq , symbol-value , makunbound
[   referred]: set-default
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
シンボルの値を設定します。
setq と違って局所変数には影響を与えません。

  SYMBOL : シンボル名
  VALUE  : 設定する値

使用例：
  ;;; foo というシンボルを束縛してみる
  (boundp 'foo)         => nil
  (set 'foo 2)          => 2
  (boundp 'foo)         => t
  foo                   => 2
  ;;; 局所変数には影響しない
  (let ((foo 1))
    (set 'foo 2) foo)   => 1


■set-buffer
[       type]: Function
[  arguments]: set-buffer BUFFER
[    package]: editor
[    seealso]: switch-to-buffer , with-set-buffer
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファを選択します。


■set-buffer-alternate-file-name
[       type]: Function
[  arguments]: set-buffer-alternate-file-name NAME &optional BUFFER
[    package]: editor
[    seealso]: get-buffer-alternate-file-name , set-buffer-file-name
[   referred]: get-alternate-file-buffer
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファBUFFERにファイル名の別名NAMEをつけます。set-buffer-file-nameでは、
ありえないパスを指定するとエラーになります。
set-buffer-alternate-file-nameではどのような文字列でも指定可能です。

使用例：
  ; c:/abc/は存在しないパス
  (set-buffer-file-name "c:/abc/def.txt")
  => c:/abc/def.txt
     指定されたパスが見つかりません。 

  ; URLでもなんでも任意の文字列を設定可
  (set-buffer-alternate-file-name "http://www.asahi.com")
  => t

指定した文字列は、バッファのファイル名がnilの場合（つまり、
get-buffer-file-nameの戻り値がnilの場合）に限り、
以下の個所で使用されます

  1)select-bufferで表示されるダイアログのファイル名
  2)mode-line-format/title-bar-formatのファイル名


■set-buffer-colors
[       type]: Function
[  arguments]: set-buffer-colors COLORS &optional BUFFER
[    package]: editor
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファの色を設定します。設定した色は現状のバッファにだけ適用されます。

  COLORS : BGRを表す数値をベクタで指定します。


■set-buffer-eol-code
[       type]: Function
[  arguments]: set-buffer-eol-code CODE &optional BUFFER
[    package]: editor
[    seealso]: *eol-lf* , *eol-crlf* , *eol-cr* , set-buffer-fileio-encoding
[   referred]: buffer-eol-code
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファの改行コードを設定します。
引数として改行コードの種類を表す定数が用意されています。
昔は、set-buffer-newline-codeという名称でしたが、xyzzy 0.2.0.121 からこ
の名前に変更されました。

  CODE：バッファの改行コードの種類を指定します。
        LFの場合        *eol-lf*        0
        CRLFの場合      *eol-crlf*      1
        CRの場合        *eol-cr*        2

使用例：
  ;;; バッファの改行コードをLFに変更する。
  (set-buffer-eol-code *eol-lf*)
  => t

参考：
  Changelogのxyzzy 0.2.0.121を参照のこと


■set-buffer-file-name
[       type]: Function
[  arguments]: set-buffer-file-name FILE-NAME &optional BUFFER
[    package]: editor
[    seealso]: get-buffer-file-name , rename , set-buffer-alternate-file-name
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファと結び付けられているファイルをFILE-NAMEにします。


■set-buffer-fileio-encoding
[       type]: Function
[  arguments]: set-buffer-fileio-encoding CODE &optional BUFFER
[    package]: editor
[    seealso]: buffer-fileio-encoding , *char-encoding-list* , set-buffer-eol-code
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファの文字エンコーディングをCODEにします。設定した文字エンコーディングは
buffer-fileio-encodingで参照することができます。

  CODE   : 文字エンコーディングを指定します。
  BUFFER : 変更するバッファを指定します。

使用例：
  (set-buffer-fileio-encoding *encoding-sjis*)
  (set-buffer-fileio-encoding *encoding-euc-jp*)
  (set-buffer-fileio-encoding *encoding-jis*)
  (set-buffer-fileio-encoding *encoding-utf8*)

参照：
  kanji.l


■set-buffer-fold-type-column
[       type]: Function
[  arguments]: set-buffer-fold-type-column
[    package]: editor
[    seealso]: set-buffer-fold-type-window , set-buffer-fold-type-none
[   referred]: set-buffer-fold-type-column-update
[       file]: window.l
[    section]: バッファ
[description]: 
カレントバッファを指定位置で折り返しします。


■set-buffer-fold-type-column-update
[       type]: Function
[  arguments]: set-buffer-fold-type-column-update
[    package]: editor
[    seealso]: set-buffer-fold-type-column
[       file]: window.l
[    section]: バッファ
[description]: 
カレントバッファが指定位置で折り返しになっているかどうかを返します。

戻り値は以下のとおりです。
  :check  なっている
  nil     なっていない


■set-buffer-fold-type-none
[       type]: Function
[  arguments]: set-buffer-fold-type-none
[    package]: editor
[    seealso]: set-buffer-fold-type-window , set-buffer-fold-type-column
[   referred]: set-buffer-fold-type-none-update
[       file]: window.l
[    section]: バッファ
[description]: 
カレントバッファを折り返しなしにします。


■set-buffer-fold-type-none-update
[       type]: Function
[  arguments]: set-buffer-fold-type-none-update
[    package]: editor
[    seealso]: set-buffer-fold-type-none
[       file]: window.l
[    section]: バッファ
[description]: 
カレントバッファが折り返し無しになっているかどうかを返します。

戻り値は以下のとおりです。
  :check  なっている
  nil     なっていない


■set-buffer-fold-type-window
[       type]: Function
[  arguments]: set-buffer-fold-type-window
[    package]: editor
[    seealso]: set-buffer-fold-type-none , set-buffer-fold-type-column
[   referred]: set-buffer-fold-type-window-update
[       file]: window.l
[    section]: バッファ
[description]: 
カレントバッファをウィンドウ幅で折り返します。


■set-buffer-fold-type-window-update
[       type]: Function
[  arguments]: set-buffer-fold-type-window-update
[    package]: editor
[    seealso]: set-buffer-fold-type-window
[       file]: window.l
[    section]: バッファ
[description]: 
カレントバッファがウィンドウ幅で折り返しになっているかどうかを返します。

戻り値は以下のとおりです。
  :check  なっている
  nil     なっていない


■set-buffer-fold-width
[       type]: Function
[  arguments]: set-buffer-fold-width WIDTH &optional BUFFER
[    package]: editor
[    seealso]: buffer-fold-width
[       file]: builtin.l
[    section]: テキスト
[description]: 
テキストの折り返し方法を制御します。[ツール]-[ローカル設定]-[表示]の"テ
キストの折り返し"と同じで、現在のバッファだけに影響します。

  WIDTH  : 折り返しの方法を指定します。
        nil     折り返しません。
        t       ウィンドウの幅で折り返します。
        数値    折り返し位置を指定します。
  BUFFER : ローカル設定するバッファを指定します。


■set-buffer-modified-p
[       type]: Function
[  arguments]: set-buffer-modified-p FLAG &optional BUFFER
[    package]: editor
[    seealso]: buffer-modified-p , not-modified
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファが変更されたかどうかのフラグを設定します。

  FLAG   : フラグを指定します。
        t       変更されている状態にします。
        nil     変更が存在しない状態にします。
  BUFFER : 対象のバッファ

使用例： 
  ;;; 変更フラグの設定・クリア
  (set-buffer-modified-p t)
  (set-buffer-modified-p nil)


■set-default
[       type]: Function
[  arguments]: set-default SYMBOL VALUE
[    package]: lisp
[    seealso]: setq-default , set
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
この関数は、ただ 1つの symbol と 1 つの value のみを許す点と、その両方を
評価する点とを除き setq-default と同じです (setq-default 参照)。

使用例：
  (set-default (car '(a b c)) 23)
  => 23


■set-default-directory
[       type]: Function
[  arguments]: set-default-directory DIRECTORY &optional BUFFER
[    package]: editor
[    seealso]: default-directory
[   referred]: cd
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
バッファが作業しているディレクトリを変更します。

  DIRECTORY : ディレクトリを指定します。
  BUFFER    : バッファを指定します。
              指定がなければカレントバッファになります。


■set-default-fold-width
[       type]: Function
[  arguments]: set-default-fold-width WIDTH
[    package]: editor
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
テキストの折り返し方法を制御します。[ツール]-[共通設定]-[表示]の"テキス
トの折り返し"と同じで、全体に影響します。

  WIDTH : 折り返しの方法を指定します。
        nil     折り返しません。
        t       ウィンドウの幅で折り返します。
        数値    折り返し位置を指定します。


■set-difference
[       type]: Function
[  arguments]: set-difference LIST1 LIST2 &rest REST &key :test :test-not :key
[    package]: lisp
[    seealso]: nset-difference , union , intersection , set-exclusive-or , ldiff , subsetp
[       file]: list.l
[    section]: リスト
[description]: 
二つのリストの差を返します。
nset-difference と違い引数 LIST1 は保存されます。

使用例：
  (set-difference  '(3 6 9) '(2 4 6 8 10))
  => (9 3)


■set-dispatch-macro-character
[       type]: Function
[  arguments]: set-dispatch-macro-character DISP-CHAR SUB-CHAR FUNCTION &optional READTABLE
[    package]: lisp
[    seealso]: make-dispatch-macro-character , get-dispatch-macro-character
[       file]: builtin.l
[    section]: 入出力
[description]: 
ディスパッチマクロ文字を設定します。
SUB-CHAR は大文字小文字を区別しません。

DISP-CHAR がディスパッチマクロ文字でなければエラーとなります。
また SUB-CHAR に [0-9] は指定できません。


■set-exclusive-or
[       type]: Function
[  arguments]: set-exclusive-or LIST1 LIST2 &rest REST &key :test :test-not :key
[    package]: lisp
[    seealso]: nset-exclusive-or , intersection , union , set-difference , ldiff , subsetp
[       file]: list.l
[    section]: リスト
[description]: 
LIST1 と LIST2 のいずれか一方にのみ含まれる要素のリストを作って返します。
nset-exclusive-or と違い引数 LIST2 は保存されます。

使用例:
  (set-exclusive-or '(1 3 5 7 9) '(2 3 5 7 11))
  => (9 1 11 2)


■set-extended-key-translate-table
[       type]: Function
[  arguments]: set-extended-key-translate-table KEY C
[    package]: editor
[       file]: keyboard.l
[    section]: キーマップ
[description]: 
通常は同時押しができないキーを別のキーに振り向けるテーブルです。

| c-modeでシフトを押しながらTABを押した時に
| インデントしてもらおうと思ったんですが、
| #\TABを#\S-TABにしたらSHIFTは使えませんとのことで。

残念ながらまともな手段では Shift+Tab は使えません。が、まともでない手
段が用意されています。

  (set-extended-key-translate-table exkey-S-tab #\F20)

このようにしておくと、Shift+Tab が押されたときに F20 が押されたふりをするので

  (global-set-key #\F20 'foo)

とすればお望み通り(^^

exkey-... に指定できるのは以下の通り。

  exkey-space
  exkey-S-space
  exkey-C-space
  exkey-S-C-space
  exkey-M-space
  exkey-S-M-space
  exkey-C-M-space
  exkey-S-C-M-space
                   
  exkey-backspace
  exkey-S-backspace
  exkey-C-backspace
  exkey-S-C-backspace
  exkey-M-backspace
  exkey-S-M-backspace
  exkey-C-M-backspace
  exkey-S-C-M-backspace
  
  exkey-tab
  exkey-S-tab
  exkey-C-tab
  exkey-S-C-tab
  
  exkey-return
  exkey-S-return
  exkey-C-return
  exkey-S-C-return
  exkey-M-return
  exkey-S-M-return
  exkey-C-M-return
  exkey-S-C-M-return
  
  exkey-escape
  exkey-S-escape

  exkey-zenkaku
  exkey-S-zenkaku
  exkey-C-zenkaku
  exkey-S-C-zenkaku
  exkey-S-M-zenkaku


■set-file-write-time
[       type]: Function
[  arguments]: set-file-write-time FILENAME UNIVERSAL-TIME
[    package]: lisp
[    seealso]: file-write-time , decode-universal-time , format-date-string
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
ファイルの最終更新日を変更します。

  FILENAME       : ファイル名を指定します。フルパスでなければ
                   (default-directory)からの相対パスになります。
  UNIVERSAL-TIME : 最終更新日をユニバーサルタイム形式で指定します。


■set-fill-column
[       type]: Function
[  arguments]: set-fill-column &optional (COL (CURRENT-COLUMN))
[    package]: editor
[    seealso]: fill-column
[       file]: fill.l
[    section]: ポジション
[description]: 
詰め込み桁数を指定します。[C-x f]
指定された値は、変数 fill-column に代入されます。

  COL : 詰め込み桁数
        引数がない場合は、現在のカーソル位置の桁数を詰め込み桁数に設定し
        ます。


■set-fill-prefix
[       type]: Function
[  arguments]: set-fill-prefix
[    package]: editor
[    seealso]: fill-prefix , auto-fill-mode
[       file]: fill.l
[    section]: その他
[description]: 
行頭からポイントまでをfill prefixに設定します。 [C-x .]
行頭で実行された場合には、fill prefixはクリアされます。auto-fill-mode
では、折り返しが行なわれると行頭にfill prefixが挿入されます。


■set-function-bar-label
[       type]: Function
[  arguments]: set-function-bar-label CHAR LABEL
[    package]: editor
[    seealso]: set-number-of-function-bar-labels
[       file]: builtin.l
[    section]: キーマップ
[description]: 
ファンクションバーのラベルを変更します。

  CHAR  : 各ファンクファンクションバーに対応したキャラクタ
  LABEL : 表示するラベル

使用例
  (global-set-key #\F3 'search-forward-again)
  => t
  (set-function-bar-label #\F3 "次検索")
  => t


■set-goal-column
[       type]: Function
[  arguments]: set-goal-column COLUMN
[    package]: editor
[    seealso]: goal-column
[   referred]: save-excursion
[       file]: builtin.l
[    section]: ポジション
[description]: 
ゴールカラムを設定します。save-excursionしてもgoal-columnが破壊されない
ように使用するぐらいでしょうか。

使用例：
  ;;; goal-columnを大事にして編集してみる。
  (let ((g (goal-column)))
    (save-excursion ... )
    (set-goal-column g))
  => t  


■set-kinsoku-chars
[       type]: Function
[  arguments]: set-kinsoku-chars BOL-CHARS EOL-CHARS &optional BUFFER
[    package]: editor
[    seealso]: kinsoku-bol-chars , kinsoku-eol-chars
[   referred]: kinsoku-extend-limit , kinsoku-mode , kinsoku-shorten-limit
[       file]: builtin.l
[    section]: テキスト
[description]: 
禁則文字をセットします。
[ツール] - [共通設定] - [禁則処理] からでも、設定できます。

  BOL-CHARS: 行頭にきてはいけない文字の集合。
  EOL-CHARS: 行末にきてはいけない文字の集合。
  BUFFER:    nil ならば共通設定として、バッファが指定されれば
             そのバッファに対してローカルに設定。


■set-local-window-flags
[       type]: Function
[  arguments]: set-local-window-flags WINDOW-OR-BUFFER FLAGS ON-OR-OFF
[    package]: editor
[    seealso]: set-window-flags , get-local-window-flags
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
ウィンドウもしくはバッファの各種表示を制御します。
ほぼ全ての項目で、ウィンドウでもバッファでも設定可能です。
バッファの設定 > ウィンドウの設定 > 全体の設定
の順番で指定が優先されます。

 BUFFER-OR-WINDOW : バッファかウィンドウのいずれかを指定します。
 FLAGS            : 下のフラグのどれかを指定します。
        *window-flag-alternate-vscroll-bar* バッファ全体表示できている
                                            場合の垂直スクロールバー
        *window-flag-cursor-line*           行カーソル
        *window-flag-eof*                   EOF
        *window-flag-fold-line*             折り返しライン
        *window-flag-fold-mark*             折り返し
        *window-flag-full-width-space*      全角スペース
        *window-flag-half-width-space*      半角スペース
        *window-flag-hscroll-bar*           水平スクロールバー
        *window-flag-just-inverse*          （詳細不明）
        *window-flag-line-number*           行番号
        *window-flag-mode-line*             モード行
        *window-flag-newline*               改行
        *window-flag-ruler*                 ルーラ
        *window-flag-scrolling*             描画位置の計算でジャンプスクロール
        *window-flag-tab*                   タブ
        *window-flag-vscroll-bar*           垂直スクロールバー
        *window-flag-zenkaku-space*         全角スペース
                                            (*window-flag-full-width-space*と同じ)
 ON-OR-OFF       : 変更後の値を設定します。
        t        フラグをonにします。
        nil      フラグをoffにします。
        それ以外 デフォルトに戻します。

使用例：
  ;;; カレントバッファの行番号を表示しないようにする。
  (set-local-window-flags (selected-buffer)
                          *window-flag-line-number* nil)
  => t


■set-macro-character
[       type]: Function
[  arguments]: set-macro-character CHAR FUNCTION &optional NON-TERMINATING-P READTABLE
[    package]: lisp
[    seealso]: get-macro-character
[       file]: builtin.l
[    section]: 入出力
[description]: 
マクロ文字を設定します。

  CHAR                  マクロ文字にする文字
  FUNCTION              CHAR が読まれたときに呼ばれる関数
  NON-TERMINATING-P     トークンの途中に現れた CHAR をマクロ文字とみなさない
  READTABLE             設定するリードテーブル

使用例：
  (set-macro-character #\? 'read-test)
  (defun read-test (stream ch)
    (list '*question* (read stream)))
  (read-from-string "?a")
  => (*question* a)
  => 2


■set-mark
[       type]: Function
[  arguments]: set-mark &optional POINT
[    package]: editor
[    seealso]: mark , set-mark-command
[       file]: builtin.l
[    section]: ポジション
[description]: 
ポイントの位置にマークを設定します。

  POINT: マークを設定する位置を指定します。
         範囲外の値を指定してもエラーにはならないようです。


■set-mark-command
[       type]: Function
[  arguments]: set-mark-command
[    package]: editor
[    seealso]: set-mark , mark-word , mark-sexp , mark-defun
[   referred]: beginning-of-buffer , end-of-buffer
[       file]: cmds.l
[    section]: ポジション
[description]: 
マークを設定します。[ESC SPC], [C-@]
ビルトイン関数の set-mark を対話に行うためのものです。

使用例：
  ;;; マークを設定してその位置を取得する。
  (set-mark-command)
  => t
  (mark)
  => 2554


■set-marker
[       type]: Function
[  arguments]: set-marker MARKER &optional POINT
[    package]: editor
[    seealso]: point-marker , unset-marker , make-marker , marker-point , goto-marker
[       file]: builtin.l
[    section]: ポジション
[description]: 
マーカーにポジションを設定します。
POINT が nil の場合は現在の位置を設定します。

  POINT : マーカーに設定する位置

使用例：
  (setq m (make-marker))
  => #<marker: *scratch*: ->
  (set-marker m)
  => #<marker: *scratch*: 62>
  (marker-point m)
  => 62


■set-menu
[       type]: Function
[  arguments]: set-menu MENU
[    package]: editor
[    seealso]: use-local-menu , define-menu
[   referred]: create-menu
[       file]: builtin.l
[    section]: メニュー
[description]: 
指定されたメニューをデフォルトのメニューにします。xyzzy上部に常時表示さ
れるようになります。

  MENU : 設定するメニューを指定します。
         メニューが不要ならばnilを指定します。


■set-meta-bit
[       type]: Function
[  arguments]: set-meta-bit CHAR SET
[    package]: editor
[       file]: builtin.l
[    section]: 文字
[description]: 
CHAR を Meta付き、無しの文字に相互変換します。

  SET: non-nil の時、CHAR の Meta付きの文字を返します。
       nil の時、    CHAR の Meta無しの文字を返します。

例:
  (set-meta-bit #\S-C-Right t)
  =>#\S-C-M-Right
  
  (set-meta-bit #\M-S-C-Right nil)
  =>#\S-C-Right


■set-minor-mode-map
[       type]: Function
[  arguments]: set-minor-mode-map KEYMAP &optional BUFFER
[    package]: editor
[    seealso]: unset-minor-mode-map , minor-mode-map
[       file]: builtin.l
[    section]: モード
[description]: 
マイナーモード用のキーマップを設定します。


■set-number-of-function-bar-labels
[       type]: Function
[  arguments]: set-number-of-function-bar-labels N
[    package]: editor
[    seealso]: number-of-function-bar-labels
[   referred]: set-function-bar-label
[       file]: builtin.l
[    section]: その他
[description]: 
ファンクションバーのラベルの数を設定します。指定できる数は、
4/5/8/10/12/15です。
[共通設定] - [表示] - [ファンクションキー] のところでも値を設定できます。


■set-per-device-directory
[       type]: Function
[  arguments]: set-per-device-directory DIRECTORY
[    package]: lisp
[    seealso]: *auto-update-per-device-directory*
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
ドライブ毎のデフォルトのディレクトリを設定します。ドライブ毎のデ
フォルトのディレクトリは、ファイラ等で移動すると毎回更新されます。
更新されたくない場合には、*auto-update-per-device-directory*をnil
に設定します。

使用例：
  (set-per-device-directory "D:/foo/bar")
  (set-per-device-directory "E:/bar/foo")


■set-process-eol-code
[       type]: Function
[  arguments]: set-process-eol-code PROCESS CODE
[    package]: editor
[    seealso]: process-eol-code
[       file]: builtin.l
[    section]: プロセス
[description]: 
PROCESSで処理する場合の改行コードCODEを設定します。


■set-process-filter
[       type]: Function
[  arguments]: set-process-filter PROCESS FILTER
[    package]: editor
[    seealso]: process-filter , set-process-outcode , set-process-incode , set-process-sentinel , process-send-string
[   referred]: make-process
[       file]: builtin.l
[    section]: プロセス
[description]: 
プロセスの出力を加工するためのフィルタを指定します。
プロセスからの入力があるとset-process-filter関数でプロセスと関係づけられた
フィルタ関数が呼ばれます。
フィルタの第一引数はプロセスで第二引数は入力文字列です。
フィルタの戻り値は捨てられるようです。

使用例:
  ;;; プロセスへの出力を試すミニマルではないかも
  (let ((buf (create-new-buffer "hoge")))
    (unwind-protect ;;念の為感が強い
        (progn
           (make-process *eshell* :output buf)
           (set-process-filter (buffer-process buf)
                               (lambda (prc str)
                                 (yes-or-no-p "proc ~S str ~S" prc str)))
           (process-send-string (buffer-process buf)
                                (concat "dir&exit" *shell-ret*))
           (sleep-for 0.9))
      (delete-buffer buf)))


■set-process-incode
[       type]: Function
[  arguments]: set-process-incode PROCESS CODE
[    package]: editor
[    seealso]: set-process-outcode
[   referred]: process-incode , set-process-filter
[       file]: builtin.l
[    section]: プロセス
[description]: 
プロセスからset-process-filterに入力がある場合の文字エンコーディングを指定します。


■set-process-outcode
[       type]: Function
[  arguments]: set-process-outcode PROCESS CODE
[    package]: editor
[    seealso]: set-process-incode
[   referred]: process-outcode , set-process-filter
[       file]: builtin.l
[    section]: プロセス
[description]: 
プロセスに対してsend-process-stringをする場合の文字エンコーディングを指定します。


■set-process-sentinel
[       type]: Function
[  arguments]: set-process-sentinel PROCESS SENTINEL
[    package]: editor
[    seealso]: process-sentinel , set-process-filter
[   referred]: make-process
[       file]: builtin.l
[    section]: プロセス
[description]: 
プロセスが終了する場合に呼ばれる関数（いわゆるSENTINEL）を指定します。


■set-syntax-comment-column
[       type]: Function
[  arguments]: set-syntax-comment-column SYNTAX-TABLE COLUMN
[    package]: editor
[    seealso]: set-syntax-option , set-syntax-start-column-comment , syntax-table , parse-point-syntax
[   referred]: set-syntax-start-c++-comment
[       file]: builtin.l
[    section]: シンタックス
[description]: 
指定された列に#\SPC以外のキャラクタがある場合にコメント行と見な
します。特定のキャラクタだけにしたい場合には、
set-syntax-option を参照して下さい。
  
使用例：
  ;;; cobol-mode.lの定義
  (set-syntax-comment-column *cobol-mode-syntax-table* 6)


■set-syntax-end-c++-comment
[       type]: Function
[  arguments]: set-syntax-end-c++-comment SYNTAX-TABLE CHAR &optional PARSE-SEXP-IGNORE-COMMENT-P
[    package]: editor
[    seealso]: set-syntax-start-c++-comment , syntax-end-c++-comment-p
[   referred]: parse-point-syntax
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARをC++スタイルのコメントの終了文字として規定します。
開始文字と異なり、終了文字は同じ文字を二つ連ねません。

使用例：
  ;;; cc-mode.l
  (set-syntax-end-c++-comment *c++-mode-syntax-table* #\LFD)


■set-syntax-end-comment
[       type]: Function
[  arguments]: set-syntax-end-comment SYNTAX-TABLE CHAR &optional PARSE-SEXP-IGNORE-COMMENT-P MAYBE-COMMENT-END-P
[    package]: editor
[    seealso]: set-syntax-start-comment , syntax-end-comment-p
[   referred]: parse-point-syntax
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARをコメント終了文字として規定します。

使用例：
  ;;; perl.l
  (set-syntax-end-comment *perl-mode-syntax-table* #\LFD)


■set-syntax-end-multi-comment
[       type]: Function
[  arguments]: set-syntax-end-multi-comment SYNTAX-TABLE STRING
[    package]: editor
[    seealso]: set-syntax-start-multi-comment , syntax-start-multi-comment-1-p , syntax-start-multi-comment-2-p
[   referred]: parse-point-syntax , syntax-end-multi-comment-1-p , syntax-end-multi-comment-2-p
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字列STRINGをSYNTAX-TABLEに複数行のコメント終了を表す文字列として規定します。

使用例：
  ;;; c-mode.lの定義
  (set-syntax-end-multi-comment *c-mode-syntax-table* "*/")


■set-syntax-escape
[       type]: Function
[  arguments]: set-syntax-escape SYNTAX-TABLE CHAR
[    package]: editor
[    seealso]: set-syntax-string , syntax-escape-p
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARをエスケープ文字として規定します。
文字列中に限らず次の一文字の構文上の機能を抑制します。

使用例：
  ;;; c-mode.l
  (set-syntax-escape *c-mode-syntax-table* #\\)


■set-syntax-from-char
[       type]: Function
[  arguments]: set-syntax-from-char TO-CHAR FROM-CHAR &optional TO-READTABLE FROM-READTABLE
[    package]: lisp
[       file]: builtin.l
[    section]: マクロ
[description]: 
文字のシンタックスを変更します。
lisp のリーダの挙動が変わります。

  TO-CHAR        : シンタックスを変更する文字
  FROM-CHAR      : 設定するシンタックスを持つ文字
  TO-READTABLE   : 変更するリードテーブル (指定しなければ *readtable*)
  FROM-READTABLE : 変更元のリードテーブル (指定しなければデフォルトのリードテーブル)

使用例：
  ;;; カンマを whitespace として扱うようにしてみる
  (let ((readtab (copy-readtable)))
    (set-syntax-from-char #\, #\SPC readtab *readtable*)
    (let ((*readtable* readtab))
      (read-from-string "(a,b,c)")))
  => (a b c)
  => 7


■set-syntax-junk
[       type]: Function
[  arguments]: set-syntax-junk SYNTAX-TABLE CHAR
[    package]: editor
[    seealso]: syntax-junk-p , skip-syntax-spec-forward
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARをゴミ文字として規定します。
skip-syntax-spec-forward / skip-syntax-spec-backward でゴミ文字をスキッ
プするのに役に立つかもしれません。


■set-syntax-match
[       type]: Function
[  arguments]: set-syntax-match SYNTAX-TABLE OPEN-CHAR CLOSE-CHAR
[    package]: editor
[    seealso]: syntax-open-p , syntax-close-p , skip-syntax-spec-forward , goto-matched-parenthesis , *show-matched-parenthesis*
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字OPEN-CHARとCLOSE-CHARをSYNTAX-TABLEに対応付けのある文字として規定します。

使用例：
  ;;; c-mode.lの定義
  (set-syntax-match *c-mode-syntax-table* #\( #\))
  (set-syntax-match *c-mode-syntax-table* #\{ #\})
  (set-syntax-match *c-mode-syntax-table* #\[ #\])


■set-syntax-math
[       type]: Function
[  arguments]: set-syntax-math SYNTAX-TABLE CHAR
[    package]: editor
[    seealso]: syntax-math-p , skip-syntax-spec-forward
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARを対になった区切り文字として規定します。
Latexの数式モードの区切りに相当します。

使用例：
  ;;; Latex.l
  (set-syntax-math *LaTeX-mode-syntax-table* #\$)


■set-syntax-option
[       type]: Function
[  arguments]: set-syntax-option SYNTAX-TABLE OPTION
[    package]: editor
[    seealso]: set-syntax-comment-column , set-syntax-start-column-comment
[       link]: [xyzzy:07988]
[       file]: builtin.l
[    section]: シンタックス
[description]: 
シンタックスの補助的な設定をします。

  *syntax-option-c-preprocessor* : （詳細不明）
  *syntax-option-indent-c++*     : （詳細不明）
  *syntax-option-indent-java*    : （詳細不明）
  *syntax-option-indent-csharp*  : （詳細不明）
  *syntax-option-column-comment-char* :
        set-syntax-comment-column だけでは、指定カラムに空白以外が来ると
        コメントと見なしますが、特定のキャラクタが現れた場合にだけにした
        い場合に設定します。以下の二つを設定しなければなりません。

        1) set-syntax-option に *syntax-option-comment-column-char* を指定する。
        2) set-syntax-start-column-comment でそのキャラクタを指定する。

使用例：
  ;;; fortran.lの定義
  ;;; 0桁目に'C'か'c'が現れたらその行はコメントと見なす。
  (set-syntax-comment-column fortran-mode-syntax-table 0)
  (set-syntax-option fortran-mode-syntax-table
                     *syntax-option-column-comment-char*)
  (set-syntax-start-column-comment fortran-mode-syntax-table #\C)
  (set-syntax-start-column-comment fortran-mode-syntax-table #\c)

参考：
  [xyzzy:07988]を参照のこと


■set-syntax-punctuation
[       type]: Function
[  arguments]: set-syntax-punctuation SYNTAX-TABLE CHAR
[    package]: editor
[    seealso]: syntax-punctuation-p
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARを句読点文字として規定します。
ほとんど使うことはないでしょう。


■set-syntax-quote
[       type]: Function
[  arguments]: set-syntax-quote SYNTAX-TABLE CHAR
[    package]: editor
[    seealso]: syntax-quote-p , skip-syntax-spec-forward
[       file]: builtin.l
[    section]: シンタックス
[description]: 
SYNTAX-TABLEにCHARをquoteとして規定します。
lispでリストで使う`''(quote)や、マクロで使う``'(backquote) `,'(comma)、
ベクタで使う`#'等があります。シンタックス上では意味付けをすることができ
ますが、どのような違いが出るかは不明。

使用例：
  ; lisp/lispmode.l
  (set-syntax-quote *lisp-mode-syntax-table* #\#)
  (set-syntax-quote *lisp-mode-syntax-table* #\')
  (set-syntax-quote *lisp-mode-syntax-table* #\,)
  (set-syntax-quote *lisp-mode-syntax-table* #\`)


■set-syntax-start-c++-comment
[       type]: Function
[  arguments]: set-syntax-start-c++-comment SYNTAX-TABLE CHAR &optional PARSE-SEXP-IGNORE-COMMENT-P
[    package]: editor
[    seealso]: syntax-c++-comment-p , set-syntax-end-c++-comment , set-syntax-start-comment , set-syntax-start-multi-comment , set-syntax-comment-column , parse-point-syntax
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARをC++スタイルのコメントの開始文字として規定します。
「C++スタイルのコメント」とは同じ文字を二つ連ねる形式のことを指しています。

使用例：
  ;;; cc-mode.l
  (set-syntax-start-c++-comment *c++-mode-syntax-table* #\/)


■set-syntax-start-column-comment
[       type]: Function
[  arguments]: set-syntax-start-column-comment SYNTAX-TABLE CHAR &optional PARSE-SEXP-IGNORE-COMMENT-P
[    package]: editor
[    seealso]: set-syntax-option , set-syntax-comment-column , syntax-start-column-comment-p , parse-point-syntax
[       file]: builtin.l
[    section]: シンタックス
[description]: 
set-syntax-comment-column の補助的な設定をします。
set-syntax-optionに *syntax-option-comment-column-char* を指定した場合に
のコメント開始用のキャラクタを設定します。
詳細は set-syntax-option を参照して下さい。


■set-syntax-start-comment
[       type]: Function
[  arguments]: set-syntax-start-comment SYNTAX-TABLE CHAR &optional PARSE-SEXP-IGNORE-COMMENT-P
[    package]: editor
[    seealso]: set-syntax-end-comment , syntax-start-comment-p , set-syntax-start-c++-comment , set-syntax-start-multi-comment , parse-point-syntax
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARをコメント開始文字として規定します。

使用例：
  ;;; perl.l
  (set-syntax-start-comment *perl-mode-syntax-table* #\#)


■set-syntax-start-multi-comment
[       type]: Function
[  arguments]: set-syntax-start-multi-comment SYNTAX-TABLE STRING
[    package]: editor
[    seealso]: set-syntax-end-multi-comment , syntax-start-multi-comment-1-p , syntax-start-multi-comment-2-p , parse-point-syntax
[   referred]: set-syntax-start-c++-comment , set-syntax-start-comment
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字列STRINGをSYNTAX-TABLEに複数行のコメント開始を表す文字列として規定します。

使用例：
  ;;; c-mode.lの定義
  (set-syntax-start-multi-comment *c-mode-syntax-table* "/*")


■set-syntax-string
[       type]: Function
[  arguments]: set-syntax-string SYNTAX-TABLE CHAR
[    package]: editor
[    seealso]: syntax-string-p , set-syntax-escape , skip-syntax-spec-forward , parse-point-syntax
[       file]: builtin.l
[    section]: シンタックス
[description]: 
SYNTAX-TABLEにCHARを文字列の区切り文字として規定します。ここで指定した文
字で囲まれた領域はリテラルの文字列として色づけされます。

使用例：
  ; | を 文字列の区切り文字とする場合
  (set-syntax-string *user-mode-syntax-table* #\|)


■set-syntax-symbol
[       type]: Function
[  arguments]: set-syntax-symbol SYNTAX-TABLE CHAR
[    package]: editor
[    seealso]: syntax-symbol-p , skip-syntax-spec-forward
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARがSYNTAX-TABLEでシンボル名を構成する文字（単語構成文字は除く）と
して規定します。

使用例：
  ;;; c-mode.lの定義
  (set-syntax-symbol *c-mode-syntax-table* #\_)
  (set-syntax-symbol *c-mode-syntax-table* #\#)


■set-syntax-symbol-prefix
[       type]: Function
[  arguments]: set-syntax-symbol-prefix SYNTAX-TABLE CHAR
[    package]: editor
[    seealso]: syntax-symbol-prefix-p
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字をシンボルの前置子として規定します。

  SYNTAX-TABLE : シンタクッステーブルを指定します。
  CHAR         : 文字を指定します。  

HTMLの`&'(実体参照)や、Perlの`$'(変数)、`@'(配列)、`%'(連想配列)等が
相当するようです。Emacsの構文テーブルには相当するものが無いように思います。

使用例：
  ;;; perl.l
  (set-syntax-symbol-prefix *perl-mode-syntax-table* #\$)
  (set-syntax-symbol-prefix *perl-mode-syntax-table* #\@)
  (set-syntax-symbol-prefix *perl-mode-syntax-table* #\%)


■set-syntax-tag
[       type]: Function
[  arguments]: set-syntax-tag SYNTAX-TABLE OPEN-CHAR CLOSE-CHAR
[    package]: editor
[    seealso]: html-highlight-mode , syntax-open-tag-p , syntax-close-tag-p , skip-syntax-spec-forward
[   referred]: parse-point-syntax
[       file]: builtin.l
[    section]: シンタックス
[description]: 
シンタックステーブルにタグの開始記号と終了記号を設定します。
HTMLやXML系のモードに設定するといいみたいです。
実際に利用する際にはさらに html-highlight-mode をnon-nilにす
る必要があります。

使用例：
  ;;; htmlmode.lでの定義
  (set-syntax-tag *html-mode-syntax-table* #\< #\>)


■set-syntax-whitespace
[       type]: Function
[  arguments]: set-syntax-whitespace SYNTAX-TABLE CHAR
[    package]: editor
[    seealso]: syntax-whitespace-p , skip-white-forward , skip-white-backward , skip-syntax-spec-forward , skip-syntax-spec-backward
[       file]: builtin.l
[    section]: シンタックス
[description]: 
SYNTAX-TABLEにCHARをwhitespaceとして規定します。whitespaceとして規定され
た文字は skip-white-forward / skip-white-backwardでスキップされるように
なります。

使用例：
  ; lisp/lispmode.l
  (set-syntax-whitespace *lisp-mode-syntax-table* #\SPC)
  (set-syntax-whitespace *lisp-mode-syntax-table* #\TAB)
  (set-syntax-whitespace *lisp-mode-syntax-table* #\C-l)
  (set-syntax-whitespace *lisp-mode-syntax-table* #\RET)


■set-syntax-word
[       type]: Function
[  arguments]: set-syntax-word SYNTAX-TABLE CHAR
[    package]: editor
[    seealso]: syntax-word-p , skip-syntax-spec-forward
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字を単語を構成する文字として規定します。
skip-syntax-spec-forward / skip-syntax-spec-backwardに影響します。

  SYNTAX-TABLE : シンタクッステーブルを指定します。
  CHAR         : 文字を指定します。

デフォルトでは#\0 .. #\9, #\A .. #\Z, #\a .. #\z です。
余程特殊でない限り新たに設定する必要は無いでしょう。


■set-tab-columns
[       type]: Function
[  arguments]: set-tab-columns COLUMN &optional BUFFER
[    package]: editor
[    seealso]: tab-columns
[       file]: builtin.l
[    section]: テキスト
[description]: 
タブ幅を設定します。

  COLUMN : タブ幅を指定します。1以上32以下の任意の整数です。
           2のべき乗である必要はありません。
  BUFFER : タブ幅を変更するバッファを指定します。
           指定がなければカレントバッファが対象になります。


■set-text-attribute
[       type]: Function
[  arguments]: set-text-attribute FROM TO TAG &key :foreground :background :bold :underline :strike-out :prefix :extend
[    package]: editor
[    seealso]: modify-text-attributes , find-text-attribute , delete-text-attributes , clear-all-text-attributes , list-text-attributes , find-text-attribute-point
[   referred]: find-text-attribute-if , find-text-attribute-if-not , modify-text-attributes-if , set-text-color
[       file]: builtin.l
[    section]: テキスト
[description]: 
リージョンに色などの属性を付けます。
付けた属性は delete-text-attributes で消せます。
一括して消す場合には、clear-all-text-attributes を使用します。

  FROM          属性を付加する開始位置
  TO            属性を付加する終了位置
  TAG           個々の属性を区別するタグ
  :bold         ボールドで表示するかどうかを
  :underline    下線付きで表示するかどうかを
  :strike-out   取り消し線を表示するかどうか
  :foreground   文字色を整数で指定
  :background   背景色を整数で指定
  :prefix       使い方は不明
  :extend       行末の改行文字以降も変えるかどうか

色の整数について：
  [ツール]-[共通設定]-[フォント]のところにある表示色になります。

  :foreground 0     : 文字色
              1〜15 : 文字1〜文字15
  :background 0     : 背景色
              1〜15 : 背景1〜背景15

  15 より大きい値を指定すると，0〜15 の色が繰り返されます。

使用例：
  ;;; バッファ全体を文字1の色にする。
  (set-text-attribute (point-min) (point-max) 'all :bold t :foreground 1)
  => t
  (delete-text-attributes 'all)
  => t


■set-text-color
[       type]: Function
[  arguments]: set-text-color FROM TO &optional FOREGROUND BACKGROUND CHAR EXTEND-P
[    package]: editor
[    seealso]: set-text-attribute
[   referred]: clear-all-text-colors
[       file]: cmds.l
[    section]: テキスト
[description]: 
指定された領域を装飾します。

  FROM       : 開始位置を指定します。
  TO         : 終了位置を指定します。
  FOREGROUND : 文字の色を番号で指定します。以下を参照
  BACKGROUND : 文字の色を番号で指定します。以下を参照
  CHAR       : （詳細不明）
  EXTEND-P   : （詳細不明）

参考：
  ;;; 番号と色の対応
         R   G   B
       ------------
   0     0   0   0
   1   255   0   0
   2     0 255   0
   3   255 255   0
   4     0   0 255
   5   255   0 255
   6     0 255 255
   7   255 255 255
   8     0   0   0
   9   128   0   0
  10     0 128   0
  11   128 128   0
  12     0   0 128
  13   128   0 128
  14     0 128 128
  15   128 128 128

補足:
  この関数は Version 0.0.0.92 にて obsolete となりました。


■set-variable
[       type]: Function
[  arguments]: set-variable VAR
[    package]: editor
[       file]: cmds.l
[    section]: 変数と定数
[description]: 
変数 VAR をプロンプトから入力した値に設定します。[C-x a]
VAR の値が文字列なら文字列として、それ以外なら S 式として入力を読み取ります。

VAR が boundp でないとエラーになります。


■set-window
[       type]: Function
[  arguments]: set-window WINDOW
[    package]: editor
[    seealso]: selected-window , get-buffer-window , next-window , previous-window
[   referred]: delete-window , with-selected-window
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
ウィンドウを変更します。
selected-window や get-buffer-window で取得したウィンドウに移動します。

  WINDOW：移動先のウィンドウ

使用例：
  ;;; *scratch*が表示されていれば移動する。
  (setq win (get-buffer-window (find-buffer "*scratch*")))
  => #<window 48436204>
  (if win (set-window win))
  => t
  (selected-buffer)
  => #<buffer: *scratch*>


■set-window-configuration
[       type]: Function
[  arguments]: set-window-configuration CONF
[    package]: editor
[    seealso]: current-window-configuration
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
取得しておいたウィンドウの状態に戻します。

  CONF：current-window-configurationで取得したウィンドウの状態


■set-window-flags
[       type]: Function
[  arguments]: set-window-flags FLAGS
[    package]: editor
[    seealso]: get-window-flags , set-local-window-flags
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
ウィンドウ全体もしくはバッファ全体の各種表示を制御します。

 FLAGS : 下記のフラグのビット和を指定します。
        *window-flag-alternate-vscroll-bar* バッファ全体表示できている
                                            場合の垂直スクロールバー
        *window-flag-cursor-line*           行カーソル
        *window-flag-eof*                   EOF
        *window-flag-fold-line*             折り返しライン
        *window-flag-fold-mark*             折り返し
        *window-flag-full-width-space*      全角スペース
        *window-flag-half-width-space*      半角スペース
        *window-flag-hscroll-bar*           水平スクロールバー
        *window-flag-just-inverse*          （詳細不明）
        *window-flag-line-number*           行番号
        *window-flag-mode-line*             モード行
        *window-flag-newline*               改行
        *window-flag-ruler*                 ルーラ
        *window-flag-scrolling*             描画位置の計算でジャンプスクロール
        *window-flag-tab*                   タブ
        *window-flag-vscroll-bar*           垂直スクロールバー
        *window-flag-zenkaku-space*         全角スペース
                                            (*window-flag-full-width-space*と同じ)


■setf
[       type]: Macro
[  arguments]: setf {PLACE NEW-VALUE}*
[    package]: lisp
[    seealso]: setq
[   referred]: aref , make-array , rotatef , svref , vector
[       file]: setf.l
[    section]: 変数と定数
[description]: 
このマクロは、変数にアクセスし、その値を変更するために使われます。従来用
いられてきたsetqよりも汎用的であり、setqと全く置き換えて使用することがで
きます。PLACEは、アクセスしようとするデータオブジェクトのある場所を指し、
NEW-VALUEを評価した値がその場所に書き込まれます。

setfは、いくつでもPLACEやNEW-VALUEの対でも受け付けます。そして、同時にで
はなく、順番に値を割り当てます。つまり、最初の引数の対は、二番目の対が評
価される前に評価され、PLACEによって示される場所に値が書き込まれています。
このように、二番目の引数の対は、最初の対の評価によって割り当てられた値を
使うことが可能です。setfは、最後に評価された引数の対によって割り当てられ
た値、あるいは、まったく引数が与えられなかった場合は、nilを返します。

PLACEの形式は以下のどのようなものも可能です：

(1)変数名(レキシカル変数でもスペシャル変数でもよい)

  (setf hoge 1); 変数hogeに1を代入する
  => 1
  hoge
  => 1

(2)アクセス関数
 * 構造体(構造体名＋変数)

  (defstruct foo a b c); 構造体fooを宣言する
  => #<structure-definition: foo>
  (setf hoge (make-foo)); hogeに空のfoo構造体を代入する(ここのsetfはsetqでもよい)
  => #S(foo a nil b nil c nil)
  (setf (foo-a hoge) 10); hogeのスロットaに10を代入する
  => 10
  hoge
  => #S(foo a 10 b nil c nil)

 * 配列(aref, svref, fill-pointer)

  (setf hoge (make-array 3)); hogeに空のベクタを代入する(ここのsetfはsetqでもよい)
  => #(nil nil nil)
  (setf (aref hoge 1) 5); hogeベクタの2番目の数値を5にする
  => 5
  hoge
  => #(nil 5 nil)

 * リスト(car, cdr, first, rest, etc...)

  (setf hoge '("a" "b" "c"))
  => ("a" "b" "c")
  (setf (car (cdr hoge)) "d")
  => "d"
  hoge
  =>("a" "d" "c")

 * 属性リスト(get, getf, symbol-plist)

  (setf (get 'Japan 'language) "Japanese")
  => "Japanese"
  (setf (get 'Japan 'population) 120000000)
  => 120000000
  (symbol-plist 'Japan)
  => (population 120000000 language "Japanese")

 * その他(symbol-value, gethash, symbol-function, documentation, macro-function)


■setq
[       type]: Special Form
[  arguments]: setq {VAR FORM}*
[    package]: lisp
[    seealso]: setf , psetq
[   referred]: set
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
変数に値を設定します。

  (setq 変数1 値1 変数2 値2 ... 変数N 値N)

上記の様に変数と値の組を任意の数だけ並べることができます。

  (setq foo '(1 2 3)) = (set 'foo '(1 2 3))

使用例：
  ;;; setとsetqで同じことをしてみる。
  (set 'foo '(2 3 4))   => (2 3 4)
  foo                   => (2 3 4)
  (setq foo '(1 2 3))   => (1 2 3)
  foo                   => (1 2 3)


■setq-default
[       type]: Macro
[  arguments]: setq-default VAR VAL
[    package]: editor
[    seealso]: default-value , set-default , make-local-variable , defvar-local
[       file]: misc.l
[    section]: 変数と定数
[description]: 
シンボルがローカルでない場合のデフォルトの値を設定します。

この関数は、各 symbol のデフォルト値を、(それに対応する) value に設定し
ます。(symbol は評価しませんが) value は評価します。最初の value を返し
ます。 

デフォルト値は、固有のバッファローカル値を持たないバッファで見られます。 

カレントバッファで symbol がバッファローカルでない場合、これは (この)カ
レントバッファで setq を行なうのと同じことになります。 symbol がカレント
バッファでバッファローカルである場合、カレントバッファで見える値ではなく、
他のバッファがまだバッファローカルな値を持たない場合にそこで見える値を設
定します。

使用例：
  (make-variable-buffer-local 'local)
  => local
  ;; バッファ foo 中:
  (setq local 'foo)
  => foo
  ;; バッファ bar 中:
  local
  => nil
  (setq-default local 'default)
  => default
  local
  => default
  (setq local 'bar)
  => bar
  ;; バッファ baz 中:
  local
  => default
  ;; バッファ foo 中:
  (setq local 'foo)
  => foo
  (default-value 'local)
  => default


■setup-temp-buffer
[       type]: Function
[  arguments]: setup-temp-buffer BUFFER
[    package]: editor
[    seealso]: buffer-read-only , need-not-save , kept-undo-information , auto-save
[       file]: misc.l
[    section]: バッファ
[description]: 
BUFFER を一時バッファ用に初期化します。
具体的には以下のようにバッファローカル変数を設定します。

  buffer-read-only      -> nil
  need-not-save         -> t
  kept-undo-information -> nil
  auto-save             -> nil


■seventh
[       type]: Function
[  arguments]: seventh X
[    package]: lisp
[    seealso]: nth
[       file]: list.l
[    section]: リスト
[description]: 
list の 7 番目の要素を返します。

  (seventh X) = (nth 6 X)

使用例：
  (seventh '(1 2 3 4 5 6 7 8 9 0))
  => 7


■shell-execute
[       type]: Function
[  arguments]: shell-execute FILENAME &optional DIRECTORY PARAMS
[    package]: editor
[    seealso]: execute-shell-command , make-process
[       file]: builtin.l
[    section]: プロセス
[description]: 
何かを行います。URLであればそれを開き、実行ファイルであれば実行したり、
拡張子に応じてアプリケーションを実行します。

  FILENAME  : 何か？URLもOK？
  DIRECTORY : どこでそれを実行するかを指定します。
        t       (cwd)の返されるディレクトリで実行されるみたいです。
        nil     特に指定がないのでFILENAMEのディレクトリで実行されます。

質問：

  | http://java.sun.com/products/jdk/1.2/docs/api/index.html
  | とかをF3キー一発で開けたらって思ってるんです。

  こんなかんじでどうぞ。

  (defun foo ()
    (interactive)
    (shell-execute "http://java.sun.com/products/jdk/1.2/docs/api/index.html" t))


■shift-region
[       type]: Function
[  arguments]: shift-region START END &optional (COLUMN (TAB-COLUMNS (SELECTED-BUFFER)))
[    package]: editor
[    seealso]: unshift-region
[       file]: region.l
[    section]: リージョン
[description]: 
STARTとENDがある行の範囲をCOLUMN桁だけインデントします。


■shiftf
[       type]: Macro
[  arguments]: shiftf {PLACE}+ NEWVALUE
[    package]: lisp
[    seealso]: rotatef
[       file]: setf.l
[    section]: 変数と定数
[description]: 
引数として与えられた値の格納場所の内容をシフトさせます。
(shiftf a b c)とすると以下のようになります。

        ┌a ┐  ┌b ┐  ┌c ┐
実行前：│ 1│  │ 2│  │ 3│
        └─┘  └┬┘  └┬┘
              ┌─┘  ┌─┘
          ┌─┘  ┌─┘  
          ↓      ↓      
        ┌a ┐  ┌b ┐  ┌c ┐
実行後：│ 2│  │ 3│  │ 3│
        └─┘  └─┘  └─┘


■short-float-p
[       type]: Function
[  arguments]: short-float-p OBJECT
[    package]: lisp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTがshort-floatならt、それ以外ならnilを返します。


■show-command-bar
[       type]: Function
[  arguments]: show-command-bar SYM
[    package]: editor
[    seealso]: hide-command-bar
[       file]: cmdbar.l
[    section]: メニュー
[description]: 
define-command-barで定義したコマンドバーを表示します。


■show-html-help
[       type]: Function
[  arguments]: show-html-help
[    package]: editor
[       file]: winhelp.l
[    section]: その他
[description]: 
カーソル位置の文字列を HTML Help から検索します。
*html-help-path* に設定されたヘルプファイルが使用されます。

*html-help-path* の値は、「共通設定」-「ディレクトリ」-「HTML ヘルプ」-
「COL/CHMファイル」から設定できるみたいです。


■show-tool-bar
[       type]: Function
[  arguments]: show-tool-bar NAME &optional EDGE X Y W
[    package]: editor
[    seealso]: hide-tool-bar
[       file]: builtin.l
[    section]: メニュー
[description]: 
ツールバーNAMEを表示します。EDGE X Y Wを指定することで任意の位置に表示さ
せることが可能です。

  EDGE  :top    上側に表示
        :left   左側に表示
        :right  右側に表示
        :bottom 下側に表示
        nil     非表示
  X     横の位置
  Y     縦の位置
  W     タブバーの場合に左右に表示した場合の横幅を与える。
        ツールバーの場合はnilを与える。

[表示]-[ツールバー]に登録したいのならば、show-tool-barではなく、
define-command-bar/show-command-barを使います。


■show-winhelp
[       type]: Function
[  arguments]: show-winhelp
[    package]: editor
[       file]: winhelp.l
[    section]: その他
[description]: 
カーソル位置の文字列を WinHelp から検索します。[C-F1]
*winhelp-path* に設定されたヘルプファイルが使用されます。


■shrink-window
[       type]: Function
[  arguments]: shrink-window &optional (ARG 1)
[    package]: editor
[    seealso]: shrink-window-horizontally , enlarge-window
[       file]: window.l
[    section]: ウィンドウ
[description]: 
カーソルのあるウィンドウの高さを小さくします。  [C-x C-z]


■shrink-window-horizontally
[       type]: Function
[  arguments]: shrink-window-horizontally &optional (ARG 1)
[    package]: editor
[    seealso]: enlarge-window-horizontally , shrink-window
[    section]: ウィンドウ
[description]: 
カーソルのあるウィンドウの幅を小さくします。[C-x {]

使用例：
  ;;; listerのマージンからウィンドウの幅を引く場合
  (shrink-window-horizontally (- (window-width) *lister-margin*))


■si:*activate-toplevel
[       type]: Function
[  arguments]: *activate-toplevel
[    package]: system
[       file]: builtin.l
[    section]: その他
[description]: 
xyzzyを他のウィンドウの最前面に表示します。


■si:*builtin-function-p
[       type]: Function
[  arguments]: *builtin-function-p OBJECT
[    package]: system
[       file]: builtin.l
[    section]: データ型
[description]: 
オブジェクトがビルトイン関数かどうかを調べます。

使用例：
  ;;; carを調べてみる。
  (si:*builtin-function-p #'car)
  => t


■si:*load-library
[       type]: Function
[  arguments]: *load-library FILENAME &key :no-suffix :if-does-not-exist :no-message
[    package]: system
[    seealso]: *load-path* , load-library
[       file]: builtin.l
[    section]: 評価
[description]: 
ライブラリをロードします。普通は load-library でいいと思いますが、
どんなときにsi:*load-libraryを使うのでしょうか？

  :no-suffix         : non-nil なら指定されたファイル名をそのままロードする。
                       nil なら *load-path* を考慮する。
  :if-does-not-exist : :no-suffix が nil でファイルが存在しない場合、
                       :error ならエラー、それ以外なら nil を返す。
  :no-message        : non-nil ならロード中のメッセージを出さない。


■si:*paste-hook*
[       type]: Variable
[    package]: system
[    seealso]: paste-from-clipboard
[    section]: 変数と定数
[description]: 
クリップボードから貼り付けるときに実行されます。


■si:*set-readtable-case
[       type]: Function
[  arguments]: *set-readtable-case READTABLE CASE
[    package]: system
[    seealso]: readtable-case , *readtable*
[       file]: builtin.l
[    section]: 入出力
[description]: 
READTABLE の case sensitivity を CASE に設定します。


■si:*stream-line-number
[       type]: Misc
[  arguments]: *stream-line-number &optional STREAM
[    package]: system
[       file]: builtin.l
[    section]: 入出力
[description]: 
（詳細不明）
(si:*stream-line-number *standard-input*)


■si:base64-decode
[       type]: Function
[  arguments]: base64-decode INPUT-STRING-OR-STREAM &optional OUTPUT-STREAM FOLD-WIDTH
[    package]: system
[    seealso]: si:base64-encode
[   referred]: base64-decode-region-to-file
[       file]: builtin.l
[    section]: その他
[description]: 
Base64でデコードします。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力のストリームを指定します。
        nil     デコードの結果はbase64-decodeの戻り値となります。
        nil以外 デコードの結果はOUTPUT-STREAMに出力されます。

使用例：
  (si:base64-decode "gtmCsILZgrA=")
  => "ほげほげ"


■si:base64-encode
[       type]: Function
[  arguments]: base64-encode INPUT-STRING-OR-STREAM &optional OUTPUT-STREAM
[    package]: system
[    seealso]: si:base64-decode
[   referred]: base64-decode-region
[       file]: builtin.l
[    section]: その他
[description]: 
Base64エンコードします。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力のストリームを指定します。
        nil     エンコードの結果はbase64-encodeの戻り値となります。
        nil以外 エンコードの結果はOUTPUT-STREAMに出力されます。

使用例：  
  (si:base64-encode "ほげほげ")
  => "gtmCsILZgrA="


■si:canonicalize-type
[       type]: Function
[  arguments]: canonicalize-type TYPE
[    package]: system
[    seealso]: deftype , typep
[       file]: typespec.l
[    section]: データ型
[description]: 
deftype で宣言されたデータ型 TYPE を展開し、標準の型に直します。

たとえば typep は標準の型しか処理しないため、
deftype で宣言された型を使いたい場合にはこの関数で処理する必要があります。

使用例:
  (si:canonicalize-type '(mod 5))
  => (integer 0 4)


■si:closure-variable
[       type]: Function
[  arguments]: si:closure-variable CLOSURE
[    package]: system
[   referred]: lambda
[       file]: builtin.l
[    section]: その他
[description]: 
クロージャの中身を覗くための関数です。

  CLOSURE : レキシカルクロージャもしくは関数定義に
            レキシカルクロージャを持つシンボルを指定します。

以下の関数でクロージャを参照することが可能です。

  si:closure-variable closure
  si:closure-function closure
  si:closure-frame closure
  si:closure-body closure

使用例：
  (setq foo (let ((x 3)) #'(lambda () (incf x) x)))
  => #<lexical-closure: (anonymous)>
  (funcall foo)
  => 4
  (funcall foo)
  => 5
  (si:closure-variable foo)
  => ((x . 5))


■si:dump-image-path
[       type]: Function
[  arguments]: dump-image-path
[    package]: system
[    seealso]: dump-xyzzy
[       file]: builtin.l
[    section]: システム
[description]: 
読み込んだダンプファイルのパスを返します。

使用例：
  (si:dump-image-path)
  => "C:/Program Files/xyzzy/xyzzy.w2k"


■si:getenv
[       type]: Function
[  arguments]: getenv VARIABLE
[    package]: system
[    seealso]: user-name , machine-name
[   referred]: os-platform
[       file]: builtin.l
[    section]: システム
[description]: 
環境変数の値を取り出します。

  VARIABLE：環境変数名

使用例：
  ;;; 環境変数PATHを取り出して、個々のPATHに分割する。
  (split-string (si:getenv "PATH") #\;)
  => ("c:\\usr\\local\\bin" "C:\\WINNT\\system32" "C:\\WINNT" ...)


■si:make-chunk
[       type]: Function
[  arguments]: make-chunk TYPE SIZE &optional SOURCE OFFSET
[    package]: system
[    seealso]: チャンクの概要 , si:make-string-chunk , si:unpack-string
[       file]: builtin.l
[    section]: チャンク
[description]: 
チャンクを作成します。チャンクとは外部とのやりとりをするための領域で、
外部DLLの呼び出しをする場合等に使用します。C言語的にはchar[]に相当するよ
うに思います。

  TYPE      : チャンクの型です。現状では使用していないようです。
  SIZE      : チャンクの長さです。
  SRC-CHUNK : 作成するチャンクの元ネタとなるチャンクです。
  OFFSET    : 作成するチャンクの元ネタとなるチャンクの開始位置です。

SRC-CHUNKとOFFSETの組み合わせでチャンクに関連付けされるメモリの取り方が
変わるようです。他のチャンクの内容を使用したい場合等にはを付けましょう。

  ┏━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━┓  
  ┃                  ┃OFFSET                                            ┃  
  ┃                  ┠────────────┬────────────┨  
  ┃                  ┃指定有                  │nil                     ┃  
  ┣━━━━━┯━━━╋━━━━━━━━━━━━┿━━━━━━━━━━━━┫  
  ┃SRC-CHUNK │指定有┃SRC-CHUNK + OFFSETを参照│SRC-CHUNKを共有         ┃  
  ┃          ├───╂────────────┼────────────┨  
  ┃          │nil   ┃OFFSETのアドレスを参照  │新しいメモリを確保      ┃  
  ┗━━━━━┷━━━┻━━━━━━━━━━━━┷━━━━━━━━━━━━┛  

SRC-CHUNK が nil で OFFSET が指定されていた場合には、 OFFSET をアドレス
と見なすのが特殊です。

補足説明：
  si:make-chunkはDLLを呼び出すとき、C言語に渡せるメモリ割り当てを行いま
  す。例えば以下のC言語のコードは
  ┌───────────────────────────────────┐
  │char buf[300];                                                        │
  │DWORD rc = GetCurrentDirectory(300, buf);                             │
  └───────────────────────────────────┘
  xyzzy lispで書くと、以下のようになります。
  ┌───────────────────────────────────┐
  │(let ((s (si:make-chunk nil 300))) ; C言語互換メモリの割り当て        │
  │   (GetCurrentDirectory 300 s)     ; define-dll-entryで定義しておく事 │
  │   (si:unpack-string s 0))         ; lispの文字列に変換               │
  └───────────────────────────────────┘


■si:make-string-chunk
[       type]: Function
[  arguments]: make-string-chunk STRING
[    package]: system
[    seealso]: si:make-chunk
[       file]: builtin.l
[    section]: チャンク
[description]: 
引数に指定された文字列の内容がコピーされたチャンクを作成します。

使用例：
  ;;; WIN32APIのMessageBoxを使ってみる。
  (let ((s (si:make-string-chunk "hello"))
        (r (si:make-string-chunk "title")))
    (MessageBox 0 s r MB_OK))     ; define-dll-entryで定義する事


■si:md5
[       type]: Function
[  arguments]: md5 INPUT-STRING-OR-STREAM
[    package]: system
[       file]: builtin.l
[    section]: その他
[description]: 
MD5ハッシュ値を得ます。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。

使用例：  
  (si:md5 "ほげほげ")
  => "11e100e3eb6e6171d9681ba6641794e3"


■si:quoted-printable-decode
[       type]: Function
[  arguments]: quoted-printable-decode INPUT-STRING-OR-STREAM &optional OUTPUT-STREAM UNDERSCORE-TO-SPACE
[    package]: system
[   referred]: quoted-printable-decode-region , quoted-printable-decode-region-to-file
[       file]: builtin.l
[    section]: その他
[description]: 
Quoted-Printableデコードします。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力のストリームを指定します。
        nil     デコードの結果はquoted-printable-decodeの戻り値となります。
        nil以外 デコードの結果はOUTPUT-STREAMに出力されます。


■si:system-root
[       type]: Function
[  arguments]: system-root
[    package]: system
[    seealso]: user-homedir-pathname
[   referred]: user-config-path
[       file]: builtin.l
[    section]: システム
[description]: 
xyzzyがインストールされているパスを返します。

※userパッケージもeditorパッケージもsystemをuse-packageしていないので、
  呼び出すときはsi:を付けて、(si:system-root)としなければいけません。

使用例：
  (load (merge-pathnames "lisp/henmi/foo.l" (si:system-root)))


■si:unpack-string
[       type]: Function
[  arguments]: unpack-string CHUNK OFFSET SIZE &optional ZERO-TERMINATING-P
[    package]: system
[    seealso]: si:make-chunk , チャンクの概要
[       file]: builtin.l
[    section]: チャンク
[description]: 
チャンクをlispの文字列に変換します。

  CHUNK              : make-chunkで作られたチャンク
  OFFSET             : 文字列化する位置を指定します。
  SIZE               : OFFSETの位置から文字列化する長さを指定します。
  ZERO-TERMINATING-P : （詳細不明）


■si:uudecode
[       type]: Function
[  arguments]: uudecode INPUT-STRING-OR-STREAM &optional OUTPUT-STREAM
[    package]: system
[    seealso]: si:uuencode
[   referred]: uudecode-region , uudecode-region-to-file
[       file]: builtin.l
[    section]: その他
[description]: 
uudecodeします。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力のストリームを指定します。
        nil     デコードの結果はuudecodeの戻り値となります。
        nil以外 デコードの結果はOUTPUT-STREAMに出力されます。


■si:uuencode
[       type]: Function
[  arguments]: uuencode INPUT-STRING-OR-STREAM &optional OUTPUT-STREAM
[    package]: system
[    seealso]: si:uudecode
[       file]: builtin.l
[    section]: その他
[description]: 
uuencodeします。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力のストリームを指定します。
        nil     エンコードの結果はuuencodeの戻り値となります。
        nil以外 エンコードの結果はOUTPUT-STREAMに出力されます。


■si:www-url-decode
[       type]: Function
[  arguments]: www-url-decode INPUT-STRING-OR-STREAM &optional OUTPUT-STREAM
[    package]: system
[    seealso]: si:www-url-encode
[       file]: builtin.l
[    section]: その他
[description]: 
URL デコードを行います。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力ストリームです。
                           t を指定した場合は標準出力へ出力します。
                           省略もしくは nil を指定すると戻り値になります。

使用例:
  (si:www-url-decode "%82%D9%82%B0%82%D9%82%B0" nil)
  =>"ほげほげ"

補足:
  xyzzy 0.2.2.233 では builtin.l 中の引数の記述が間違っています。
  0.2.2.234 で修正されました。


■si:www-url-encode
[       type]: Function
[  arguments]: www-url-encode INPUT-STRING-OR-STREAM &optional OUTPUT-STREAM LITERAL-CHARS
[    package]: system
[    seealso]: si:www-url-decode
[       file]: builtin.l
[    section]: その他
[description]: 
RFC1738 に基づき文字列の URL エンコードを行います。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力ストリームです。
                           t を指定した場合は標準出力へ出力します。
                           省略もしくは nil を指定すると戻り値になります。
  LITERAL-CHARS          : エンコードしない文字群を指定します。
     t                       すべての文字をエンコードする
     nil                     "-A-Za-z0-9$_.+!*'(|),"と同値

使用例:
  ; 標準では Shift_JIS としてエンコード
  (si:www-url-encode "かめ")
  =>"%82%A9%82%DF"
  
  ; EUC-JP としてエンコード
  (si:www-url-encode (map-internal-to-euc "かめ"))
  =>"%A4%AB%A4%E1"
  
  ; 変換しない文字群を明示する
  (si:www-url-encode "www-url-encode" nil "0-9A-Za-z")
  =>"www%2Durl%2Dencode"

補足:
  RFC1738は現在RFC3986によって更新されています。
  RFC3986で定義されている unreserved な文字の種類は "0-9A-Za-z---._~" です。

  xyzzy 0.2.2.233 では builtin.l 中の引数の記述が間違っています。
  0.2.2.234 で修正されました。


■signal-process
[       type]: Function
[  arguments]: signal-process PROCESS
[    package]: editor
[    seealso]: kill-process , process-exit-code
[       file]: builtin.l
[    section]: プロセス
[description]: 
指定されたプロセスPROCESSにシグナルを送ります。
※SIGINT?


■signum
[       type]: Function
[  arguments]: signum NUMBER
[    package]: lisp
[       file]: builtin.l
[    section]: 数値
[description]: 
数値の符号を返します。
引数が複素数の場合は偏角が等しく絶対値が 1 の複素数を返します

使用例：
  (signum 12)
  => 1
  (signum 0)
  => 0
  (signum -5.0)
  =>-1.0
  (signum (complex 1 1))
  =>#C(0.7071068 0.7071068)


■simple-string
[       type]: Misc
[    package]: lisp
[    seealso]: simple-string-p , schar
[    section]: データ型
[description]: 
simple-string とはシンプルな文字列のことを指します。
共有可能でなく、フィルポインタを持たず、サイズ変更不可能な文字列のことで
す。formatやconcatを使って文字列を操作する場合にはsimple-stringのままです。

使用例：
  ;;; simple-stringの場合
  (type-of "abc") 
  => simple-string


■simple-string-p
[       type]: Function
[  arguments]: simple-string-p OBJECT
[    package]: lisp
[    seealso]: simple-string
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTがsimple-stringならt、それ以外ならnilを返します。

使用例：
  ;;; make-vectorを使ってsimple-stringでないstringを作ります。
  (setq var1 (make-vector 10 :element-type 'character)
        var2 (make-vector 10 :element-type 'character :fill-pointer 0))
  => ""
  (type-of var1)                => simple-string
  (type-of var2)                => string
  (simple-string-p var1)        => t
  (simple-string-p var2)        => nil


■simple-vector-p
[       type]: Function
[  arguments]: simple-vector-p OBJECT
[    package]: lisp
[    seealso]: vectorp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTがsimple-vectorならt、それ以外ならnilを返します。


■sin
[       type]: Function
[  arguments]: sin RADIANS
[    package]: lisp
[       file]: builtin.l
[    section]: 数値
[description]: 
正弦関数の値を返します。


■single-float-p
[       type]: Function
[  arguments]: single-float-p OBJECT
[    package]: lisp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTがsingle-floatならt、それ以外ならnilを返します。


■sinh
[       type]: Function
[  arguments]: sinh Z
[    package]: lisp
[       file]: number.l
[    section]: 数値
[description]: 
双曲線正弦関数を計算します。 


■sit-for
[       type]: Function
[  arguments]: sit-for TIMEOUT &optional NO-REDRAW
[    package]: editor
[    seealso]: sleep-for , do-events , refresh-screen
[       file]: builtin.l
[    section]: 日付・時間
[description]: 
指定された秒数停止します。途中でキー入力があれば直ぐに再開します。

  TIMEOUT   : 停止する秒数を指定します。
  NO-REDRAW : 再開後に画面を再描画するかどうかを指定します。


■sixth
[       type]: Function
[  arguments]: sixth X
[    package]: lisp
[    seealso]: nth
[       file]: list.l
[    section]: リスト
[description]: 
list の 6 番目の要素を返します。

  (sixth X) = (nth 5 X)

使用例：
  (sixth '(1 2 3 4 5 6 7 8 9 0))
  => 6


■skip-chars-backward
[       type]: Function
[  arguments]: skip-chars-backward CHARS
[    package]: editor
[    seealso]: skip-chars-forward , skip-syntax-spec-backward
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
skip-chars-forwardの後ろ向きのものです。


■skip-chars-forward
[       type]: Function
[  arguments]: skip-chars-forward CHARS
[    package]: editor
[    seealso]: skip-chars-backward , skip-syntax-spec-forward
[   referred]: scan-buffer
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
指定された文字群を前方方向にスキップします。

  CHARS : スキップする文字群を指定します。

skip-syntax-spec-forwardも似た動作をしますが、これはバッファのシンタック
ステーブルを見てスキップする文字を判断します。目的がはっきりしていれば、
skip-chars-forwardを使用しましょう。

使用例：
  ;;; 半角空白とタブ文字をスキップします。
  (skip-chars-forward " \t")


■skip-syntax-spec-backward
[       type]: Function
[  arguments]: skip-syntax-spec-backward SYNTAX-SPEC
[    package]: editor
[    seealso]: skip-syntax-spec-forward , skip-chars-backward , skip-white-backward
[   referred]: set-syntax-whitespace
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
skip-syntax-spec-forwardの後ろ向きのものです。


■skip-syntax-spec-forward
[       type]: Function
[  arguments]: skip-syntax-spec-forward SYNTAX-SPEC
[    package]: editor
[    seealso]: skip-syntax-spec-backward , skip-chars-forward , skip-white-forward , skip-token
[   referred]: set-syntax-junk , set-syntax-match , set-syntax-math , set-syntax-quote , set-syntax-string , set-syntax-symbol , set-syntax-tag , set-syntax-whitespace , set-syntax-word
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
シンタックステーブルのカテゴリ基づいて文字を前方方向にスキップします。

skip-syntax-spec-(for|back)ward は、シンタックステーブルで指定
される文字のカテゴリに基づいて、指定されたカテゴリに属する文字
をスキップする関数です。カテゴリを表す文字は以下の通りです(7 割
ぐらいは Emacs と互換性あり)。

;  ' '(スペース)  空白文字
;  .              記号
;  (              開き括弧
;  )              閉じ括弧
;  $              TeX の $
;  "              文字列の区切り
;  <             1 文字コメントの開始
;  >             1 文字コメントの終了
;  /              C++ の // コメントの終了
;  \              エスケープ文字
;  '              単独で現れたときは記号、シンボルに隣接している場合はシンボル
;  _              シンボルを構成する文字
;  w              単語を構成する文字
;  k              いわゆる半角カナ
;  j              漢字
;  x              ゴミ文字
;  {              タグの開始
;  }              タグの終了

最初に '^' を指定すると、指定したカテゴリ以外という意味になりま
す(正規表現の[^...]と同じ)。カレントバッファのシンタックステー
ブルに基づくので、バッファのモードによって動きが変わってきます。
ちなみに、単語を構成する文字は一般に英数字で、シンボルを構成す
る文字は単語を構成する文字以外で識別子に使えそうな文字という意
味です。

文字の並びには意味はありません。"w_" と"_w" は同じものを意味します。

使用例：
  ;;; ワードの区切りに移動・英字
  (skip-syntax-spec-forward "w_")

  ;;; ワードの区切りに移動・漢字
  (skip-syntax-spec-forward "jk_")


■skip-token
[       type]: Function
[  arguments]: skip-token
[    package]: editor
[    seealso]: skip-syntax-spec-forward
[       file]: builtin.l
[    section]: ポジション
[description]: 
多分シンボル構成文字と単語構成文字をスキップします。
（詳細不明）


■skip-white-backward
[       type]: Function
[  arguments]: skip-white-backward
[    package]: editor
[    seealso]: skip-white-forward , skip-syntax-spec-backward
[   referred]: set-syntax-whitespace
[       file]: builtin.l
[    section]: ポジション
[description]: 
空白文字を後方にスキップします。
シンタックステーブル上でwhitespaceとして規定されている文字を後方に
スキップします。他にも影響する要素があるようですが詳細は不明。


■skip-white-forward
[       type]: Function
[  arguments]: skip-white-forward
[    package]: editor
[    seealso]: skip-white-backward , skip-syntax-spec-forward
[   referred]: set-syntax-whitespace
[       file]: builtin.l
[    section]: ポジション
[description]: 
空白文字を前方にスキップします
シンタックステーブル上でwhitespaceとして規定されている文字を前方に
スキップします。他にも影響する要素があるようですが詳細は不明。


■sleep-for
[       type]: Function
[  arguments]: sleep-for TIMEOUT
[    package]: editor
[    seealso]: sit-for , refresh-screen
[   referred]: do-events
[       file]: builtin.l
[    section]: 日付・時間
[description]: 
指定された秒数停止します。途中でキー入力があっても直ぐには再開しません。

  TIMEOUT   : 停止する秒数を指定します。


■smart-indentation
[       type]: Function
[  arguments]: smart-indentation COLUMN
[    package]: editor
[    seealso]: *smart-indentation* , indent-to
[       file]: cmds.l
[    section]: テキスト
[description]: 
行頭からcolumn文字インデントします。
*smart-indentation*がtの時は適度にサボったりするみたいです。


■software-type
[       type]: Function
[  arguments]: software-type
[    package]: lisp
[       file]: builtin.l
[    section]: システム
[description]: 
ソフト名を返します。

使用例：  
  (software-type)
  => "xyzzy"


■software-version
[       type]: Function
[  arguments]: software-version
[    package]: lisp
[       file]: builtin.l
[    section]: システム
[description]: 
xyzzyのバージョンを返します。

使用例：
  (software-version)
  => "0.2.2.228"


■some
[       type]: Function
[  arguments]: some PREDICATE SEQUENCE &rest MORE-SEQUENCES
[    package]: lisp
[    seealso]: every , notany
[       file]: sequence.l
[    section]: シーケンス
[description]: 
SEQUENCEの先頭の要素から順番にPREDICATEを適用していき、PREDICATEが
非nilな値を返すと、その値をSOMEの戻り値としてすぐに終了します。
PREDICATEを満たす要素が見つからない時は nil を返します。

MORE-SEQUNCESが与えられた時、SEQUENCEの中で最も短いものの終わりまで実行されます。


■sort
[       type]: Function
[  arguments]: sort SEQUENCE PREDICATE &key :key
[    package]: lisp
[    seealso]: stable-sort
[       link]: [xyzzy:06221]
[    section]: シーケンス
[description]: 
SEQUENCE を PREDICATE に従った順番に並び替えたものを返します。元の SEQUENCE
は変更されます。 sort は安定であることは保証されません。安定なソートが必要
なときは stable-sort を使いましょう。

  SEQUENCE  : ソートするシーケンスを指定します。
  PREDICATE : 比較関数を指定します。
  :key      : 比較対象を取得する関数を指定します。

使用例：
  (setq *test-seq* '(("foo") ("bar") ("hoge")))
  => (("foo") ("bar") ("hoge"))
  (setq *test-seq* (sort *test-seq* #'string-lessp :key #'car))
  => (("bar") ("foo") ("hoge"))
  *test-seq*
  => (("bar") ("foo") ("hoge"))
 
  (setq *test-seq* '(("foo") ("bar") ("hoge")))
  => (("foo") ("bar") ("hoge"))
  (sort *test-seq* #'string-lessp :key #'car)
  => (("bar") ("foo") ("hoge"))
  *test-seq*
  => (("foo") ("hoge"))

参考：
  [xyzzy:06221] (こっそり)バージョンアップのお知らせ
  ・sort のアルゴリズムを quick から merge に変更
  (比較回数が少ない分、merge の方が速いっぽい)。
  結果、stable-sort と同じになった(が、依存しないように)。
  従来は *たまたま* (eq list (sort list)) だったが、
  そうではなくなったので注意すること。


■spec-map
[       type]: Variable
[    package]: editor
[    seealso]: specific-command-prefix
[       file]: keymap.l
[    section]: キーマップ
[description]: 
C-c に続くキーシーケンスのバインディングを格納するキーマップです。


■special
[       type]: Misc
[    package]: lisp
[    seealso]: declare
[    section]: 変数と定数
[description]: 
declare をごらんください。


■special-file-p
[       type]: Function
[  arguments]: special-file-p PATHNAME
[    package]: lisp
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
PATHNAMEがデバイスファイル(CON, AUX, NUL, PRN, LPT1/2/3/4, COM1/2/3/4)か
否かを返します。
  t    デバイスファイルである。
  nil  デバイスファイルでない。


■special-form-p
[       type]: Function
[  arguments]: special-form-p SYMBOL
[    package]: lisp
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
シンボルが特殊形式かどうかを返します。

  SYMBOL : 判定するシンボル

戻り値
  nil      シンボルは特殊形式ではない。
  non-nil  シンボルは特殊形式

  ; 特殊形式を書き出してみる
  (do-all-symbols (i "end")
    (and (special-form-p i)
         (format t "~A~%" i)))
  interactive
  save-restriction
  save-excursion
  save-window-excursion
  *byte-code
  macrolet
  setq
  throw
  return-from
  progn
  let*
  go
  labels
  if
  multiple-value-call
  unwind-protect
  multiple-value-setq
  catch
  tagbody
  eval-when
  let
  multiple-value-bind
  block
  function
  quote
  multiple-value-prog1
  flet
  =>"end"


■specific-command-prefix
[       type]: Function
[  arguments]: specific-command-prefix
[    package]: editor
[    seealso]: spec-map
[       file]: keymap.l
[    section]: キーマップ
[description]: 
C-c プレフィックスです。 [C-c]

specific-command-prefix の関数セルは普通のコマンドではなく spec-map と
いうキーマップを保持しています。


■split-line
[       type]: Function
[  arguments]: split-line
[    package]: editor
[    seealso]: open-line
[       file]: cmds.l
[    section]: テキスト
[description]: 
カーソル位置から行末までのテキストを縦に 1 行下げ、2 行に分割します。[ESC C-o]


■split-string
[       type]: Function
[  arguments]: split-string STRING SEPARATOR &optional IGNORE-EMPTY CHAR-BAG
[    package]: editor
[       file]: builtin.l
[    section]: 文字列
[description]: 
文字列を指定されたセパレータ文字で分割したリストにします。
セパレータ文字は含まれません。

  STRING       : 分割する文字列を指定します。
  SEPARATOR    : セパレータ文字を指定します。
  IGNORE-EMPTY : 長さが0の文字列も（つまり、セパレータ文字が連続するような場合）
                 を許すかどうかを指定します。
  CHAR-BAG     : 分割した後の文字列の前後をトリムするための文字群を指定します。
  
使用例：
  (split-string "121,,12321" #\,)       => ("121" "12321")
  (split-string "121,,12321" #\, t)     => ("121" "" "12321")
  (split-string "121,,12321" #\, t "1") => ("2" "" "232")
  (split-string "121,,12321" #\, t "3") => ("121" "" "12321")


■split-window
[       type]: Function
[  arguments]: split-window &optional ARG VERTICAL
[    package]: editor
[    seealso]: split-window-vertically , pop-to-buffer
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
ウィンドウを分割します。分割サイズと分割方向が指定可能です。[C-x 2]

  ARG      : 分割サイズを指定します。
  VERTICAL : 分割方向を指定します。
        t       左右に分割します。
        nil     上下に分割します。

分割後にカレントになるウィンドウには注意が必要です。

  (split-window 20 t)
  => +20-+---------+    
     |   |         |
     +↑-+---------+
      こちらにカーソルがくる
 
  (split-window -20 t)
  => +---------+20-+
     |         |   |
     +---------+↑-+
                こちらにカーソルがくる

  (split-window 20 nil)
  => +-------------+    
     |             ←こちらにカーソルがくる
     +-------------+    
     +-------------+    
      
  (split-window -20 nil)
  => +-------------+    
     +-------------+    
     |             ←こちらにカーソルがくる
     +-------------+          


■split-window-vertically
[       type]: Function
[  arguments]: split-window-vertically &optional ARG
[    package]: editor
[    seealso]: split-window
[   referred]: pop-to-buffer
[       file]: window.l
[    section]: ウィンドウ
[description]: 
ウィンドウを左右に分割します。[C-x 5]


■sqrt
[       type]: Function
[  arguments]: sqrt NUMBER
[    package]: lisp
[       file]: builtin.l
[    section]: 数値
[description]: 
平方根の値を返します。


■stable-sort
[       type]: Function
[  arguments]: stable-sort SEQUENCE PREDICATE &key :key
[    package]: lisp
[    seealso]: sort
[   referred]: merge
[       link]: [xyzzy:06221]
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCE を PREDICATE に従った順番に並び替えたものを返します。元の SEQUENCE
は変更されます。 stable-sort は安定なソートを行います。つまり PREDICATE によっ
て同順と見なされる要素間の順序は、ソート前と同じであることが保証されます。

  SEQUENCE  : ソートするシーケンスを指定します。
  PREDICATE : 比較関数を指定します。
  :key      : 比較対象を取得する関数を指定します。

使用例：
  (setq *test-seq* '(("foo") ("bar") ("hoge")))
  => (("foo") ("bar") ("hoge"))
  (setq *test-seq* (stable-sort *test-seq* #'string-lessp :key #'car))
  => (("bar") ("foo") ("hoge"))
  *test-seq*
  => (("bar") ("foo") ("hoge"))
 
  (setq *test-seq* '(("foo") ("bar") ("hoge")))
  => (("foo") ("bar") ("hoge"))
  (stable-sort *test-seq* #'string-lessp :key #'car)
  => (("bar") ("foo") ("hoge"))
  *test-seq*
  => (("foo") ("hoge"))


■standard-char-p
[       type]: Function
[  arguments]: standard-char-p CHAR
[    package]: lisp
[    seealso]: characterp
[       file]: builtin.l
[    section]: データ型
[description]: 
文字が、改行文字もしくは [ -~] かどうかを判定します。
表示可能な文字は SJIS 文字コードで 10, 32-126 です。

  CHAR : 判定する文字

戻り値：
  t   standard-char である
  nil standard-char でない

補足：
  ;;; 改行文字(SJIS 10) 以外の standard-char 文字一覧出力 (SJIS 32-126)
  (do ((i (char-code #\SPC) (1+ i)))
      ((= i (char-code #\DEL)))
    (format t "~A" (code-char i)))


■start-selection
[       type]: Function
[  arguments]: start-selection TYPE &optional TEMPORARY POINT
[    package]: editor
[    seealso]: stop-selection , get-selection-type , set-selection-type , fix-selection-point , pre-selection-p
[       file]: builtin.l
[    section]: リージョン
[description]: 
選択領域の範囲指定を開始します。

  TYPE：選択領域の範囲指定の方法を指定します。 
        1の場合         範囲選択を行で行います。
        2の場合         範囲選択を文字で行います。
        3の場合         範囲選択を矩形で行います。

  TEMPORARY：一時的なものかどうかを指定します。
        tの場合         キー入力されると範囲指定を解除します。
        nilの場合       カーソル移動に応じて範囲を変更します。

使用例：
  ;;; 矩形で範囲指定する。
  (start-selection 3 nil)
  => t


■start-selection-as-line
[       type]: Function
[  arguments]: start-selection-as-line
[    package]: editor
[    seealso]: start-selection-as-region
[       file]: select.l
[    section]: リージョン
[description]: 
行選択モードを開始します。[F6]
セレクションが存在する場合は、セレクションを解除します。


■start-selection-as-region
[       type]: Function
[  arguments]: start-selection-as-region
[    package]: editor
[    seealso]: start-selection-as-line
[       file]: select.l
[    section]: リージョン
[description]: 
文字選択モードを開始します。[S-F6]
文字選択モードが開始されている場合は、矩形選択モードに切替えます。
矩形選択モードが開始されている場合は、文字選択モードに切替えます。
行選択モードが開始されている場合は、選択モードを解除します。


■start-timer
[       type]: Function
[  arguments]: start-timer INTERVAL FN &optional ONE-SHOT-P
[    package]: editor
[    seealso]: stop-timer
[       file]: builtin.l
[    section]: 日付・時間
[description]: 
タイマーを設定します。INTERVAL秒後に、FNがfuncallされます。

  INTERVAL   : 何秒後に関数を実行するかを指定します。
  FN         : 実行する関数を指定します。
  ONE-SHOT-P : 継続して作動させるかどうかを指定します。
        nil      継続して作動させます。
        non-nil  1 回だけ作動させます。
  
使用例：
  ;; パターンを循環参照で作る
  (setq pat '(#\― #\／ #\｜ #\＼))
  => pat
  (setf (cdr (last pat)) pat)
  => #1=(#\― #\／ #\｜ #\＼ . #1#)
  (defun func () (setq pat (cdr pat)) (message "~A" (car pat)))
  => func
  ;; 動かす時は…
  (start-timer 0.2 'func)
  => t  
  ;; 止める時は…
  (stop-timer 'func)
  => t


■start-xyzzy-server
[       type]: Function
[  arguments]: start-xyzzy-server
[    package]: editor
[    seealso]: stop-xyzzy-server
[       file]: builtin.l
[    section]: システム
[description]: 
stop-xyzzy-serverの逆です。複数のxyzzy-serverが立ち上がっている状態で
xyzzycli.exe が実行された場合、最後にアクティブになったほうが選択され
るようです。


■step
[       type]: Macro
[  arguments]: step FORM
[    package]: lisp
[       file]: misc.l
[    section]: 制御構造
[description]: 
ステップ実行を行います。


■stop-selection
[       type]: Function
[  arguments]: stop-selection
[    package]: editor
[    seealso]: start-selection , fix-selection-point
[       file]: builtin.l
[    section]: ポジション
[description]: 
セレクションを解除します。


■stop-timer
[       type]: Function
[  arguments]: stop-timer FN
[    package]: editor
[    seealso]: start-timer
[       file]: builtin.l
[    section]: 日付・時間
[description]: 
設定したタイマーを停止します。


■stop-xyzzy-server
[       type]: Function
[  arguments]: stop-xyzzy-server
[    package]: editor
[    seealso]: start-xyzzy-server
[       file]: builtin.l
[    section]: システム
[description]: 
xyzzycli.exeに反応しないようにします。


■store-match-data
[       type]: Function
[  arguments]: store-match-data DATA
[    package]: editor
[    seealso]: scan-buffer , match-data
[   referred]: match-string , replace-match
[       file]: builtin.l
[    section]: 検索・正規表現
[description]: 
match-data で退避しておいた検索時点の状態を戻します。


■streamp
[       type]: Function
[  arguments]: streamp OBJECT
[    package]: lisp
[    seealso]: open-stream-p
[       file]: builtin.l
[    section]: 入出力
[description]: 
OBJECTがストリームか否かを返します。
  t    OBJECTはストリームである。
  nil  OBJECTはストリームでない。


■string
[       type]: Function
[  arguments]: string X
[    package]: lisp
[    seealso]: symbol-name , make-sequence , format , coerce
[       file]: builtin.l
[    section]: 文字列
[description]: 
Xが文字列ならそれを返します。シンボルならその名前を返します。
文字や文字のベクタなら、それらの文字からなる文字列を返します。

使用例：
  (string "foo")
  => "foo"
  (string 'bar)
  => "bar"
  (string #\a)
  => "a"
  (string (make-vector 3 :initial-contents '(#\a #\b #\c)))
  => "abc"


■string-capitalize
[       type]: Function
[  arguments]: string-capitalize STRING &key :start :end
[    package]: lisp
[    seealso]: nstring-capitalize
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING の内部の単語の先頭を大文字に、それ以外を小文字にした文字列を返します。
引数 STRING は保存されます。

使用例：
  (string-capitalize "xYZzY")
  => "Xyzzy"  
  (string-capitalize "tHis iS a pEn.")
  => "This Is A Pen."


■string-downcase
[       type]: Function
[  arguments]: string-downcase STRING &key :start :end
[    package]: lisp
[    seealso]: nstring-downcase , char-downcase , downcase-word
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING を小文字にした文字列を返します。引数 STRING は保存されます。

使用例：
  (string-downcase "XyZzY")
  => "xyzzy"
  (string-downcase "XYZZY" :start 2 :end 4)
  => "XYzzY"


■string-equal
[       type]: Function
[  arguments]: string-equal STRING1 STRING2 &key :start1 :end1 :start2 :end2
[    package]: lisp
[    seealso]: equalp , string= , string-not-equal
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING1とSTRING2を大文字小文字に関係なく比較して等しければt、そうでなけ
ればnilを返します。

使用例：
  (string-equal "foo" "foo")
  => t
  (string-equal "foo" "Foo")
  => t


■string-greaterp
[       type]: Function
[  arguments]: string-greaterp STRING1 STRING2 &key :start1 :end1 :start2 :end2
[    package]: lisp
[    seealso]: string< , string> , string<= , string>= , string-lessp , string-not-lessp , string-not-greaterp
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING1とSTRING2を大文字小文字に関係なく比較して「>」の条件を満たせば
一致しない文字のインデックスを、そうでなければnilを返します。

使用例：
  (string-greaterp "ac" "ab")
  => 1
  (string-greaterp "ac" "ac")
  => nil
  (string-greaterp "AC" "ab")
  => 1


■string-left-trim
[       type]: Function
[  arguments]: string-left-trim CHARACTER-BAG STRING
[    package]: lisp
[    seealso]: string-trim , string-right-trim
[       file]: builtin.l
[    section]: 文字列
[description]: 
文字列の先頭から指定した文字群を削除します。

  STRING         : 文字列
  CHARACTGER-BAG : 削除する文字群です。
  
使用例：
  ;;;  先頭の"/"や"\"を取り除きます。
  (string-left-trim "/\\" "/foo/bar/zzz.txt/")
  => "foo/bar/zzz.txt/"


■string-lessp
[       type]: Function
[  arguments]: string-lessp STRING1 STRING2 &key :start1 :end1 :start2 :end2
[    package]: lisp
[    seealso]: string< , string> , string<= , string>= , string-not-lessp , string-greaterp , string-not-greaterp
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING1とSTRING2を大文字小文字に関係なく比較して「<」の条件を満たせば
一致しない文字のインデックスを、そうでなければnilを返します。

使用例：  
  (string-lessp "Aa" "ab")
  => 1
  (string-lessp "ac" "AB")
  => nil  


■string-looking-at
[       type]: Function
[  arguments]: string-looking-at REGEXP STRING &key :start :end :case-fold
[    package]: editor
[    seealso]: string-match , string-matchp , looking-at , match-string , 正規表現の表記
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING が、REGEXP とマッチするかを調べます。

string-match は、REGEXP が STRING のどこかにマッチすれば、その位置を返し
ますが、string-looking-at は指定された位置でマッチするかを返します。

  :start       : チェックする文字列の開始位置を指定します。
                 適正な値でないとき、戻り値は nil となります。
  :end         : チェックする文字列の終了位置を指定します。
                 適正な値でないとき、戻り値は nil となります。
  :case-fold   : ASCII 文字の大文字小文字の区別の方法を指定します。
                 REGEXP が[コンパイル済み正規表現]の場合は、:case-fold
                 指定は意味を持ちません。
        nil     - 大文字小文字を区別して検索します。
        :smart  - REGEXP に大文字が含まれていない場合、大文字小文字を区
                  別せずに検索します。
        上記以外- 大文字小文字を区別せずに検索します。

例:
  (string-looking-at "a+b" "aaab")
  => 0

  (string-looking-at "a+b" "baaab")
  => nil

  (string-looking-at "a+b" "aaab" :start 2)
  => 2

  (string-looking-at "a+b" "aaab" :start 3 :end 6)
  => nil

  (string-looking-at "a+b" "AaAAB" :case-fold :smart)
  => 0


■string-match
[       type]: Function
[  arguments]: string-match REGEXP STRING &optional START END
[    package]: editor
[    seealso]: string-matchp , string-looking-at , looking-at , 正規表現の表記
[   referred]: string-replace-match
[       file]: builtin.l
[    section]: 文字列
[description]: 
指定された文字列が正規表現に一致するかどうかを返します。

  REGEXP : 正規表現
  STRING : チェックする文字列
  START  : 文字列の開始位置
  END    : 文字列の終了位置

互換性：
  muleあり。
  Common Lispなし。


■string-matchp
[       type]: Function
[  arguments]: string-matchp REGEXP STRING &optional START END
[    package]: editor
[    seealso]: string-match , string-looking-at
[       file]: builtin.l
[    section]: 文字列
[description]: 
| string-match と string-matchp とはどこがどう
| 違うのでしょう？

p 付きの方は大文字小文字を区別しません。


■string-not-equal
[       type]: Function
[  arguments]: string-not-equal STRING1 STRING2 &key :start1 :end1 :start2 :end2
[    package]: lisp
[    seealso]: string-equal
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING1とSTRING2を大文字小文字に関係なく比較して等しくなければ一致しない
文字のインデックスを、そうでなければnilを返します。
string-equalの反対の機能です。


■string-not-greaterp
[       type]: Function
[  arguments]: string-not-greaterp STRING1 STRING2 &key :start1 :end1 :start2 :end2
[    package]: lisp
[    seealso]: string< , string> , string<= , string>= , string-lessp , string-not-lessp , string-greaterp
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING1とSTRING2を大文字小文字に関係なく比較して「<=」の条件を満たせ
ば一致しない文字のインデックスを、そうでなければnilを返します。


■string-not-lessp
[       type]: Function
[  arguments]: string-not-lessp STRING1 STRING2 &key :start1 :end1 :start2 :end2
[    package]: lisp
[    seealso]: string< , string> , string<= , string>= , string-lessp , string-greaterp , string-not-greaterp
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING1とSTRING2を大文字小文字に関係なく比較して「>=」の条件を満たせ
ば一致しない文字のインデックスを、そうでなければnilを返します。


■string-rectangle
[       type]: Function
[  arguments]: string-rectangle P1 P2 STRING
[    package]: editor
[    seealso]: string-rectangle-selection , operate-on-rectangle
[       file]: rectangl.l
[    section]: リージョン
[description]: 
P1 と P2 で指定される矩形領域の各行を文字列 STRING で置き換えます。


■string-rectangle-selection
[       type]: Function
[  arguments]: string-rectangle-selection STRING
[    package]: editor
[    seealso]: string-rectangle , operate-on-rectangle-selection
[       file]: select.l
[    section]: リージョン
[description]: 
矩形選択されたセレクションの各行を文字列 STRING で置き換えます。


■string-replace-match
[       type]: Function
[  arguments]: string-replace-match STRING REPLACEMENT
[    package]: editor
[    seealso]: string-match
[       file]: builtin.l
[    section]: 文字列
[description]: 
string-matchで検索した結果を使って文字列の置換を行います。

  STRING      : string-matchで指定した文字列を指定します。
  REPLACEMENT : 置換する文字列を指定します。
                REPLACEには正規表現に部分\1-\9を含めることが可能です。

使用例：
  ;;; 文字列を置換してみる。
  (setq str "01356:00001:error message")
  => "01356:00001:error message"
  (when (string-match "\\([0-9]+\\):\\([0-9]+\\):\\(.*\\)" str)
    (setq str (string-replace-match str "\\1,\\3")))
  => "01356,error message"


■string-right-trim
[       type]: Function
[  arguments]: string-right-trim CHARACTER-BAG STRING
[    package]: lisp
[    seealso]: string-trim , string-left-trim
[       file]: builtin.l
[    section]: 文字列
[description]: 
文字列の末尾から指定した文字群を削除します。

  STRING         : 文字列
  CHARACTGER-BAG : 削除する文字群です。
  
使用例：
  ;;;  末尾の"/"や"\"を取り除きます。
  (string-right-trim "/\\" "/foo/bar/zzz.txt/")
  => "/foo/bar/zzz.txt"


■string-trim
[       type]: Function
[  arguments]: string-trim CHARACTER-BAG STRING
[    package]: lisp
[    seealso]: string-right-trim , string-left-trim
[       file]: builtin.l
[    section]: 文字列
[description]: 
文字列の前後から指定した文字群を削除します。

  STRING         : 文字列
  CHARACTGER-BAG : 削除する文字群です。
  
使用例：
  ;;;  前後の"/"や"\"を取り除きます。
  (string-trim "/\\" "/foo/bar/zzz.txt/")
  => "foo/bar/zzz.txt"


■string-upcase
[       type]: Function
[  arguments]: string-upcase STRING &key :start :end
[    package]: lisp
[    seealso]: nstring-upcase , char-upcase , upcase-word
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING を大文字にした文字列を返します。引数 STRING は保存されます。

使用例：
  (string-upcase "xyzzy")
  => "XYZZY"
  (string-upcase "xyzzy" :start 2 :end 4)
  => "xyZZy"


■string/=
[       type]: Function
[  arguments]: string/= STRING1 STRING2 &key :start1 :end1 :start2 :end2
[    package]: lisp
[    seealso]: string=
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING1とSTRING2を比較して等しくなければ一致しない文字のインデックスを、
そうでなければnilを返します。
英字の大文字と小文字は区別します。string=の反対の機能です。


■string<
[       type]: Function
[  arguments]: string< STRING1 STRING2 &key :start1 :end1 :start2 :end2
[    package]: lisp
[    seealso]: string= , string> , string<= , string>= , string-lessp , string-not-lessp , string-greaterp , string-not-greaterp
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING1とSTRING2を比較して「<」の条件を満たせば一致しない文字のインデ
ックスを、そうでなければnilを返します。

使用例：
  (string< "aa" "aa")
  => nil
  (string< "aa" "ab")
  => 1


■string<=
[       type]: Function
[  arguments]: string<= STRING1 STRING2 &key :start1 :end1 :start2 :end2
[    package]: lisp
[    seealso]: string= , string< , string> , string>= , string-lessp , string-not-lessp , string-greaterp , string-not-greaterp
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING1とSTRING2を比較して「<=」の条件を満たせば一致しない文字のイン
デックスを、そうでなければnilを返します。


■string=
[       type]: Function
[  arguments]: string= STRING1 STRING2 &key :start1 :end1 :start2 :end2
[    package]: lisp
[    seealso]: equal , string-equal , string/= , string> , string< , string<=
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING1とSTRING2を比較して等しければt、そうでなければnilを返します。
英字の大文字と小文字は区別します。

使用例：
  (string= "foo" "foo")
  => t
  (string= "foo" "Foo")
  => nil
  (string= "together" "frog" :start1 1 :end1 3 :start2 2)
  => t

参考：
  case-sensitive        case-insensitive
  ----                  ----
  string=               string-equal
  string/=              string-not-equal
  string<               string-lessp
  string>               string-greaterp
  string<=              string-not-greaterp
  string>=              string-not-lessp


■string>
[       type]: Function
[  arguments]: string> STRING1 STRING2 &key :start1 :end1 :start2 :end2
[    package]: lisp
[    seealso]: string< , string<= , string>= , string-lessp , string-not-lessp , string-greaterp , string-not-greaterp
[   referred]: string=
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING1とSTRING2を比較して「>」の条件を満たせば一致しない文字のインデ
ックスを、そうでなければnilを返します。

使用例：
  (string> "ac" "ab")
  => 1
  (string> "ac" "ac")
  => nil
  (string> "AC" "ab")
  => nil


■string>=
[       type]: Function
[  arguments]: string>= STRING1 STRING2 &key :start1 :end1 :start2 :end2
[    package]: lisp
[    seealso]: string< , string> , string<= , string-lessp , string-not-lessp , string-greaterp , string-not-greaterp
[       file]: builtin.l
[    section]: 文字列
[description]: 
STRING1とSTRING2を比較して「>=」の条件を満たせば一致しない文字のイン
デックスを、そうでなければnilを返します。


■stringp
[       type]: Function
[  arguments]: stringp OBJECT
[    package]: lisp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTがstringならt、それ以外ならnilを返します。


■sub-directory-p
[       type]: Function
[  arguments]: sub-directory-p DIRECTORY PARENT
[    package]: lisp
[    seealso]: path-equal
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
DIRECTORYがPARENTのサブディレクトリならt、そうでなければnilを返します。

使用例： 
  (sub-directory-p "c:/windows/system" "c:/windows")
  => t


■sublis
[       type]: Function
[  arguments]: sublis ALIST TREE &key :test :test-not :key
[    package]: lisp
[    seealso]: subst , nsublis , nsubstitute
[   referred]: substitute
[       file]: builtin.l
[    section]: リスト
[description]: 
TREE の中で ALIST の :key との :test を満たすものを VALUE に置き換えたリストを返します。
引数 TREE は保存されます。

使用例：
  ;;; a->1、b->2に変更
  (sublis '((a . 1) (b . 2)) '(a b c))
  => (1 2 c)


■subseq
[       type]: Function
[  arguments]: subseq SEQUENCE START &optional END
[    package]: lisp
[    seealso]: last , butlast , substring
[       file]: builtin.l
[    section]: シーケンス
[description]: 
SEQUENCEのSTART番目からENDもしくは最後までの新しいsequenceを返します。


■subsetp
[       type]: Function
[  arguments]: subsetp LIST1 LIST2 &rest REST &key :test :test-not :key
[    package]: lisp
[    seealso]: set-difference , intersection
[   referred]: set-exclusive-or , union
[       file]: list.l
[    section]: リスト
[description]: 
LIST1 が LIST2 のサブセットなら t、そうでないなら nil を返します。

使用例:
  (subsetp '(1 5 7) '(1 3 5 7 9))
  => t
  (subsetp '(1 5 8) '(1 3 5 7 9))
  => nil


■subst
[       type]: Function
[  arguments]: subst NEW OLD TREE &key :test :test-not :key
[    package]: lisp
[    seealso]: sublis , nsubst , subst-if , subst-if-not , substitute
[       file]: builtin.l
[    section]: リスト
[description]: 
TREE の中で OLD を NEW に置き換えた TREE のコピーを返します。
引数 TREE は保存されます。

使用例：
  ;;; 階層のあるツリーをsubstしてみる。aはそのまま
  (setq a '((1 2) ((1 3) (1 4))))       => ((1 2) ((1 3) (1 4)))
  (subst 5 1 a)                         => ((5 2) ((5 3) (5 4)))
  a                                     => ((1 2) ((1 3) (1 4)))


■subst-if
[       type]: Function
[  arguments]: subst-if NEW TEST TREE &key :key
[    package]: lisp
[    seealso]: subst-if-not , subst , substitute-if
[   referred]: nsubst-if , nsubst-if-not
[       file]: builtin.l
[    section]: リスト
[description]: 
TREE の中で TEST を満たすものがあれば NEW に置き換えたものを返します。
引数 TREE は保存されます。

  NEW  : 置き換える要素
  TEST : 置き換えるかどうかを判定するテスト
         non-nilを返したら置き換えます。
  TREE : 対象のツリー

TESTにはTREEの部分リストと要素を順番に引数として与えるので、必ずしも末端
の要素だけが置き換えの対象とはなりません。例えば、こんな感じで呼び出され
ます。

  ;;; funcで判定する場合
  (subst-if 0 #'func '(1 2 3))

  ;;; funcに引数として与えられる値(1 2 3だけじゃない)
  (1 2 3) 1 (2 3) 2 (3) 3 nil

下の使用例の様に事前の型チェックをして回避します。

使用例：
  ;;; 適当なツリーを用意して、その要素が奇数ならば0に置き換える。
  (setq a '((1 2) ((1 3) (1 (1 3)))))
  => ((1 2) ((1 3) (1 (1 3))))
  (subst-if 0 #'(lambda (x) (and (integerp x) (oddp x))) a)
  => ((0 2) ((0 0) (0 (0 0))))
  a
  => ((1 2) ((1 3) (1 (1 3))))


■subst-if-not
[       type]: Function
[  arguments]: subst-if-not NEW TEST TREE &key :key
[    package]: lisp
[    seealso]: subst-if , subst , substitute-if-not
[       file]: builtin.l
[    section]: リスト
[description]: 
TREEの中でTESTを満たさないものがあればNEWに置き換えたものを返します。
TREEは保存されます。

  NEW  : 置き換える要素
  TEST : 置き換えるかどうかを判定するテスト
         nilを返したら置き換えます。
  TREE : 対象のツリー

TESTの引数についてはsubst-ifを参照して下さい。

使用例：
  ;;; 適当なツリーを用意して、数字以外のものがあれば0に変換する。
  (setq a '((123 "abc") '(456 "123") (789 #\a)))
  => ((123 "abc") '(456 "123") (789 #\a))
  (subst-if-not 0 #'(lambda (x) (or (listp x) (integerp x))) a)
  => ((123 0) (0 (456 0)) (789 0))
  a
  => ((123 "abc") '(456 "123") (789 #\a))  


■substitute
[       type]: Function
[  arguments]: substitute NEWITEM OLDITEM SEQUENCE &key :from-end :test :test-not :start :end :count :key
[    package]: lisp
[    seealso]: substitute-if , substitute-if-not , nsubstitute , subst , substitute-string , sublis
[       file]: sequence.l
[    section]: シーケンス
[description]: 
SEQUENCE に対して OLDITEM との :test を満足する要素を NEWITEM に置き換え
たシーケンスを返します。引数 SEQUENCE は保存されますが、戻り値と一部を共有する
かもしれません。

  :test     : テストを行う2項演算子
  :start    : 開始位置。デフォルトは0で非負の整数
  :end      : 終了位置。デフォルトはnilで、nilの場合はSEQUENCEの長さを指定した
              場合と等しい動作。
  :count    : 置き換える最大の回数。
  :from-end : nil ならば先頭から、non-nil で末尾から置換を行う。 :count
              が与えられた時のみ意味を持つ。


■substitute-if
[       type]: Function
[  arguments]: substitute-if NEWITEM TEST SEQUENCE &key :from-end :start :end :count :key
[    package]: lisp
[    seealso]: subst-if , substitute , substitute-if-not , nsubstitute-if
[       file]: sequence.l
[    section]: シーケンス
[description]: 
SEQUENCEに対してTESTを満足する要素をNEWITEMに置き換えたシーケンスを返します。
引数 SEQUENCE は保存されますが、戻り値と一部を共有するかもしれません。

  TEST      : テストを行う単項演算子
  :start    : 開始位置。デフォルトは0で非負の整数
  :end      : 終了位置。デフォルトはnilで、nilの場合はSEQUENCEの長さを指定した
              場合と等しい動作。
  :count    : 置き換える最大の回数。
  :from-end : nil ならば先頭から、non-nil で末尾から置換を行う。 :count
              が与えられた時のみ意味を持つ。


■substitute-if-not
[       type]: Function
[  arguments]: substitute-if-not NEWITEM TEST SEQUENCE &key :from-end :start :end :count :key
[    package]: lisp
[    seealso]: subst-if-not , substitute , substitute-if , nsubstitute-if-not
[       file]: sequence.l
[    section]: シーケンス
[description]: 
SEQUENCEに対してTESTを満足しない要素をNEWITEMに置き換えたシーケンスを返します。
引数 SEQUENCE は保存されますが、戻り値と一部を共有するかもしれません。

  TEST      : テストを行う単項演算子
  :start    : 開始位置。デフォルトは0で非負の整数
  :end      : 終了位置。デフォルトはnilで、nilの場合はSEQUENCEの長さを指定した
              場合と等しい動作。
  :count    : 置き換える最大の回数。
  :from-end : nil ならば先頭から、non-nil で末尾から置換を行う。 :count
              が与えられた時のみ意味を持つ。


■substitute-key-definition
[       type]: Function
[  arguments]: substitute-key-definition OLDDEF NEWDEF &optional (KEYMAP *global-keymap*) (OKEYMAP KEYMAP)
[    package]: editor
[    seealso]: define-key
[       file]: keymap.l
[    section]: キーマップ
[description]: 
OKEYMAP において OLDDEF が割り当てられているすべてのキーに対して、
KEYMAP において NEWDEF を割り当てます。

例：
  ;;; text-mode での行の移動を物理行単位にする
  (substitute-key-definition 'next-virtual-line 'next-line
                             *text-mode-map* *global-keymap*)
  (substitute-key-definition 'previous-virtual-line 'previous-line
                             *text-mode-map* *global-keymap*)


■substitute-string
[       type]: Function
[  arguments]: substitute-string STRING PATTERN REPLACEMENT &key :case-fold :start :end :skip :count
[    package]: editor
[    seealso]: replace-string , substitute , replace , quote-string
[   referred]: perform-replace , replace-buffer
[       file]: builtin.l
[    section]: 文字列
[description]: 
文字列中の正規表現パターンを置換して返します。

  :case-fold  : nil なら大文字小文字を区別する。
                :smart なら、パターンに大文字が現れないときのみ区別しない。
                その他の場合なら大文字小文字を区別しない。                
  :start      : 開始位置。デフォルトは 0 で非負の整数
  :end        : 終了位置。デフォルトは nil で、 nil の場合は列の長さを
                指定した場合と等しい動作
  :skip       : 指定された回数マッチするまでは置換を行わない
  :count      : 置き換える最大の回数

使用例：
  ;;; 部分文字列を置換する。
  (substitute-string "Hogehoge" "ho" "pa")
  => "Hogepage"

  ;;; 大文字小文字を区別せず置換する。
  (substitute-string "Hogehoge" "ho" "pa" :case-fold t)
  => "pagepage"

  ; 正規表現・メタ文字の利用
  (substitute-string "abc123cdef" "[^0-9]*\\([0-9]+\\).*" "\\1 in \\&")
  =>"123 in abc123cdef"


■substring
[       type]: Function
[  arguments]: substring STRING START &optional END
[    package]: lisp
[    seealso]: subseq
[   referred]: buffer-substring , copy-string
[       file]: builtin.l
[    section]: 文字列
[description]: 
指定された文字列の部分文字列を返します。
START, END に負の数値を指定すると文字列の最後からカウントします。

互換性：
  Common Lispにはなし(ただしsubseqがほぼ同等の機能）
  muleあり。


■subtypep
[       type]: Function
[  arguments]: subtypep TYPE1 TYPE2
[    package]: lisp
[    seealso]: deftype , typep , 型一覧
[       file]: typespec.l
[    section]: データ型
[description]: 
ある型が他の型の副型かどうか調べて多値で返します。
（詳細不明）

  TYPE1 : 副型を指定します。
  TYPE2 : 型を指定します。

  t   t         TYPE1は明確にTYPE2の副型
  nil t         TYPE1は明確にTYPE1の副型ではない
  nil nil       関係を判断できない

使用例：
  ;;; サブタイプかどうかを調べる。
  (subtypep 'single-float 'number)
  => (single-float double-float long-float)
  (subtypep 'cons 'number)
  => nil


■svref
[       type]: Accessor
[  arguments]: svref SIMPLE-VECTOR INDEX
[    package]: lisp
[    seealso]: aref , setf , vector
[   referred]: row-major-aref
[       file]: builtin.l
[    section]: 配列
[description]: 
aref と同じですが、 svref はベクタ(一次元配列)のみにアクセスできます。つ
まり、ベクタ hoge があるとき、 (svref hoge 2) は (aref hoge 2) と同じ意味で
す。ただし、 foo が2x2配列の場合は、 svref でアクセスすることはできません。


■switch-pseudo-frame
[       type]: Function
[  arguments]: switch-pseudo-frame NAME
[    package]: editor
[    seealso]: select-pseudo-frame , pseudo-frame-selector
[   referred]: next-pseudo-frame , other-pseudo-frame , previous-pseudo-frame
[       file]: pframe.l
[    section]: ウィンドウ
[description]: 
対話的にフレームを選択します。


■switch-to-buffer
[       type]: Function
[  arguments]: switch-to-buffer BUFFER &optional NOWARN
[    package]: editor
[    seealso]: get-buffer-create , set-buffer , verify-visited-file-modtime , switch-to-buffer-other-window
[       file]: buffer.l
[    section]: バッファ
[description]: 
指定されたバッファに移動し、ウィンドウに移動します。 [C-x b]
バッファが存在しなければバッファを作成します。そのバッファを操作中のウ
ィンドウに表示するところ以外は、get-buffer-createのinteractive版と言え
ます。

使用例：
  ;;; *calc*があろうとなかろうと*calc*に移動する。
  (switch-to-buffer "*calc*")
  => #<buffer: *calc*>


■switch-to-buffer-other-window
[       type]: Function
[  arguments]: switch-to-buffer-other-window BUFFER &optional NOWARN
[    package]: editor
[    seealso]: switch-to-buffer
[       file]: buffer.l
[    section]: バッファ
[description]: 
他のウィンドウに移ってからバッファを切り替えます。[C-x 4 b]
ウィンドウ数が1の時は、ウィンドウを分割します。

  BUFFER : このバッファにカレントウィンドウを切り替えます。
  NOWARN : non-nilならば、指定したバッファが他のアプリケーションにより更
           新されているかのチェックを行いません。


■symbol-function
[       type]: Function
[  arguments]: symbol-function SYMBOL
[    package]: lisp
[    seealso]: symbol-value , function
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
シンボルが束縛された関数定義を返します。
fletなどで定義したローカルの関数定義は参照できません。

  SYMBOL : 関数定義を取得するシンボル名

使用例：
  ;;; 関数定義の取得
  (symbol-function 'foo)
  => 関数が定義されていません: foo
  (defun foo (x) (* x 2))
  => foo
  (symbol-function 'foo)
  => #<lexical-closure: foo>


■symbol-name
[       type]: Function
[  arguments]: symbol-name SYMBOL
[    package]: lisp
[    seealso]: intern , string
[       file]: builtin.l
[    section]: シンボル
[description]: 
シンボルの名前を印字用の文字列として返します。

使用例：
  ;;; シンボルxyzzyを文字列にしてみる。
  (symbol-name 'xyzzy)
  => "xyzzy"


■symbol-package
[       type]: Function
[  arguments]: symbol-package SYMBOL
[    package]: lisp
[    seealso]: make-symbol , gensym , intern
[       file]: builtin.l
[    section]: シンボル
[description]: 
シンボルが属するパッケージを返します。
make-symbol とか gensym で生成されたシンボルはどのパッケージにも属しません。

使用例：
  ;;; uninternedなシンボルとそうでないシンボルを作ってみる。
  (setq foo 2)                          => foo
  (symbol-package 'foo)                 => #<package: user>
  
  (setq bar (make-symbol "bar"))        => #:bar
  (set bar 3)                           => 3
  (symbol-value bar)                    => 3
  (symbol-package bar)                  => nil


■symbol-plist
[       type]: Function
[  arguments]: symbol-plist SYMBOL
[    package]: lisp
[    seealso]: get
[   referred]: getf
[       file]: builtin.l
[    section]: シンボル
[description]: 
シンボルのプロパティリストを返す。

使用例：
  ;;; シンボルのプロパティリストを見てみる。
  (symbol-plist 'xyzzy)         => nil
  (setf (get 'xyzzy 'foo) 1)    => 1
  (symbol-plist 'xyzzy)         => (foo 1)


■symbol-value
[       type]: Function
[  arguments]: symbol-value SYMBOL
[    package]: lisp
[    seealso]: symbol-function , default-value , buffer-local-value
[   referred]: set
[       file]: builtin.l
[    section]: シンボル
[description]: 
シンボルが束縛されている値を返します。
局所変数の値は参照できません。

  SYMBOL : 値を返すシンボル

使用例：
  ;;; foo というシンボルの値を返してみる
  (set 'foo 3)          => 3
  (symbol-value 'foo)   => 3
  foo                   => 3
  ;;; 局所変数は参照できない
  (let ((foo 1))
    (symbol-value 'foo)) => 3


■symbolp
[       type]: Function
[  arguments]: symbolp OBJECT
[    package]: lisp
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTがsymbolならt、それ以外ならnilを返します。

  (symbolp x) == (typep x 'symbol)


■syntax-c++-comment-p
[       type]: Function
[  arguments]: syntax-c++-comment-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-start-c++-comment
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARがC++スタイルのコメントの開始文字として規定されているかを返します。

  t     開始文字である。
  nil   開始文字でない。


■syntax-close-p
[       type]: Function
[  arguments]: syntax-close-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-match , syntax-open-p
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARが括弧などの終了文字として規定されているかを返します。

  t     終了文字である。
  nil   終了文字でない。


■syntax-close-tag-p
[       type]: Function
[  arguments]: syntax-close-tag-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-close-tag
[   referred]: set-syntax-tag , syntax-open-tag-p
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARがタグの終了文字として規定されているかを返します。

  t     タグの終了文字である。
  nil   タグの終了文字でない。


■syntax-end-c++-comment-p
[       type]: Function
[  arguments]: syntax-end-c++-comment-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-end-c++-comment
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARがC++スタイルのコメントの終了文字として規定されているかを返します。

  t     終了文字である。
  nil   終了文字でない。


■syntax-end-comment-p
[       type]: Function
[  arguments]: syntax-end-comment-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-end-comment
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARがコメント終了文字として規定されているかを返します。

  t     コメント終了文字である。
  nil   コメント終了文字でない。


■syntax-end-multi-comment-1-p
[       type]: Function
[  arguments]: syntax-end-multi-comment-1-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-end-multi-comment , syntax-end-multi-comment-2-p
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARがコメント終了の文字列の1文字目として規定されているかを返します。

  t     コメント終了文字列の1文字目である。
  nil   コメント終了文字列の1文字目でない。


■syntax-end-multi-comment-2-p
[       type]: Function
[  arguments]: syntax-end-multi-comment-2-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-end-multi-comment , syntax-end-multi-comment-1-p
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARがコメント終了の文字列の2文字目として規定されているかを返します。

  t     コメント終了文字列の2文字目である。
  nil   コメント終了文字列の2文字目でない。


■syntax-escape-p
[       type]: Function
[  arguments]: syntax-escape-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-escape
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARがエスケープ文字として規定されているかを返します。

  t     エスケープ文字である。
  nil   エスケープ文字でない。


■syntax-junk-p
[       type]: Function
[  arguments]: syntax-junk-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-junk
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARがゴミ文字として規定されているかを返します。

  t     ゴミ文字である。
  nil   ゴミ文字でない。


■syntax-math-p
[       type]: Function
[  arguments]: syntax-math-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-math
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARが対になった区切り文字として規定されているかを返します。

  t     対になった区切り文字である。
  nil   対になった区切り文字でない。


■syntax-open-p
[       type]: Function
[  arguments]: syntax-open-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-match , syntax-close-p
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARが括弧などの開始文字として規定されているかを返します。

  t     開始文字である。
  nil   開始文字でない。


■syntax-open-tag-p
[       type]: Function
[  arguments]: syntax-open-tag-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-tag , syntax-close-tag-p
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARがタグの開始文字として規定されているかを返します。

  t     タグの開始文字である。
  nil   タグの開始文字でない。


■syntax-punctuation-p
[       type]: Function
[  arguments]: syntax-punctuation-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-punctuation
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARが句読点文字として規定されているかを返します。

  t     句読点文字である。
  nil   句読点文字である。


■syntax-quote-p
[       type]: Function
[  arguments]: syntax-quote-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-quote
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARがSYNTAX-TABLEでquote(?)として規定されているか否か返します。

  t    CHARはquoteである。
  nil  CHARはquoteでない。


■syntax-start-column-comment-p
[       type]: Function
[  arguments]: syntax-start-column-comment-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-start-column-comment
[       file]: builtin.l
[    section]: シンタックス
[description]: 
set-syntax-start-column-comment で指定した文字か否かを判定します。


■syntax-start-comment-p
[       type]: Function
[  arguments]: syntax-start-comment-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-start-comment
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARがコメント開始文字として規定されているかを返します。

  t     コメント開始文字である。
  nil   コメント開始文字でない。


■syntax-start-multi-comment-1-p
[       type]: Function
[  arguments]: syntax-start-multi-comment-1-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-start-multi-comment , syntax-start-multi-comment-2-p
[   referred]: set-syntax-end-multi-comment
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字がコメント開始の文字列の1文字目として規定されているかを返します。

  CHAR         : コメント開始の1文字目を指定します。
  SYNTAX-TABLE : シンタックステーブルを指定します。指定しないと、カレン
                 トバッファにしようされているシンタックステーブルが使用
                 されます。

  t     コメント開始文字列の1文字目である。
  nil   コメント開始文字列の1文字目でない。


■syntax-start-multi-comment-2-p
[       type]: Function
[  arguments]: syntax-start-multi-comment-2-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-start-multi-comment , syntax-start-multi-comment-1-p
[   referred]: set-syntax-end-multi-comment
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARがコメント開始の文字列の2文字目として規定されているかを返します。

  t     コメント開始文字列の2文字目である。
  nil   コメント開始文字列の2文字目でない。


■syntax-string-p
[       type]: Function
[  arguments]: syntax-string-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-string
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARがSYNTAX-TABLEで文字列の区切りとして規定されているか否かを返します。

  t    CHARは文字列の区切り文字である。
  nil  CHARは文字列の区切り文字でない。


■syntax-symbol-p
[       type]: Function
[  arguments]: syntax-symbol-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-symbol
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字がシンボル名を構成する文字として規定されているかを返します。
ただし単語構成文字は除きます。

  CHAR : 文字を指定します。  

  t     シンボル名を構成する文字である。
  nil   シンボル名を構成する文字でない。


■syntax-symbol-prefix-p
[       type]: Function
[  arguments]: syntax-symbol-prefix-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-symbol-prefix
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARがシンボルの前置子として規定されているかを返します。

  CHAR : 文字を指定します。  

  t     シンボルの前置子である。
  nil   シンボルの前置子でない。


■syntax-table
[       type]: Function
[  arguments]: syntax-table &optional BUFFER
[    package]: editor
[    seealso]: make-syntax-table , syntax-table-p , use-syntax-table , parse-point-syntax
[   referred]: set-syntax-comment-column
[       file]: builtin.l
[    section]: シンタックス
[description]: 
現在のシンタックステーブルを取り出します。

使用例：
  ;;; evalして挿入
  (defun xmldoc-eval-and-insert ()
    (interactive "p")
    (let ((syntab (syntax-table)))  ;;現在のxmldocモードのsyntax-tableを取り出し
      (let (from to col str start end)
        (cond ((selection-start-end (start end)
                 (setq from start to end)))
              (t
               ;;一時的にlispに切り替えて
               (use-syntax-table ed::*lisp-mode-syntax-table*)
               (unwind-protect
                   (setq from (progn
                                (backward-sexp)
                                (point))
                         to (progn
                              (forward-sexp)
                              (point)))
                 ;; また元に戻す
                 (use-syntax-table syntab))))


■syntax-table-p
[       type]: Function
[  arguments]: syntax-table-p OBJECT
[    package]: editor
[    seealso]: make-syntax-table
[   referred]: syntax-table , use-syntax-table
[       file]: builtin.l
[    section]: シンタックス
[description]: 
指定されてオブジェクトOBJECTがシンタックステーブルか否かを返します。

  t    シンタックステーブルである。
  nil  シンタックステーブルでない。


■syntax-whitespace-p
[       type]: Function
[  arguments]: syntax-whitespace-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-whitespace
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字CHARがSYNTAX-TABLEでwhitespaceとして規定されてるか否かを返します。

  t    CHARはwhitespaceでない。
  nil  CHARはwhitespaceである。


■syntax-word-p
[       type]: Function
[  arguments]: syntax-word-p CHAR &optional SYNTAX-TABLE
[    package]: editor
[    seealso]: set-syntax-word
[   referred]: word-char-p
[       file]: builtin.l
[    section]: シンタックス
[description]: 
文字が単語を構成する文字として規定されているかを返します。

  CHAR : 判定する文字を指定します。

  t     単語を構成する文字である。
  nil   単語を構成する文字でない。


■t
[       type]: Variable
[    package]: lisp
[    seealso]: nil
[    section]: 変数と定数
[description]: 
真を表す定数です。


■tab-bar-add-item
[       type]: Function
[  arguments]: tab-bar-add-item BAR ITEM STRING &optional TOOLTIP MENU &key :first :last :before :after
[    package]: editor
[    seealso]: tab-bar-delete-item , tab-bar-find-item , tab-bar-current-item , create-tab-bar
[   referred]: tab-bar-modify-item
[       file]: builtin.l
[    section]: メニュー
[description]: 
create-tab-barで作成したタブバーBARにタブを追加します。タブを識別するた
めのITEMとタブの文字列STRINGを指定します。個別のツールチップTOOLTIPと、
メニューMENUを指定可能です。


■tab-bar-current-item
[       type]: Function
[  arguments]: tab-bar-current-item BAR
[    package]: editor
[    seealso]: tab-bar-delete-item , tab-bar-add-item
[   referred]: tab-bar-select-item
[       file]: builtin.l
[    section]: メニュー
[description]: 
選択中のタブの情報が返されます。タブがひとつも無い場合には、nilが返され
ます。必ず、タブを識別するためのシンボル、タブの文字列、ツールチップのリ
ストで返されます。ツールチップが設定されていない場合には、nilが返されま
す。

使用例：
  (progn
    (defun a-func (a) (msgbox "~A ~A" a (type-of a)))
    (define-command-bar 'a-bar "a bar")
    (create-tab-bar 'a-bar 'a-func)
    (show-command-bar 'a-bar)
    (tab-bar-add-item 'a-bar '1st "- 1st -" "1st item")
    (tab-bar-add-item 'a-bar '2nd "- 2nd -" "2nd item"))
  => t
  (tab-bar-current-item 'a-bar)
  => (1st "- 1st -" "1st item")
  (progn
    (tab-bar-delete-item 'a-bar '1st)
    (tab-bar-delete-item 'a-bar '2nd)
    (delete-tool-bar 'a-bar)
    (delete-command-bar 'a-bar))
  => t


■tab-bar-delete-item
[       type]: Function
[  arguments]: tab-bar-delete-item BAR ITEM
[    package]: editor
[    seealso]: tab-bar-add-item , create-tab-bar
[   referred]: tab-bar-current-item
[       file]: builtin.l
[    section]: メニュー
[description]: 
create-tab-barで作成したタブバーBARからタブITEMを削除します。削除するタ
ブが選択状態であれば、次のタブが選択されて同時にCALLBACKが実行されます。


■tab-bar-find-item
[       type]: Function
[  arguments]: tab-bar-find-item BAR ITEM
[    package]: editor
[    seealso]: create-tab-bar , tab-bar-list-items
[   referred]: tab-bar-add-item
[       file]: builtin.l
[    section]: メニュー
[description]: 
指定されたタブバーBARからタブITEMが存在するか否かを返します。

  t    存在する。
  nil  存在しない。

使用例：
  (tab-bar-find-item 'a-bar '1st)
  => t
  (tab-bar-find-item 'a-bar '3rd)
  => nil


■tab-bar-list-items
[       type]: Function
[  arguments]: tab-bar-list-items BAR
[    package]: editor
[    seealso]: tab-bar-find-item , create-tab-bar
[       file]: builtin.l
[    section]: メニュー
[description]: 
指定されたタブバーBARのタブのシンボルのリストを返します。

使用例：
  (tab-bar-list-items 'a-bar)
  => (1st 2nd)


■tab-bar-modify-item
[       type]: Function
[  arguments]: tab-bar-modify-item BAR ITEM &optional STRING TOOLTIP MENU
[    package]: editor
[    seealso]: tab-bar-add-item
[   referred]: create-tab-bar
[       file]: builtin.l
[    section]: メニュー
[description]: 
指定されたタブバーBARのタブITEMの設定を変更します。

使用例：
  (tab-bar-modify-item 'a-bar '1st "- first -")
  => t


■tab-bar-select-item
[       type]: Function
[  arguments]: tab-bar-select-item BAR ITEM
[    package]: editor
[    seealso]: tab-bar-current-item
[   referred]: create-tab-bar
[       file]: builtin.l
[    section]: メニュー
[description]: 
指定されたタブバーBARのタブITEMを選択状態にします。同時にタブバーに設定
されたCALLBACKが実行されます。


■tab-columns
[       type]: Function
[  arguments]: tab-columns &optional BUFFER
[    package]: editor
[    seealso]: set-tab-columns
[       file]: builtin.l
[    section]: テキスト
[description]: 
タブ幅を返します。タブ幅はset-tab-columnsで設定できます。

  BUFFER : タブ幅を返すバッファを指定します。
           指定がなければカレントバッファが対象となります。


■tabify
[       type]: Function
[  arguments]: tabify FROM TO
[    package]: editor
[    seealso]: untabify
[       file]: cmds.l
[    section]: テキスト
[description]: 
FROM と TO の間にある半角スペースを可能な限りタブ文字で置き換えます。


■tagbody
[       type]: Special Form
[  arguments]: tagbody {TAG|STATEMENT}*
[    package]: lisp
[    seealso]: go
[   referred]: prog , prog*
[       file]: builtin.l
[    section]: 制御構造
[description]: 
labelジャンプです。
tagbody内は任意の数のtag(シンボルもしくは数字)とstatement(S式)からなり
実行時にはtagは無視されstatementが実行されます。(go tag)が評価されたときに
実行はtagの場所に移ります。tagbodyは終了時にnilを返します。


■tail-f
[       type]: Function
[  arguments]: tail-f FILENAME
[    package]: editor
[   referred]: *tail-f-mode-hook*
[       file]: tail-f.l
[    section]: ファイルシステム
[description]: 
tail コマンドの -f オプションのように、更新され続けるようなファイルを終
端まで読み込み続けようとします。


■tailp
[       type]: Function
[  arguments]: tailp SUBLIST LIST
[    package]: lisp
[    seealso]: ldiff
[       file]: list.l
[    section]: リスト
[description]: 
SUBLISTがLISTを構成しているconsであるかを返す。

具体的にはLISTを順にcdrしていった結果とSUBLISTが
eqならtそうでないならnilを返す。


■tan
[       type]: Function
[  arguments]: tan RADIANS
[    package]: lisp
[       file]: builtin.l
[    section]: 数値
[description]: 
正接関数の値を返します。


■tanh
[       type]: Function
[  arguments]: tanh Z
[    package]: lisp
[       file]: number.l
[    section]: 数値
[description]: 
双曲線正接関数を計算します。 


■tenth
[       type]: Function
[  arguments]: tenth X
[    package]: lisp
[    seealso]: nth
[       file]: list.l
[    section]: リスト
[description]: 
list の 10 番目の要素を返します。

  (tenth X) = (nth 9 X)

使用例：
  (tenth '(1 2 3 4 5 6 7 8 9 0))
  => 0


■terpri
[       type]: Function
[  arguments]: terpri &optional OUTPUT-STREAM
[    package]: lisp
[    seealso]: fresh-line
[       file]: builtin.l
[    section]: 入出力
[description]: 
OUTPUT-STREAM に改行 (#\LFD) を出力して nil を返します。


■third
[       type]: Function
[  arguments]: third X
[    package]: lisp
[    seealso]: caddr , nth
[       file]: list.l
[    section]: リスト
[description]: 
caddr の別名です。全く同じ動きをします。


■throw
[       type]: Special Form
[  arguments]: throw TAG RESULT
[    package]: lisp
[    seealso]: catch
[       file]: builtin.l
[    section]: 制御構造
[description]: 
catchで指定されたラベルまで、非局所脱出します。
名前はC++と同じです。

  C++  : try    throw
  Lisp : catch  throw

使用例：
  ;;; test2で例外を出してtest1でキャッチする。
  (defun test1 (x)
    (catch 'label1
      (test2 x)))
  => test1
  (defun test2 (x)
    (if (zerop x)
        (throw 'label1 'division-by-zero)
        (/ 1 x)))
  => test2
  (test1 0)
  => division-by-zero

参考：
  エラー処理関連


■title-bar-format
[       type]: Variable
[    package]: editor
[    seealso]: mode-line-format
[    section]: 変数と定数
[description]: 
タイトルバーのフォーマットを設定します。
モードラインのフォーマットと同様です。

使用例：
  (setq title-bar-format "--%*- %b (%M) [%k:%l] %P %f")

パラメタ：
  %*    変更あり          : **
        書込禁止          : %-
        変更あり・書込禁止: %*
        それ以外          : --
  %#*   変更あり: *
        変更なし: (空白) 
  %r    書込可  : (空白)
        書込禁止: % 
  %#r   書込可        : (空白)
        書込禁止      : %
        不完全バッファ: # 
  %p    プログラム名 
  %v    バージョン 
  %h    ホスト名 
  %#h   @ホスト名 
  %b    バッファ名 
  %f    File: ファイル名 
  %#f   ファイル名 
  %F    File: ファイル名。ファイル名がなければバッファ名 
  %#F   ファイル名。ファイル名がなければバッファ名 
  %M    モード(マイナーモード含む) 
  %m    モード 
  %k    エンコーディング 
  %l    改行コード 
  %i    IMEの状態。mode-line-formatのみ。 
  %P    カーソル位置。mode-line-formatのみ。


■toggle-ime
[       type]: Function
[  arguments]: toggle-ime &optional ON-OR-OFF
[    package]: editor
[    seealso]: *ime-mode-hook* , get-ime-mode
[       file]: builtin.l
[    section]: キーマップ
[description]: 
IMEのON/OFFを制御します。
  non-nil  IMEをONにする
  nil      IMEをOFFにする
  省略時   IMEをトグルする


■toggle-over
[       type]: Function
[  arguments]: toggle-over &optional (ARG () SV)
[    package]: editor
[    seealso]: overwrite-mode
[       file]: cmds.l
[    section]: モード
[description]: 
上書き用マイナーモードを制御します。 [Insert]

  nil以外  上書きモードにする
  nil      挿入モードにする
  省略時   モードをトグルする


■toggle-read-only
[       type]: Function
[  arguments]: toggle-read-only &optional (ARG () SV)
[    package]: editor
[    seealso]: buffer-read-only
[       file]: buffer.l
[    section]: バッファ
[description]: 
バッファの書き込み禁止をトグルします。 [C-x C-q]


■toggle-session-auto-save
[       type]: Function
[  arguments]: toggle-session-auto-save &optional (ARG () SV)
[    package]: editor
[    seealso]: close-session , ed::*auto-save-session-file*
[       file]: session.l
[    section]: バッファ
[description]: 
セッションの自動保存フラグ (ed::*auto-save-session-file*) を切り替え
ます。 non-nil のときは、セッションを終了する際に自動でセッションファ
イルを上書きします。

ARG が与えられたとき (SV が non-nil のとき) は
  nil または負の整数 : nil にする
  それ以外           : t にする


■toggle-trace-on-error
[       type]: Function
[  arguments]: toggle-trace-on-error &optional (ARG () SVAR)
[    package]: editor
[    seealso]: ed::toggle-mode
[       file]: misc.l
[    section]: エラー
[description]: 
エラーをトレースするかどうかをトグルします。
On にする時にトレース用のバッファ *Trace Output* が無ければ新しく作ります。

前置引数をつけた場合、toggle-mode と同じような挙動をします。


■tool-bar-exist-p
[       type]: Function
[  arguments]: tool-bar-exist-p NAME
[    package]: editor
[       file]: builtin.l
[    section]: メニュー
[description]: 
指定されたツールバーNAMEが存在するか否かを返します。

  t    ツールバーが存在する。
  nil  ツールバー存在しない。


■tool-bar-info
[       type]: Function
[  arguments]: tool-bar-info NAME
[    package]: editor
[    seealso]: list-tool-bars
[       file]: builtin.l
[    section]: メニュー
[description]: 
指定したツールバーNAMEの情報を多値で返します。

形式：
  表示位置  :top        上側に表示
            :left       左側に表示
            :right      右側に表示
            :bottom     下側に表示
            nil         非表示
  横位置    横の位置を返す。
  縦位置    縦の位置を返す。
  横幅      タブバーの場合に左右に表示した場合の横幅を返す。
            ツールバーの場合はnilを返す。


■track-popup-menu
[       type]: Function
[  arguments]: track-popup-menu MENU &optional ANY
[    package]: editor
[    seealso]: create-popup-menu , define-popup-menu , popup-string
[       file]: builtin.l
[    section]: メニュー
[description]: 
フローティングポップアップメニューを表示します。選択されたコマン
ドを実行します。マウスボタンが押されていない場合はnilを返します。

  MENU : create-popup-menuもしくはdefine-popup-menuで作成された
         メニューを指定します。
  ANY  : どのようにポップアップするかを指定できます。
        :button1        マウスの位置にポップアップ
        :button2        マウスの位置にポップアップ
        上記以外        カーソルの位置にポップアップ


■transpose-chars
[       type]: Function
[  arguments]: transpose-chars &optional (ARG 1 F)
[    package]: editor
[    seealso]: transpose-region
[       file]: cmds.l
[    section]: テキスト
[description]: 
ポイントのひとつ前の文字を、ポイントの位置の文字と交換します。 [C-t]
ポイント自体はひとつ前に進みます。


■transpose-lines
[       type]: Function
[  arguments]: transpose-lines &optional (ARG 1)
[    package]: editor
[    seealso]: transpose-region
[       file]: cmds.l
[    section]: テキスト
[description]: 
カーソルのある行の一つ前の行と、そこから ARG 行先の行とを入れ換えます。[C-x C-t]
ただし ARG が 0 の場合にはマークの前の行と入れ換えます。


■transpose-paragraphs
[       type]: Function
[  arguments]: transpose-paragraphs &optional (ARG 1)
[    package]: editor
[    seealso]: transpose-region
[       file]: paragrph.l
[    section]: リージョン
[description]: 
段落を次の段落と交換します。


■transpose-region
[       type]: Function
[  arguments]: transpose-region MOVER ARG
[    package]: editor
[    seealso]: transpose-chars , transpose-words , transpose-lines , transpose-sexps , transpose-paragraphs
[       file]: cmds.l
[    section]: テキスト
[description]: 
リージョンを入れ換えます。入れ換えるリージョンは MOVER を funcall して
決定されます。

使用例： 
  (transpose-region 'forward-paragraph arg)


■transpose-words
[       type]: Function
[  arguments]: transpose-words &optional (ARG 1)
[    package]: editor
[    seealso]: transpose-region
[       file]: cmds.l
[    section]: 文字列
[description]: 
カーソル位置の単語を後方の単語と入れ換えます。[ESC t]


■trap-errors
[       type]: Macro
[  arguments]: trap-errors &body BODY
[    package]: editor
[    seealso]: handler-case , ignore-errors
[       file]: misc.l
[    section]: エラー
[description]: 
BODY 内でエラーが起こった場合もしくは中断（quit）された場合、
キャッチして trap-errors の外に影響がでないようにします。
handler-case の簡易版といえます。
ignore-errors と違い、エラーが発生したら表示されます。

使用例:
  ;; エラーが起きたらとりあえずキャッチして、その後の処理は続ける。
  (progn
    (trap-errors
      (/ 1 0))
    (msgbox "done."))


■truename
[       type]: Function
[  arguments]: truename PATHNAME
[    package]: lisp
[    seealso]: get-short-path-name
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
相対パスを絶対パスに変えます。

  PATHNAME : 変換するパスを指定します。

使用例：
  ;;; 相対パス及び絶対パスを指定して変換する。
  (truename ".")
  => "C:/applications/xyzzy"
  (truename "C:/applications/xyzzy/")
  => "C:/applications/xyzzy"


■truncate
[       type]: Function
[  arguments]: truncate NUMBER &optional DIVISOR
[    package]: lisp
[    seealso]: rem , floor , ceiling , round , ftruncate
[       file]: builtin.l
[    section]: 数値
[description]: 
NUMBERを0の方向に丸めます。

使用例：
  (truncate 2.8)
  => 2
  (truncate -2.8)
  => -2
  (multiple-value-list (truncate 2.8))
  => (2 0.8)


■two-way-stream-input-stream
[       type]: Function
[  arguments]: two-way-stream-input-stream TWO-WAY-STREAM
[    package]: lisp
[    seealso]: make-two-way-stream
[       file]: builtin.l
[    section]: 入出力
[description]: 
make-two-way-stream で作られた TWO-WAY-STREAM の入力元のストリームを返します。


■two-way-stream-output-stream
[       type]: Function
[  arguments]: two-way-stream-output-stream TWO-WAY-STREAM
[    package]: lisp
[    seealso]: make-two-way-stream
[       file]: builtin.l
[    section]: 入出力
[description]: 
make-two-way-stream で作られた TWO-WAY-STREAM の出力先のストリームを返します。


■type-of
[       type]: Function
[  arguments]: type-of OBJECT
[    package]: lisp
[    seealso]: 型一覧
[   referred]: coerce , typep
[       file]: builtin.l
[    section]: データ型
[description]: 
与えられたオブジェクトの型を返します。
(typep OBJECT (type-of OBJECT))は必ずtになります。

使用例：
  ;;; それぞれの型を調べてみる。
  (type-of 1)
  => integer
  (type-of 2.2)
  => single-float
  (type-of #'car)
  => compiled-function


■typep
[       type]: Function
[  arguments]: typep OBJECT TYPE
[    package]: lisp
[    seealso]: si:canonicalize-type , type-of , subtypep , deftype , 型一覧
[       file]: typespec.l
[    section]: データ型
[description]: 
OBJECT が TYPE の型であれば、non-nil な値を返します。

TYPE に与えることのできる引数には以下のようなものがあります。

1. 一般の型 
  builtin 関数（characterp、listp など）で判定します。

  'atom                'null           'ed:buffer
  'base-character      'number         'ed:marker
  'bignum              'package        'ed:process
  'character           'random-state   'ed:regexp
  'compiled-function   'ratio          'ed:syntax-table
  'cons                'real           'ed:menu
  'fixnum              'readtable      'ed:dde-handle
  'function            'sequence       'ed:window
  'hash-table          'stream         'ed:oledata
  'keyword             'symbol
  'list

2. 条件式・複合型
  条件を満たす場合に non-nil な値を返します。

  '(satisfies FUNC)      OBJECT を引数に FUNC を funcall した結果を返す
  '(member ELEMENTS)     OBJECT が ELEMENTS に含まれる
  '(eql OBJ)             OBJECT が OBJ に等しい
  '(not TYPE1)           OBJECT が TYPE2 の型でない
  '(and TYPE1 TYPE2 ...) OBJECT が TYPE1, TYPE2, ... すべての型である
  '(or TYPE1 TYPE2 ...)  OBJECT が TYPE1, TYPE2, ... いずれかの型である
  't                     常に真
  'nil                   常に偽

3. 文字
  'standard-char         文字のうち standard-char-p なもの
  'extended-char (*)     常に nil を返す（extended-char は存在しない？）

4. 数値
  範囲を指定できます。省略することも可能。
  MIN および MAX に、数値の代わりに * を与えると、
  下限（上限）を指定しなかったとみなされます。

  '(integer MIN MAX)
  '(float MIN MAX)
  '(rational MIN MAX)
  '(short-float MIN MAX)
  '(single-float MIN MAX)
  '(double-float MIN MAX)
  '(long-float MIN MAX)

  '(complex TYPE1)      integer 型、float 型などで区別可能。範囲指定はできない。

5. 一次元配列
  長さを指定できます。
  長さには整数値か * を指定します。省略も可能。

  '(simple-vector LENGTH)
  '(simple-string LENGTH)
  '(string LENGTH)
  
  '(vector TYPE1 LENGTH)       TYPE1 は t（普通のベクタ）または character（文字列）
  
6. 一次元以上の配列
  '(simple-array TYPE1 DIM)    TYPE1 は t（普通のベクタ）または character（文字列）
  '(array TYPE1 DIM)           DIM は次元

  '(simple-array TYPE1 (DIMS)) TYPE1 は t（普通のベクタ）または character（文字列）
  '(array TYPE1 (DIMS))        DIMS は各次元のサイズ（たとえば 2x3 なら (2 3) ）

7. defstruct で定義された構造体

使用例:
  ;; 一般の型
  (typep #\a 'character)
  => t
  (typep (selected-buffer) 'buffer)
  => t

  ;; 複合型
  (typep 3 '(satisfies oddp))       ; 奇数（関数 oddp による判定）
  => t
  (typep 'b '(member a b c))        ; a b c がリストとしてまとめられる
  => (b c)
  (typep 3 '(and atom number))      ; atom かつ number
  => t
  (typep 3 '(and atom number list)) ; atom かつ number かつ list
  => nil
  (typep 3 '(or atom number list))  ; atom または number または list
  => t

  ;; 数値
  (typep 3 'integer)                ; 範囲指定しないならリストにする必要なし
  => t
  (typep 3 '(integer 1 5))
  => t
  (typep x '(integer * 5))
  => t
  (typep x '(integer 5 *))
  => nil
  
  (typep #C(1 2) 'complex)
  => t
  (typep #C(1 2) '(complex float))
  => nil

  ;; 一次元配列
  (typep #(1 2 3) '(simple-vector 3))
  => t
  (typep #(1 2 3) '(vector t 3))
  => t
  (typep "abc" '(vector character 3))
  => t

  ;; 一次元以上の配列
  (setf a (make-array '(3 4)))
  => #2A((nil nil nil nil) (nil nil nil nil) (nil nil nil nil))
  (typep a '(array t *))     ; 次元を指定しない
  => t
  (typep a '(array t 2))     ; 2 次元配列
  => t
  (typep a '(array t (3 4))) ; サイズも一致
  => t
  (typep a '(array t (* 4))) ; サイズの一部だけを指定することも可能
  => t

  ;; 構造体
  (typep (selected-pseudo-frame) 'ed::pseudo-frame)
  => t


■undefine-key
[       type]: Function
[  arguments]: undefine-key KEYMAP KEY
[    package]: editor
[    seealso]: define-key
[       file]: keymap.l
[    section]: キーマップ
[description]: 
キーマップのキーの割り当てを解除します。

  KEYMAP : キーマップ
  KEY    : 削除するキー

使用例：
  ;;; C-lをfiler-reloadに割り当てて、解除してみる
  (define-key filer-keymap #\C-l 'filer-reload)
  => t
  (undefine-key filer-keymap #\C-l)
  => t


■undefined
[       type]: Function
[  arguments]: undefined
[    package]: editor
[    seealso]: ding
[   referred]: global-set-key
[       file]: cmds.l
[    section]: その他
[description]: 
ベルを鳴らします。 ding の interactive 版です。

キーにコマンドが割り当てられてないことを表すのに使われることがあるようです。


■undo
[       type]: Function
[  arguments]: undo
[    package]: editor
[    seealso]: buffer-can-undo-p , undo-boundary , clear-undo-boundary , kept-undo-information , redo , last-modified-point , *move-forward-after-undo-deletion*
[   referred]: *dabbrevs-no-undo*
[       file]: builtin.l
[    section]: バッファ
[description]: 
直前の操作を取り消します。[End], [C-\] 
UNDO情報の直近の境界まで戻ります。


■undo-boundary
[       type]: Function
[  arguments]: undo-boundary
[    package]: editor
[    seealso]: clear-undo-boundary , undo
[   referred]: kept-undo-information
[       file]: builtin.l
[    section]: バッファ
[description]: 
UNDO情報に境界を設定します。
以後undoを実行すると、この境界まで戻ります。


■unexport
[       type]: Function
[  arguments]: unexport SYMBOLS &optional PACKAGE
[    package]: lisp
[    seealso]: export , パッケージ
[       file]: builtin.l
[    section]: パッケージ
[description]: 
シンボルのリストを指定して、その全てのシンボルをパッケージの外部から参照
できないようにします。

  ;; find-file は editor パッケージの外部シンボル
  (find-symbol "find-file" "editor")
  =>find-file
    :external

  ;; よって editor パッケージを use している user パッケージから参照できる
  (find-symbol "find-file" "user")
  =>find-file
    :inherited

  ;; 外部から参照できなくする
  (unepxport 'find-file "editor")
  =>t

  ;; 内部シンボルになった
  (find-symbol "find-file" "editor")
  =>editor::find-file
    :internal

  ;; user パッケージから参照できなくなった
  (find-symbol "find-file" "user")
  =>nil
    nil

  ;; 元に戻す
  (export 'ed::find-file "editor")
  =>t


■unicode-char
[       type]: Function
[  arguments]: unicode-char CODE
[    package]: editor
[    seealso]: char-unicode , code-char , *unicode-to-half-width*
[   referred]: char-code
[       file]: builtin.l
[    section]: 文字
[description]: 
UNICODEのコード値に対応した文字を返します。

使用例：
  ;;; UNICODEから文字を出してみる。
  (unicode-char 28450)
  => #\漢


■unintern
[       type]: Function
[  arguments]: unintern SYMBOL &optional PACKAGE
[    package]: lisp
[    seealso]: intern
[   referred]: gensym
[       file]: builtin.l
[    section]: パッケージ
[description]: 
パッケージにシンボルがあれば削除してtを、なければnilを返します。


■uninterned
[       type]: Misc
[    seealso]: make-symbol , gensym
[   referred]: copy-symbol
[    section]: パッケージ
[description]: 
uninterned とは intern されていない状態を表します。
すなわちどのパッケージにも属していない状態です。

使用例：
  ;;; make-symbolでパッケージに属さないシンボルを作ってみる。
  (setq a (make-symbol "foo"))  => #:foo
  (symbol-package a)            => nil


■union
[       type]: Function
[  arguments]: union LIST1 LIST2 &rest REST &key :test :test-not :key
[    package]: lisp
[    seealso]: merge , nunion , intersection , set-difference , set-exclusive-or , ldiff , subsetp
[       file]: list.l
[    section]: リスト
[description]: 
LIST1 と LIST2 を併せたリストを作って返します。
nunion と違い引数 LIST1 は保存されます。

使用例:
  (union '(1 3 5 7 9) '(2 3 5 7 11))
  => (1 9 2 3 5 7 11)


■universal-argument
[       type]: Function
[  arguments]: universal-argument RAW &optional ARG
[    package]: editor
[    seealso]: digit-argument , negative-argument , *prefix-args* , *prefix-value*
[       file]: cmds.l
[    section]: 関数
[description]: 
後に続くコマンドに前置引数として 'universal-argument を渡します。[C-u]

'universal-agument を数値として処理する場合は 4 と解釈されます。


■unless
[       type]: Macro
[  arguments]: unless TEST &body BODY
[    package]: lisp
[    seealso]: when
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
条件が成立しない場合に実行します。whenの逆です。

  (unless 条件式  本体 ....)


■unread-char
[       type]: Function
[  arguments]: unread-char CHARACTER &optional INPUT-STREAM
[    package]: lisp
[       file]: builtin.l
[    section]: 入出力
[description]: 
入力ストリームに一文字戻します。

  CHARACTER    : 入力ストリームに戻す文字
  INPUT-STREAM : 入力ストリーム


■unregister-history-variable
[       type]: Function
[  arguments]: unregister-history-variable VAR
[    package]: editor
[    seealso]: define-history-variable , register-history-variable
[       file]: history.l
[    section]: 変数と定数
[description]: 
変数をヒストリ変数の登録から削除します。


■unset-marker
[       type]: Function
[  arguments]: unset-marker MARKER
[    package]: editor
[    seealso]: set-marker , delete-marker
[       file]: builtin.l
[    section]: ポジション
[description]: 
マーカーのポジションを解除します。
オブジェクトはマーカーとして残ります。

使用例：
  (unset-marker m)
  => t
  m
  => #<marker: *scratch*: ->


■unset-minor-mode-map
[       type]: Function
[  arguments]: unset-minor-mode-map KEYMAP &optional BUFFER
[    package]: editor
[    seealso]: set-minor-mode-map
[       file]: builtin.l
[    section]: モード
[description]: 
マイナーモード用のキーマップを解除します。


■unshift-region
[       type]: Function
[  arguments]: unshift-region START END &optional (COLUMN (TAB-COLUMNS (SELECTED-BUFFER)))
[    package]: editor
[    seealso]: shift-region
[       file]: region.l
[    section]: リージョン
[description]: 
STARTとENDがある行の範囲をCOLUMN桁だけインデントを戻します。


■untabify
[       type]: Function
[  arguments]: untabify FROM TO
[    package]: editor
[    seealso]: tabify
[   referred]: backward-delete-char-untabify
[       file]: cmds.l
[    section]: テキスト
[description]: 
FROM と TO の間にあるタブ文字を適当な数の半角スペースで置き換えます。


■unuse-package
[       type]: Function
[  arguments]: unuse-package PACKAGES-TO-UNUSE &optional PACKAGE
[    package]: lisp
[    seealso]: use-package
[       file]: builtin.l
[    section]: パッケージ
[description]: 
パッケージが別のパッケージを使用しないようにします。

使用例：
  ;;; 使用例はcalc.lを参照
  (unuse-package "lisp" *calc-package*)
  => t


■unwind-protect
[       type]: Special Form
[  arguments]: unwind-protect PROTECTED-FORM {CLEANUP-FORM}*
[    package]: lisp
[    seealso]: handler-case , ignore-errors
[   referred]: error
[       file]: builtin.l
[    section]: 制御構造
[description]: 
PROTECTED-FORM 中に終了もしくは例外が発生しても（正常、異常を問わず）
CLEANUP-FORM を実行します。

使用例：
  ;;; ゼロ除算が起きても CLEANUP-FORM が実行される。
  (progn
    (msgbox "計算前")
    (unwind-protect (/ 1 0)
      (msgbox "計算後")))
  => 0で除算しました: /: (1 0)


■up-list
[       type]: Function
[  arguments]: up-list &optional ARG NO-ERRORS
[    package]: editor
[    seealso]: forward-sexp , forward-list , down-list
[       file]: builtin.l
[    section]: ポジション
[description]: 
カーソルを ARG 個外側の括弧の後ろに移します。

  (setq lst '(a b c)) ; ここから
               ^
  (setq lst '(a b c)) ; ここへ
                    ^

ARG が負の場合には、前の方の括弧へ移動します。

  (setq lst '(a b c)) ; ここから
               ^
  (setq lst '(a b c)) ; ここへ
             ^

外側に括弧が見つからなかった場合、
NO-ERRORS が nil の場合にはエラーを、 t の場合には nil を返します。


■upcase-region
[       type]: Function
[  arguments]: upcase-region FROM TO
[    package]: editor
[    seealso]: upcase-word , capitalize-region , downcase-region
[       file]: builtin.l
[    section]: リージョン
[description]: 
リージョン内の単語を大文字にします。[C-x C-u]


■upcase-word
[       type]: Function
[  arguments]: upcase-word &optional (ARG 1)
[    package]: editor
[    seealso]: downcase-word , capitalize-word , upcase-region , upcase-selection , string-upcase
[       file]: cmds.l
[    section]: 文字列
[description]: 
カーソル位置から単語の末尾までを大文字に変換します。[ESC u]


■update-mode-line
[       type]: Function
[  arguments]: update-mode-line &optional BUFFER
[    package]: editor
[    seealso]: mode-line-format
[       file]: builtin.l
[    section]: その他
[description]: 
モード行を更新します。mode-line-formatの変更などを行った場合に、速やかに
モード行に反映したい場合に実行します。


■upper-case-p
[       type]: Function
[  arguments]: upper-case-p CHAR
[    package]: lisp
[    seealso]: lower-case-p , both-case-p , char-upcase
[       file]: builtin.l
[    section]: 文字
[description]: 
CHAR が大文字なら t 、そうでなければ nil を返します。

使用例：  
  (upper-case-p #\A)
  => t
  (upper-case-p #\a)
  => nil
  (upper-case-p #\RET)
  => nil


■use-keymap
[       type]: Function
[  arguments]: use-keymap KEYMAP &optional BUFFER
[    package]: editor
[    seealso]: make-keymap , define-key
[       file]: builtin.l
[    section]: キーマップ
[description]: 
バッファが使用するキーマップを設定します。

  KEYMAP : 使用するキーマップを指定します。
  BUFFER : バッファを指定します。省略時はカレントバッファに適用されます。

使用例：
  ;;; lispmode.lより
  (defun lisp-mode ()
    (interactive)
    (kill-all-local-variables)
    (setq buffer-mode 'lisp-mode)
    (setq mode-name "Lisp")
    (use-keymap *lisp-mode-map*)
    ...
    (run-hooks '*lisp-mode-hook*))


■use-local-menu
[       type]: Function
[  arguments]: use-local-menu MENU
[    package]: editor
[    seealso]: set-menu , current-menu , define-menu
[   referred]: create-menu
[       file]: builtin.l
[    section]: メニュー
[description]: 
カレントバッファにローカルなメニューを設定します。

  MENU : バッファにローカルなメニューを指定します。nilを設定するとローカ
         ルなメニューは解除され、デフォルトのメニューが使用されます。


■use-package
[       type]: Function
[  arguments]: use-package PACKAGES-TO-USE &optional PACKAGE
[    package]: lisp
[    seealso]: export , defpackage , パッケージ
[   referred]: in-package , package-use-list , package-used-by-list , unuse-package
[       file]: builtin.l
[    section]: パッケージ
[description]: 
指定されたパッケージ（省略された場合はカレントのパッケージ）が使
用する他のパッケージを設定します。


■use-syntax-table
[       type]: Function
[  arguments]: use-syntax-table SYNTAX-TABLE &optional BUFFER (INVALIDATE-P T)
[    package]: editor
[    seealso]: syntax-table-p , syntax-table
[   referred]: make-syntax-table
[       file]: builtin.l
[    section]: シンタックス
[description]: 
バッファで使用するシンタックステーブルを設定します。

使用例：
  ;;; lispmode.lの例
  (use-syntax-table *lisp-mode-syntax-table*)
  => t


■user-config-path
[       type]: Function
[  arguments]: user-config-path
[    package]: editor
[    seealso]: user-homedir-pathname , si:system-root
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
ユーザ設定を格納しているディレクトリを返します。
ダイアログでの規定値等が格納されるディレクトリです。

起動時オプション -config で指定したり，XYZZYCONFIGPATH
で指定可能です。両方指定された場合，起動時オプションが
優先されます。

使用例：
  (user-config-path)
  =>"H:/xyzzy/usr/Administrator/w2k/"


■user-homedir-pathname
[       type]: Function
[  arguments]: user-homedir-pathname
[    package]: lisp
[    seealso]: si:system-root , user-config-path
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
ユーザーのホームディレクトリを返します。

find-fileしたときに"~/"で参照可能なディレクトリです。
起動時に、このディレクトリに格納されている.xyzzyを読み込みます。
同一PCを複数人で使用していたり、ネットワーク共有されたフォルダに
xyzzyを格納した場合には、ユーザ毎にホームディレクトリの設定して
.xyzzyを切り替えることができます。

ユーザのホームディレクトリは、以下の順番で決定されます。

  1)iniファイル内の[init]homeDir
  2)環境変数 XYZZYHOME
  3)環境変数 HOME
  4)環境変数 HOMEDRIVE + HOMEPATH
  5)iniファイル内の[init]logDir
  6)xyzzy.exeのpath

使用例：
  (user-homedir-pathname)
  => "C:/HOME/"


■user-name
[       type]: Function
[  arguments]: user-name
[    package]: editor
[    seealso]: machine-name , si:getenv
[       file]: builtin.l
[    section]: システム
[description]: 
Windowsのログオンユーザー名を返します。


■uudecode-region
[       type]: Function
[  arguments]: uudecode-region FROM TO
[    package]: editor
[    seealso]: si:uudecode , uudecode-region-to-file
[       file]: encdec.l
[    section]: リージョン
[description]: 
リージョンをuudecodeします。


■uudecode-region-to-file
[       type]: Function
[  arguments]: uudecode-region-to-file FILENAME FROM TO
[    package]: editor
[    seealso]: si:uudecode , uudecode-region
[       file]: encdec.l
[    section]: リージョン
[description]: 
リージョンをuudecodeしてファイルに保存します。


■valid-path-p
[       type]: Function
[  arguments]: valid-path-p PATHNAME
[    package]: lisp
[    seealso]: check-valid-pathname , file-exist-p
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
パスが有効かどうかをチェックします。

  PATHNAME : 有効かどうかをチェックするパス

ここで「有効なパス」というのは、最終的なファイルやディレクトリが存在する
ことを指すのではなく、途中の経路が存在することを指します。ファイルを指し
示している場合には、そのファイル自体の有無は関係ありません。そのファイル
に至るディレクトリが全て存在していることが有効か否かに関わります。

使用例：
  (valid-path-p "foo/bar/zzz.txt")
  =>nil
  (valid-path-p "/autoexec.bat")
  =>t


■values
[       type]: Function
[  arguments]: values &rest ARGS
[    package]: lisp
[    seealso]: values-list , multiple-value-bind , multiple-value-list , multiple-value-setq
[   referred]: multiple-value-call , multiple-value-prog1
[       file]: evalmacs.l
[    section]: 変数と定数
[description]: 
多値で値を返します。

C言語では関数は1つの値しか返すことができませんが、Common Lispでは複数の
値を返す事ができます（リストとは違います）。これを多値（関数）と呼びます。
複数の値を返したい時は、 (values 値1 値2 ..)という構文を使います。

多値関数を呼び出す場合には、複数の戻り値を受け取れるように 
multiple-value-bind または multiple-value-listを使って受け取ります。

互換性：
  Common Lispとxyzzyにはあり。
  muleにはなさそう。


■values-list
[       type]: Function
[  arguments]: values-list LIST
[    package]: lisp
[    seealso]: values
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
指定されたリストを多値として返します。

  (values-list '(a b c)) == (values a b c)
  (values-list list) == (apply #'values list)


■vconcat
[       type]: Function
[  arguments]: vconcat &rest SEQ
[    package]: editor
[    seealso]: concatenate
[       file]: misc.l
[    section]: 配列
[description]: 
ベクタを連結します。

使用例:
  (vconcat #(1 3) #(2 5 7))
  => #(1 3 2 5 7)


■vector
[       type]: Function
[  arguments]: vector &rest LIST
[    package]: lisp
[    seealso]: svref , aref , setf , length , vector-pop , vector-push , vector-push-extend , vectorp , fill-pointer , make-vector , make-array
[       file]: array.l
[    section]: 配列
[description]: 
要素 LIST からなるベクタをつくります。

  (setf v (vector 1 2 "oop"))
  =>#(1 2 "oop")

ベクタの各要素にアクセスするためには、svref(あるいはaref)が使われます。


■vector-pop
[       type]: Function
[  arguments]: vector-pop VECTOR
[    package]: lisp
[    seealso]: fill-pointer , vector-push
[   referred]: vector
[       file]: builtin.l
[    section]: 配列
[description]: 
ベクタ（一次元配列） VECTOR のフィルポインタの位置の要素を取り除き、
その要素を返します。

VECTOR はフィルポインタを持っているベクタである必要があります。

使用例:
  ;; フィルポインタなし
  (setf x (make-array 5 :initial-contents '(a b c d e)))
  => #(a b c d e)
  (vector-pop x)
  => エラー

  ;; フィルポインタあり
  (setf x (make-array 5 :initial-contents '(a b c d e) :fill-pointer t))
  => #(a b c d e)
  (vector-pop x)
  => e
  x
  => #(a b c d)


■vector-push
[       type]: Function
[  arguments]: vector-push NEW-ELEMENT VECTOR
[    package]: lisp
[    seealso]: fill-pointer , vector-pop , vector-push-extend
[   referred]: vector
[       file]: builtin.l
[    section]: 配列
[description]: 
ベクタ（一次元配列） VECTOR のフィルポインタの次の位置に
新しい要素 NEW-ELEMENT を追加します。

VECTOR はフィルポインタを持っているベクタである必要があります。
フィルポインタが VECTOR の最後に達している場合には何もせず nil を返します。

使用例:
  ;; フィルポインタがベクタの長さに一致
  (setf x (make-vector 5 :initial-contents '(a b c d e) :fill-pointer t))
  => #(a b c d e)
  (fill-pointer x)
  => 5
  (vector-push 'xyz x)
  => nil
  x
  =>#(a b c d e)

  ;; フィルポインタがベクタの長さより小さい
  (setf x (make-vector 5 :initial-contents '(a b c d e) :fill-pointer 3))
  => #(a b c)
  (fill-pointer x)
  => 3
  (vector-push 'xyz x)
  => 3
  x
  => #(a b c xyz)


■vector-push-extend
[       type]: Function
[  arguments]: vector-push-extend NEW-ELEMENT VECTOR &optional EXTENSION
[    package]: lisp
[    seealso]: vector-push , adjustable-array-p , fill-pointer , vector
[       file]: builtin.l
[    section]: 配列
[description]: 
ベクタ VECTOR に新しい要素を追加します。長さが足りなければ拡張します。
VECTOR はフィルポインタを持ち、かつアジャスタブルなベクタである必要があります。

  NEW-ELEMENT：新しい要素 
  VECTOR     ：追加するベクタ
  EXTENSION  ：拡張する時のサイズ増加量。
               デフォルトでは 64 増えます。

使用例：
  ;;; 文字を要素とする長さ10のベクタを作成し文字を詰める。
  (setq vec (make-vector 10 :element-type 'character
                            :fill-pointer 0 :adjustable t))
  => ""
  (vector-push-extend #\a vec)  => 0
  vec                           => "a"
  (vector-push-extend #\b vec)  => 1
  vec                           => "ab"

  ;;; 文字を要素とする長さ10のベクタを作成し文字を詰める。
  (setq s (make-vector 10 :element-type 'character
                          :fill-pointer 0 :adjustable t))
  => ""
  (dotimes (i 20 s)
    (vector-push-extend (code-char (+ 64 i)) s)
    (vector-push-extend (code-char (+ 64 i)) s)
    (vector-push-extend (code-char (+ 64 i)) s))
  => "@@@AAABBBCCCDDDEEEFFFGGGHHHIIIJJJKKKLLLMMMNNNOOOPPPQQQRRRSSS"


■vectorp
[       type]: Function
[  arguments]: vectorp OBJECT
[    package]: lisp
[    seealso]: simple-vector-p , vector
[       file]: builtin.l
[    section]: データ型
[description]: 
OBJECTがvectorならt、それ以外ならnilを返します。


■verify-visited-file-modtime
[       type]: Function
[  arguments]: verify-visited-file-modtime &optional BUFFER
[    package]: editor
[    seealso]: verify-buffers-file-modtime , switch-to-buffer , find-file-verify , clear-visited-file-modtime , update-visited-file-modtime
[       file]: builtin.l
[    section]: バッファ
[description]: 
バッファがファイルに関連付けられていない、もしくはバッファとそれに関連付
けられたファイルとの更新時間が一致していると t を返します。バッファとそ
れに関連付けられたファイルとの更新時間が一致していない時、つまり他のプロ
セスによってファイルが変更された時などに nil を返します。

[       type]: BufferLocal
[    package]: editor
[    seealso]: verify-buffers-file-modtime , switch-to-buffer
[       file]: buffer.l
[    section]: バッファ
[description]: 
activate 時のバッファの最終更新日チェックを制御します。
  :auto    更新されていれば自動的に読み直す
  non-nil  チェックする
  nil      チェックしない


■version-up-xyzzy
[       type]: Function
[  arguments]: version-up-xyzzy &rest ARGS
[    package]: editor
[    seealso]: dump-xyzzy
[       file]: verup.l
[    section]: システム
[description]: 
亀井さんが配布しているxyzzyのアーカイブファイルをxyzzyがインストールされている
ディレクトリに展開します。
別途、ダンプファイルの再作成をする必要があります。


■view-register
[       type]: Function
[  arguments]: view-register R
[    package]: editor
[   referred]: ed::get-register , ed::set-register
[       file]: register.l
[    section]: その他
[description]: 
レジスタ R の中身をバッファ *output* に表示します。


■virtual-bolp
[       type]: Function
[  arguments]: virtual-bolp
[    package]: editor
[    seealso]: virtual-eolp
[       file]: builtin.l
[    section]: ポジション
[description]: 
仮想行の行頭にあるかを返します。
バッファが行を折り返して表示している場合に有効です。

  t     仮想行の行頭にある
  nil   仮想行の行頭にない


■virtual-eolp
[       type]: Function
[  arguments]: virtual-eolp
[    package]: editor
[    seealso]: virtual-bolp
[       file]: builtin.l
[    section]: ポジション
[description]: 
仮想行の行末にあるかを返します。
バッファが行を折り返して表示している場合に有効です。

  t     仮想行の行末にある
  nil   仮想行の行末にない


■what-cursor-position
[       type]: Function
[  arguments]: what-cursor-position
[    package]: editor
[    seealso]: iso-char-code , point , current-column , *status-bar-format*
[   referred]: goto-char
[       file]: cmds.l
[    section]: ポジション
[description]: 
カーソル位置の情報をステータスバーに表示します。[C-x =]
カーソル位置の文字の内部コード値、UNICODE値、
カーソル位置のバッファにおける位置、
桁数などが表示されます。

使用例:
  "w"の位置で情報を見る
  Char: w (0x77 / U+0077 / 0x77[us-ascii])  point=46 of 518(8%)  column 7

  "カ"の位置で情報を見る
  Char: カ (0x834a / U+30ab / 0x252b[jisx0208])  point=152 of 395(38%)  column 0


■when
[       type]: Macro
[  arguments]: when TEST &body BODY
[    package]: lisp
[   referred]: unless
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
条件がnilでなければフォームを連続して実行します。

  TEST : 条件部
  BODY : nilでない場合に実行するフォーム

whenはマクロです。以下の様に展開されます。

 (when exp1 exp2 exp3 ...)
 = (if exp1
      (progn exp2
             exp3
             ...))


■while
[       type]: Macro
[  arguments]: while TEST &body BODY
[    package]: lisp
[       file]: evalmacs.l
[    section]: 制御構造
[description]: 
条件節が成立する間、BODYを繰り返して実行します。
BODYの実行の途中でwhileを抜けるには、returnを使います。

  (while 条件 本体)

使用例：
  ;;; 確認しつつ処理を実行する場合
  (while (yes-or-no-p "次行に移動しますか？")
    (forward-line)
    (reverse-region (progn (goto-bol) (point))
                    (progn (goto-eol) (point)) t)
    (refresh-screen))
  => nil


■widen
[       type]: Function
[  arguments]: widen
[    package]: editor
[    seealso]: narrow-to-region
[       file]: builtin.l
[    section]: ポジション
[description]: 
narrow-to-regionで制限された領域を元に戻します。[C-x w]


■wild-pathname-p
[       type]: Function
[  arguments]: wild-pathname-p PATHNAME
[    package]: lisp
[    seealso]: *brackets-is-wildcard-character* , pathname-match-p
[       file]: builtin.l
[    section]: 変数と定数
[description]: 
ワイルドカード指定されたパスかどうかを返します。

  t     ワイルドカード指定されたパスです。
  nil   ワイルドカード指定されていません。

使用例：
  ;;; ワイルドカードかどうかを調べてみる。
  (wild-pathname-p "site-lisp/*.l")
  => t


■window-buffer
[       type]: Function
[  arguments]: window-buffer WINDOW
[    package]: editor
[    seealso]: get-buffer-window
[       file]: builtin.l
[    section]: バッファ
[description]: 
ウィンドウが表示しているバッファを返します。
  
使用例：
  (window-buffer (selected-window))


■window-columns
[       type]: Function
[  arguments]: window-columns &optional WINDOW
[    package]: editor
[    seealso]: window-width , window-lines , window-height
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
ウィンドウの文字を表示可能な領域の幅をキャラクタ単位で返します。
window-width が対象とする幅から、必要に応じて「行番号」表示領域、「折り
返し」マーク表示領域を除いた幅を計算対象とします。
キャラクタ幅に満たない幅については切り捨てますが、返す最小値は 1 です。

補足：
  具体的には、window-width の返す値から、「行番号」表示時は、行番号表示
  桁数 (xyzzy 0.2.2.233 では 6) ＋境界線分 (1) が引かれます。
  さらに、「折り返し」表示かつ、テキストの折り返しが「ウィンドウ幅」の場
  合には、「折り返し」マーク分 (1) が引かれます。


■window-coordinate
[       type]: Function
[  arguments]: window-coordinate &optional WINDOW
[    package]: editor
[    seealso]: window-width , window-height
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
指定されたウィンドウの座標をリストで返します。
(左端のx座標 左端のy座標 右端のx座標 右端のy座標)

座標軸は左上が (0 0) で右下にいくほど値が大きくなり、
単位はピクセルです。

使用例:
  (window-coordinate)
  => (0 0 693 636)


■window-height
[       type]: Function
[  arguments]: window-height &optional WINDOW
[    package]: editor
[    seealso]: window-lines , window-width , window-columns , screen-height
[   referred]: window-coordinate
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
ウィンドウの高さを行単位で返します。
部分的でなく完全に表示可能な行の数を返しますが、返す最小値は 1 です。
xyzzy 0.2.2.232 では内部的には window-lines と完全に同一定義です。

使用例：
  ;;; 現在のウィンドウを縦に半分にする。
  (split-window (- (floor (window-height) 2) 2))
  => t

補足：
  xyzzy 0.2.2.232 では内部的には window-lines と完全に同一定義ですが、
  window-height と window-lines は同一オブジェクトではありません。
  (eq #'window-height #'window-lines) => nil


■window-lines
[       type]: Function
[  arguments]: window-lines &optional WINDOW
[    package]: editor
[    seealso]: window-height , window-width , window-columns , get-window-line
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
ウィンドウの表示可能行数を返します。
部分的でなく完全に表示可能な行の数を返しますが、返す最小値は 1 です。
xyzzy 0.2.2.232 では内部的には window-height と完全に同一定義です。

使用例：
  (window-lines)
  => 18

補足：
  xyzzy 0.2.2.232 では内部的には window-height と完全に同一定義ですが、
  window-lines と window-height は同一オブジェクトではありません。
  (eq #'window-lines #'window-height) => nil


■window-width
[       type]: Function
[  arguments]: window-width &optional WINDOW
[    package]: editor
[    seealso]: window-columns , window-height , window-lines , screen-width
[   referred]: window-coordinate
[       file]: builtin.l
[    section]: ウィンドウ
[description]: 
ウィンドウの幅をキャラクタ単位で返します。
文字を表示可能な領域の幅ではなく、「行番号」表示領域、「折り返しマーク」
表示領域を含んだ領域についての幅を返します。
キャラクタ幅に満たない幅については切り捨てますが、返す最小値は 1 です。


■windowp
[       type]: Function
[  arguments]: windowp OBJECT
[    package]: editor
[       file]: builtin.l
[    section]: データ型
[description]: 
指定されたOBJECTがウィンドウかを返します。

  t     OBJECTがウィンドウ
  nil   OBJECTはウィンドウではない


■with-hash-table-iterator
[       type]: Macro
[  arguments]: with-hash-table-iterator (MNAME HASH-TABLE) &body BODY
[    package]: lisp
[    seealso]: maphash
[       file]: hash.l
[    section]: ハッシュ
[description]: 
ハッシュテーブルの要素を順番に返す関数を返してもらいます。

  MNAME      : 要素を順番に返す関数名を指定します。
               この関数は要素を列挙し終わるとnilを返します。
  HASH-TABLE : ハッシュテーブルを指定します。
  BODY       : フォームを記述します。

関数が順番に要素を返すので、loopを使ってnilが返るまで繰り返します。

使用例：
(with-hash-table-iterator (foo hsh)
  (loop
    (multiple-value-bind (f x y)
        (foo)
      (unless f (return))
      (format t "~S ~S~%" x y))))


■with-input-from-buffer
[       type]: Macro
[  arguments]: with-input-from-buffer (BUFFER &optional POINT EOB) &rest BODY
[    package]: editor
[    seealso]: with-output-to-buffer
[       file]: misc.l
[    section]: 入出力
[description]: 
バッファを入力ストリームとして扱えるようになり、
*standard-input*から読み込まれるようになります。

使用例：
  ;;; *scratch*の内容を*Output*に吐き出す。
  (with-output-to-buffer ((switch-to-buffer "*Output*"))
    (with-input-from-buffer ((switch-to-buffer "*scratch*"))
      (while (setq line (read-line *standard-input* nil))
        (princ line)
        (princ "\n"))))


■with-input-from-selected-buffer
[       type]: Macro
[  arguments]: with-input-from-selected-buffer &rest BODY
[    package]: editor
[       file]: misc.l
[    section]: 入出力
[description]: 
現在のバッファを標準入力にして読み込みます。

使用例：
  ;;; 現在のバッファから読み込んで変数に入れる。
  (with-input-from-selected-buffer
    (setq name (read) count (read) exp (read)))


■with-input-from-string
[       type]: Macro
[  arguments]: with-input-from-string (VAR STRING &key :index :start :end) &body BODY
[    package]: lisp
[    seealso]: make-string-input-stream , with-output-to-string
[       file]: stream.l
[    section]: 入出力
[description]: 
文字列を標準入力にして読み込みます。


■with-interval-message
[       type]: Macro
[  arguments]: with-interval-message (INTERVAL) &body BODY
[    package]: editor
[    seealso]: message
[       file]: misc.l
[    section]: 入出力
[description]: 
BODY 内で message コマンドによる表示の更新間隔を制限します。

  INTERVAL : 表示の最低更新間隔（ミリ秒）。
             前回 message を実行したときから INTERVAL ミリ秒以上経過していない場合、
             新たなメッセージを表示しません。

使用例:
  ;; 更新間隔を 100 ミリ秒にしてみる。
  (with-interval-message (100)
    (dotimes (i 100000)
      (message "~D" i)))


■with-open-file
[       type]: Macro
[  arguments]: with-open-file (STREAM FILENAME &rest OPTIONS) &body BODY
[    package]: lisp
[    seealso]: with-open-stream , open
[       file]: stream.l
[    section]: 入出力
[description]: 
指定されたファイルからストリームを作成し、本体を評価します。

  STREAM    : ストリームに束縛される変数
  FILENAME  : ストリームを作成するファイル名
  OPTIONS   : キーワード引数。open へ渡せるものと同じ
  BODY      : 実行する本体

使用例：
  (with-open-file (fp (merge-pathnames "lisp/henmi/c++-kwd.txt" (si:system-root)))
    (let ((line nil))
      (while (setq line (read-line fp nil nil nil))
        (push line *kekka*))))


■with-open-stream
[       type]: Macro
[  arguments]: with-open-stream (VAR STREAM) &body BODY
[    package]: lisp
[    seealso]: with-open-file , connect
[   referred]: open
[       file]: stream.l
[    section]: 入出力
[description]: 
局所変数をストリームに束縛して本体を評価し、ストリームを閉じます。

参考：
  connect の例を参照のこと


■with-output-to-buffer
[       type]: Macro
[  arguments]: with-output-to-buffer (BUFFER &optional POINT) &rest BODY
[    package]: editor
[    seealso]: with-output-to-selected-buffer , with-output-to-temp-buffer
[   referred]: with-input-from-buffer
[       file]: misc.l
[    section]: 入出力
[description]: 
標準出力を指定されたバッファにリダイレクトします。

  BUFFER : 出力するバッファ
  POINT  : 出力をするポイントを指定します。
           指定しない場合には、バッファの先頭から出力されます。
  BODY   : 実行するフォーム

使用例：
  ;;; *scratch*に書き出してみる。
  (with-output-to-buffer ((find-buffer "*scratch*"))
     (format t "foo~%")
     (format t "bar~%"))


■with-output-to-selected-buffer
[       type]: Function
[  arguments]: with-output-to-selected-buffer &rest BODY
[    package]: editor
[    seealso]: with-output-to-buffer
[       file]: misc.l
[    section]: 入出力
[description]: 
標準出力をカレントバッファにリダイレクトします。
ポイントがある位置から出力されます。
  
使用例：
  ;;; カレントバッファに書き出してみる。
  (with-output-to-selected-buffer
     (format t "foo~%")
     (format t "bar~%"))


■with-output-to-string
[       type]: Macro
[  arguments]: with-output-to-string (VAR &optional STRING) &body BODY
[    package]: lisp
[    seealso]: make-string-output-stream , with-input-from-string
[       file]: stream.l
[    section]: 入出力
[description]: 
文字列を出力するストリームを作成します。

使用例：
  ;;; ストリームを使って文字列を出力してみる。
  (setq var
        (with-output-to-string (out)
          (prin1 "test" out)))
  => "test"


■with-output-to-temp-buffer
[       type]: Macro
[  arguments]: with-output-to-temp-buffer (BUFNAME &optional (POPUP t)) &rest BODY
[    package]: editor
[    seealso]: with-output-to-buffer
[       file]: misc.l
[    section]: 入出力
[description]: 
指定されたバッファを作成し、標準出力をそのバッファにリダイレクトします。
同じ名前のバッファがあった場合には、そのバッファの内容は破棄されます。
単に処理結果だけを書き込むような場合に便利です。

  BUFNAME : バッファの名前を指定します。
  POPUP   : バッファを分割表示する際の行数／列数を指定します。
        t       ニ分割します。
        整数    指定行数／列数で分割します。
        nil     バッファを分割表示しません。
  VERT-P  : バッファの分割方法を指定します。
            POPUP が nil の場合は意味を持ちません。
        non-nil 左右にバッファを分割します。
        nil     上下にバッファを分割します。

使用例：
  ;;; *Help*を作ってそこに書き出してみる。
  (with-output-to-temp-buffer ("*Help*")
     (format t "foo~%")
     (format t "bar~%"))

互換性：
   muleにもCommon Lispにもありません。


■with-package-iterator
[       type]: Macro
[  arguments]: with-package-iterator (MNAME PACKAGE-LIST &rest SYMBOL-TYPE) &body BODY
[    package]: lisp
[    seealso]: do-all-symbols
[       file]: package.l
[    section]: パッケージ
[description]: 
指定されたパッケージのシンボルを列挙する関数を作ってもらいます。
作られた関数を呼び出すたびにシンボルが列挙されます。

  MNAME        : シンボルを返す関数名を指定します。
  PACKAGE-LIST : パッケージのリストを指定します。
  SYMBOL-TYPE  : どんなシンボルを返すかを指定するようです。

使用例：
  ;;; 全シンボルを列挙します。
  ;;; 呼ぶたびに次のシンボルを返すfooという関数を定義してもらう。
  (with-package-iterator (foo (list-all-packages) :internal :external)
    (loop
      (multiple-value-bind (f sym type package)
          (foo)             ; 呼ぶと次のシンボルが返ってくる。
        (unless f           ; なければ終わり。
          (return))
        (and (or (boundp sym)
                 (fboundp sym))
             (format t "~:[ ~;V~]~:[ ~;F~]~:[ ~;M~] ~A ~S ~S~%"
                     (boundp sym)
                     (fboundp sym)
                     (macro-function sym)
                     (package-name package)
                     sym
                     type)))))


■with-selected-window
[       type]: Macro
[  arguments]: with-selected-window &body BODY
[    package]: editor
[    seealso]: set-window , save-window-excursion
[       file]: misc.l
[    section]: ウィンドウ
[description]: 
BODY の前後でカレントウィンドウを保存します。
すなわち、BODY 実行中にウィンドウを移動しても、実行後に元のウィンドウに戻ります。


■with-set-buffer
[       type]: Macro
[  arguments]: with-set-buffer &body BODY
[    package]: editor
[    seealso]: set-buffer
[       file]: misc.l
[    section]: バッファ
[description]: 
BODY を実行する際に、ポイントがミニバッファ以外にあることを保証します。
ポイントがミニバッファにあった場合、BODY を実行した後ポイントはミニバッファに戻ります。

ミニバッファで set-buffer するとエラーが起きるので、それを回避するためにあるようです。

使用例:
  ;; lisp/misc.l より
  (defun setup-temp-buffer (buffer)
    (with-set-buffer
      (save-excursion
        (set-buffer buffer)
        (setq buffer-read-only nil)
        (setq need-not-save t)
        (setq kept-undo-information nil)
        (setq auto-save nil))))


■word-char-p
[       type]: Function
[  arguments]: word-char-p CHAR
[    package]: editor
[    seealso]: syntax-word-p , characterp
[       file]: builtin.l
[    section]: データ型
[description]: 
CHAR が単語構成文字かどうかを判定します。


■write
[       type]: Function
[  arguments]: write OBJECT &key :stream :escape :pretty :base :radix :circle :level :length :readably
[    package]: lisp
[    seealso]: read
[       file]: builtin.l
[    section]: 入出力
[description]: 
OBJECTを印字表現でストリームに出力します。

  OBJECT       : 出力するオブジェクトを指定します。

  :stream      : 出力するストリームを指定します。
                 省略すると*standard-output*に出力します。

  :escape      : エスケープするかどうか指定します。
                 デフォルトの値は*print-escape*です。
        non-nil  prin1やformat指定子の~Sと同じように出力されます。
        nil      princやformat指定子の~Aと同じように出力されます。

  :pretty      : 式の表示を見やすくするかどうかを指定します。
                 デフォルトの値は*print-pretty*です。
        non-nil  見やすくします。
        nil      見やすくしません。

  :base        : 基数を指定します。
                 2〜36までを指定でき、それ以外は10進数になります。
                 デフォルトの値は*print-base*です。

  :radix       : 基数を主力するかどうかを指定します。
                 デフォルトの値は*print-radix*です。
        non-nil  #(基数)r(数)の形で出力します。
                 10進数の時はこの形ではなく、最後に . が付きます。
                 2進数,8進数,16進数の基数はそれぞれ、b,o,xと表示され、
                 それ以外の時は基数自体は10進数で表示されます。
        nil      数のみ出力します。

  :circle      : 循環リストを考慮するかどうかを指定します。
                 デフォルトの値は*print-circle*です。
        non-nil  考慮し、#1=(a . #1#) のような形で表示します。
        nil      考慮しません。無限に表示されるのでC-gで止める必要があります。

  :level       : リスト出力の深さの制限を指定します。
                 制限よりも深い位置にあるリストは、#で表示されます。
                 デフォルトの値は*print-level*です。

  :length      : リスト出力の長さの制限を指定します。
                 制限よりも長いリストは途中で打ち切られ、
                 ... で表示されます。
                 デフォルトの値は*print-length*です。

  :readably    : 読めるように出力します。
                 デフォルトの値は*print-readably*です。
        non-nil  :lengthや:levelのnon-nil指定を無効にし、
                 :escapeがnilでもnon-nilを指定したように出力します。


■write-char
[       type]: Function
[  arguments]: write-char CHARACTER &optional OUTPUT-STREAM
[    package]: lisp
[    seealso]: read-char
[       file]: builtin.l
[    section]: 入出力
[description]: 
OUTPUT-STREAM に CHARACTER を出力し、その CHARACTER を返します。


■write-file
[       type]: Function
[  arguments]: write-file FILENAME &optional NOMSG APPEND CHAR-ENCODING EOL-CODE
[    package]: editor
[    seealso]: append-file , save-buffer , emacs-write-file , *default-write-file-directory*
[       file]: files.l
[    section]: ファイルシステム
[description]: 
バッファの内容を FILENAME に書き込みます。[C-x C-w]
バッファ名およびバッファに関連付けられたファイルは変更しません。

  NOMSG         : non-nil ならステータスバーに経過メッセージを表示しません。
  APPEND        : non-nil ならファイルに追加します。
  CHAR-ENCODING : エンコーディングを指定します。
  EOL-CODE      : 改行コードを指定します。


■write-region
[       type]: Function
[  arguments]: write-region FROM TO FILENAME &optional APPEND CHAR-ENCODING EOL-CODE
[    package]: editor
[       file]: builtin.l
[    section]: ファイルシステム
[description]: 
リージョンをファイルに書き込みます。
APPEND が non nil なら追加書き込みをします。


■write-registry
[       type]: Function
[  arguments]: write-registry SECTION KEY VALUE
[    package]: editor
[    seealso]: read-registry
[       file]: builtin.l
[    section]: システム
[description]: 
レジストリに書き込みます。

  SECTION : セクションを指定します。
  KEY     : キーを指定します。
  VALUE   : 値を指定します。

使用例：
  ;;; HKEY_CURRENT_USER\Software\Free Software\Xyzzy の下にデータを書き込む
  (write-registry "software\\chombo\\altime" "aaa" 64)

  以下のように書き込まれます。
-----
REGEDIT4

[HKEY_CURRENT_USER\Software\Free Software\Xyzzy\software\chombo\altime]
"aaa"=dword:00000040
-----


■wrong-disk
[       type]: Misc
[    package]: lisp
[    seealso]: wrong-disk-pathname
[    section]: ファイルシステム
[description]: 
注）どこにもみつからない？


■wrong-disk-pathname
[       type]: Function
[  arguments]: wrong-disk-pathname X
[    package]: lisp
[   referred]: wrong-disk
[    section]: ファイルシステム
[description]: 
注）どこにもみつからない？


■xyzzy-dumped-p
[       type]: Function
[  arguments]: xyzzy-dumped-p
[    package]: editor
[    seealso]: dump-xyzzy
[       file]: builtin.l
[    section]: システム
[description]: 
起動時にxyzzyがダンプ済みかどうかを返します。

  t     ダンプ済み
  nil   ダンプ済みではない

ダンプ作業をしても再起動するまでは戻り値はtになりません。


■xyzzyで提供されているストリームの種類
[       type]: Tips
[    seealso]: open , make-string-input-stream , make-string-output-stream , make-synonym-stream , make-broadcast-stream , make-concatenated-stream , make-echo-stream , make-two-way-stream , make-buffer-stream , connect , stream-encoding , set-stream-encoding
[   referred]: buffer-stream-buffer , buffer-stream-p , buffer-stream-point , buffer-stream-set-point
[    section]: 入出力
[description]: 
（途中）
以下はxyzzyで提供されているストリームの種類です。

  Commonと同じ
  ---------------------------------------------
  file-input-stream       open
  file-output-stream      open
  file-io-stream          open
  string-input-stream     make-string-input-stream
  string-output-stream    make-string-output-stream
  synonym-stream          make-synonym-stream
  broadcast-stream        make-broadcast-stream
  concatenated-stream     make-concatenated-stream
  echo-stream             make-echo-stream
  two-way-stream          make-two-way-stream
  ---------------------------------------------

synonym-stream以降は使ったことないんで(^^;、動くかどうか分からないんです
が多分動くでしょう(^^)。

  独自
  ---------------------------------------------
  buffer-stream           make-buffer-stream
  status-window-stream    なし
  keyboard-stream         なし
  wstreams-stream         なし
  ---------------------------------------------

独自ストリームの概要：
  buffer-stream
    バッファをストリームとみなして入出力どっちでもできます。  
  status-window-stream
    ステータスウィンドウをストリームとみなして出力ができます。
    グローバル変数*status-window*の値です。
  keyboard-stream
    キーボードをストリームとみなして入力ができます。
    グローバル変数*keyboard*の値です。
  wstreams-stream
    formatからコールバックが呼ばれたときのstreamの実体。


■y-or-n-p
[       type]: Function
[  arguments]: y-or-n-p FMT &rest ARGS
[    package]: lisp
[    seealso]: yes-or-no-p , no-or-yes-p , yes-no-or-cancel-p
[       file]: misc.l
[    section]: ミニバッファ
[description]: 
ミニバッファにメッセージを表示してユーザーが'y'か'n'を入力するのを待ちます。

  t     'y'を押下した
  nil   'n'を押下した

使用例：
  ;;; "Foo: (y or n) "と表示して選択させる。
  (y-or-n-p "Foo: ")
  => t          ; 'y'を押下


■yank
[       type]: Function
[  arguments]: yank &optional PREFIX (ARG 0)
[    package]: editor
[    seealso]: *kill-ring* , yank-pop , yank-rectangle
[       file]: region.l
[    section]: リージョン
[description]: 
*kill-ring*の先頭の要素を挿入します。[C-y]


■yank-and-pop
[       type]: Function
[  arguments]: yank-and-pop &optional PREFIX (ARG 0)
[    package]: editor
[    seealso]: yank-pop
[       file]: region.l
[    section]: リージョン
[description]: 
*kill-ring*の先頭の要素をyankした後に、先頭の要素を*kill-ring*からpopします。
*kill-ring*は一要素分短くなります。


■yank-pop
[       type]: Function
[  arguments]: yank-pop &optional (ARG 1)
[    package]: editor
[    seealso]: yank
[   referred]: yank-and-pop
[       file]: region.l
[    section]: リージョン
[description]: 
次の要素をyankします。 [ESC y]
直前のコマンドがyankならば*kill-ring*のポインターをずらして、次の要素
でyankをし直します。


■yank-rectangle
[       type]: Function
[  arguments]: yank-rectangle
[    package]: editor
[    seealso]: kill-rectangle , yank-rectangle-selection , yank-rectangle-as-region
[   referred]: *rectangle-kill-buffer* , yank
[       file]: rectangl.l
[    section]: リージョン
[description]: 
copy-rectangleやkill-rectangleによって選択された領域を矩形挿入します。
yank-rectangle-selectionのInsert相当の機能のようです。


■yank-rectangle-as-region
[       type]: Function
[  arguments]: yank-rectangle-as-region
[    package]: editor
[    seealso]: yank-rectangle
[       file]: rectangl.l
[    section]: リージョン
[description]: 
copy-rectangleで切り取った矩形領域を、
連続した一連の文字列として挿入します。

  ABCDEFG ;
  HIJKLMN ; JKL
  OPQRSTU ; QRS
  VWXYZ   ; XYZの領域をcopy-rectangle

  (yank-rectangle)
  =>JKL
    QRS
    XYZ

  (yank-rectangle-as-region)
  =>JKLQRSXYZ


■yank-rectangle-selection
[       type]: Function
[  arguments]: yank-rectangle-selection &optional ARG
[    package]: editor
[    seealso]: yank-rectangle , kill-rectangle-selection
[       file]: select.l
[    section]: リージョン
[description]: 
マウスで矩形選択されたセレクションの領域をyankします。[S-F9]
実行後にどのようにyankするかを質問されます。
  F6    Cancel                  yank中止
  F7    Append                  行末に追加
  F8    Overwrite               上書き
  F9    Insert                  挿入
  F10   Insert as region        文字列にして挿入


■yank-selection
[       type]: Function
[  arguments]: yank-selection &optional (ARG 0)
[    package]: editor
[    seealso]: kill-selection , copy-selection
[   referred]: *selection-ring* , yank-selection-and-pop
[       file]: select.l
[    section]: リージョン
[description]: 
*selection-ring*の先頭の要素を貼り付けます。[F9]
*selection-ring*へはcopy-selectionもしくはkill-selectionで追加します。


■yank-selection-and-pop
[       type]: Function
[  arguments]: yank-selection-and-pop &optional (ARG 0)
[    package]: editor
[    seealso]: yank-selection
[       file]: select.l
[    section]: リージョン
[description]: 
*selection-ring*の先頭の要素をyank-selectionした後に、
先頭の要素を*selection-ring*からpopします。
*selection-ring*は一要素分短くなります。


■yank-to-clipboard
[       type]: Function
[  arguments]: yank-to-clipboard &optional (ARG 1)
[    package]: editor
[    seealso]: copy-to-clipboard
[       file]: region.l
[    section]: リージョン
[description]: 
*kill-ring*の内容をクリップボードに複写します。


■yes-no-or-cancel-p
[       type]: Function
[  arguments]: yes-no-or-cancel-p FMT &rest ARGS
[    package]: lisp
[    seealso]: yes-or-no-p , no-or-yes-p , y-or-n-p
[       file]: misc.l
[    section]: ダイアログ
[description]: 
「はい」「いいえ」「キャンセル」のボタン付メッセージボックスを表示します。
デフォルトは「はい」です。「キャンセル」を選択した場合には、quitが実行されます。

  t     「はい」を選択
  nil   「いいえ」を選択

使用例：
  ;;; ダイアログを表示して選択させる。
  (yes-no-or-cancel-p "foo")
  => t          ; 「はい」を選択
  (yes-no-or-cancel-p "foo")
  => nil        ; 「いいえ」を選択


■yes-or-no-p
[       type]: Function
[  arguments]: yes-or-no-p FMT &rest ARGS
[    package]: lisp
[    seealso]: no-or-yes-p , y-or-n-p , yes-no-or-cancel-p , message-box
[       file]: misc.l
[    section]: ダイアログ
[description]: 
「はい」「いいえ」のボタン付メッセージボックスを表示します。デフォルトは
「はい」です。

  FMT  : format同様の書式が指定できます。
  ARGS : 出力書式へのパラメタとなります。

戻り値は以下のとおりです。

  t     「はい」を選択
  nil   「いいえ」を選択

使用例：
  ;;; ダイアログを表示して選択させる。
  (yes-or-no-p "foo")
  => t          ; 「はい」を選択
  (yes-or-no-p "~A" "hogehoge")  
  => nil        ; 「いいえ」を選択


■zap-to-char
[       type]: Function
[  arguments]: zap-to-char C &optional (N 1)
[    package]: editor
[    seealso]: kill-region
[       file]: cmds.l
[    section]: 文字
[description]: 
ポイントから指定されたキャラクタまでをkillします。[ESC z]


■zerop
[       type]: Function
[  arguments]: zerop NUMBER
[    package]: lisp
[       file]: builtin.l
[    section]: 数値
[description]: 
NUMBERがゼロならt、そうでなければnilを返します。

使用例：  
  (zerop 0)
  => t
  (zerop 1)
  => nil
  (zerop 0.0)
  => t
  (zerop -0.00)
  => t


■どの関数の頭に何がつくのでしょうか？
[       type]: Tips
[    seealso]: パッケージの概要
[   referred]: export , パッケージ
[    section]: パッケージ
[description]: 
| パッケージという概念に関係があるんだと思いますが、どの関数の頭に何がつくの
| かというのはどこを見ればわかるんでしょうか。

  M-x apropos make-chunk RET

としたときに、

  system:make-chunk

のように表示されるものはパッケージが必要なものです。ちなみに、
si は system パッケージの、c は foreign パッケージのニックネー
ムです。
----------------------------------

  editor::xyzzy-mode  `:'が2つ表示される場合はexportされていない
        ^^
  editor:xyzzy-mode   `:'が1つ表示される場合はexportされている
        ^
  xyzzy-mode          パッケージが表示されない場合は現在のパッケージから
                      直接アクセスできる


■エラー処理関係
[       type]: Tips
[   referred]: define-condition , error , handler-case , ignore-errors , make-condition
[    section]: エラー
[description]: 
エラーの種類のツリー（階層）です。

condition
├simple-condition
├serious-condition
│├error
││├simple-error
│││└plain-error
││├arithmetic-error
│││├division-by-zero
│││├floating-point-overflow
│││├floating-point-underflow
│││├domain-error
│││├bignum-overflow
│││└power-number-too-large
││├cell-error
│││├unbound-variable
│││├modify-constant
│││└undefined-function
││├control-error
│││└target-missing
││├file-error
│││├file-not-found
│││├path-not-found
│││├access-denied
│││├invalid-drive
│││├current-directory
│││├not-same-device
│││├write-protected
│││├bad-unit
│││├device-not-ready
│││├sharing-violation
│││├lock-violation
│││├wrong-disk
│││├file-exists
│││├not-empty
│││├archiver-error
│││├network-error
│││└file-lost-error
││├package-error
│││└simple-package-error
││├program-error
│││├no-target
│││├bad-macro-form
│││├invalid-function
│││├invalid-variable-list
│││├invalid-lambda-list
│││└invalid-keyword-list
││├type-error
││├range-error
││├stream-error
│││└end-of-file
││├reader-error
││├too-few-arguments
││├too-many-arguments
││├bad-type-specifier
││├read-only-buffer
││└dde-error
││  ├dde-timeout
││  ├dde-busy
││  ├dde-low-memory
││  ├dde-no-conv
││  ├dde-not-processed
││  ├dde-server-died
││  └dde-terminated-transaction
│├storage-condition
│├stack-overflow
│└invalid-byte-code
├quit
│└silent-quit
└warning
  └simple-warning


| xyzzyはもちろん、Emacs Lispでなくて Common Lispに合わせているんですよね。

そうです。コンディションタイプには独自のがありますけど。Stallman先生は、
直接ではないですがCommonのコンディションシステムに影響を与えているらしい
ので、仕組み的には似てます。

| コンディションって何ですか？

Commonでは、エラーと言わずにコンディションと言うらしいです(エラー以外も
投げられるから?)。簡単に言うとC++のtry-catchと同じです(多分、C++がパクっ
たんだろうけど)。

  class condition {};
  class serious_condition: public condition {};
  class error: public serious_condition {};
  class arithmetic_error: public error {};
  class division_by_zero: public arithmetic_error {};

ってのがある場合、

  throw division_by_zero;

とすると、

  try {...} catch (division_by_zero &) {...}

でも、

  try {...} catch (error &) {...}

でも、

  try {...} catch (condition &) {...}

でも捕まえられますよね?
それと同様に

  (error 'division-by-zero)

は、

  (handler-case ... (division-by-zero (c) ...))
  (handler-case ... (error (c) ...))
  (handler-case ... (condition (c) ...))

どれででも捕まえることができます。ま、名前が違うだけでEmacsの
condition-caseと同じです(多分)。catch&throwのタグに継承関係を付けた
のとも同じかも。

また、Emacsでできるかどうかは知りませんが、↓な感じで次のキャッチャにコ
ンディションを渡すこともできます。

  (handler-case
      (any-expression)
    (error (c)
      (some-expression)
      (error c)))

C++での
  try
    {
      any-expression;
    }
  catch (error &)
    {
      some-expression;
      throw;
    }
と同じですけど。


■キーワードファイルの書き方
[       type]: Tips
[   referred]: *keyword-load-path* , load-keyword-file
[    section]: その他
[description]: 
キーワードファイルは*keyword-load-path*もしくはetc-pathから検索
をします。$XYZZY/etc配下のファイルを参照して下さい。

形式：
  属性を指定する場合には以下の二つの形式で記述します。

  ;*n[attrib]
  ;**fg[bg[attrib]]

      n       キーワード番号(0-5) 3-5は0-2と同じ色の反転
      fg      文字色 0-f (0ならば普通の色)
      bg      背景色 0-f (0ならば普通の色）
      attrib  属性みたいなもの。以下のものの組み合わせ
              b bold
              u underline
              s strike-out
              l 一行丸ごと
条件：
  xyzzy 0.2.207からload-keyword-fileにconditionを指定する
  ことが可能になりました。conditionはitemと比較を行います。
  $XYZZY/lisp/html-kwd.lを参照

  ;*+         conditionに関わらず以降を有効にする
  ;*-         conditionに関わらず以降を無効にする
  ;*+item     itemがconditionに一致した場合に以降を有効にする
  ;*-item     itemがconditionに一致した場合に以降を無効にする
  ;*&         以降はHTMLのタグ以外でも有効なキーワードとする
  ;*<         以降はHTMLのタグでのみ有効なキーワードとする


■キー表現使用可能文字
[       type]: Tips
[    seealso]: global-set-key , define-key , *kbd-translate-table*
[    section]: キーマップ
[description]: 
#\aや#\C-bのように文字として表現します。ただし、\"'(),;`| の9文字は、
lispの構文上の特別な意味があるので、それを抑制するために'\'を前置します。

  #\a           ; a
  #\;           ; ;
  #\C-b         ; Ctrl+b
  #\C-\;        ; Ctrl+;
  #\M-\;        ; Alt+;
  #\C-M-\;      ; Ctrl+Alt+;

Ctrl、Alt、Shiftの同時押しも表現できます。C-、M-、S-の順番は何でも良いです。

  #\C-          ; Ctrl同時押し
  #\S-          ; Shift同時押し
  #\C-S-        ; Ctrl+Shift同時押し
  #\M-          ; Alt同時押し
  #\M-C-        ; Alt+Ctrl同時押し
  #\M-S-        ; Alt+Shift同時押し
  #\M-C-S-      ; Alt+Ctrl+Shift同時押し


キーによっては同時押しできるキーに制限があります。
例えばS-TABは普通のやり方ではできません。どうしてもやりたければ、
set-extended-key-translate-table を参照して下さい。

  ┌─────────────┬─────────────┐
  │キー                      │同時押しできるキー        │
  │                          ├─┬─┬─┬─┬─┬─┬─┤
  │                          │M │C │M │S │C │M │M │
  │                          │  │  │C │  │S │S │C │
  │                          │  │  │  │  │  │  │S │
  ├─────────────┼─┼─┼─┼─┼─┼─┼─┤
  │ !"#$%&'()*+,-./          │○│○│○│Ｘ│Ｘ│Ｘ│Ｘ│
  │0123456789:;<=>?          │  │  │  │  │  │  │  │
  │@ABCDEFGHIJKLMNO          │  │  │  │  │  │  │  │
  │PQRSTUVWXYZ[\]^_          │  │  │  │  │  │  │  │
  │`abcdefghijklmno          │  │  │  │  │  │  │  │
  │pqrstuvwxyz{|}~           │  │  │  │  │  │  │  │
  ├─────────────┼─┼─┼─┼─┼─┼─┼─┤
  │SPC       スペースキー    │○│○│Ｘ│Ｘ│Ｘ│Ｘ│Ｘ│
  ├─────────────┼─┼─┼─┼─┼─┼─┼─┤
  │TAB       Tabキー         │○│Ｘ│Ｘ│Ｘ│Ｘ│Ｘ│Ｘ│
  │LFD                       │  │  │  │  │  │  │  │
  │RET       Enterキー       │  │  │  │  │  │  │  │
  │ESC       Escキー         │  │  │  │  │  │  │  │
  │DEL                       │  │  │  │  │  │  │  │
  │NUL                       │  │  │  │  │  │  │  │
  ├─────────────┼─┼─┼─┼─┼─┼─┼─┤
  │PageUp    Page Upキー     │○│○│○│○│○│○│○│
  │PageDown  Page Downキー   │  │  │  │  │  │  │  │
  │End       Endキー         │  │  │  │  │  │  │  │
  │Home      Homeキー        │  │  │  │  │  │  │  │
  │Left      ←キー          │  │  │  │  │  │  │  │
  │Up        ↑キー          │  │  │  │  │  │  │  │
  │Right     →キー          │  │  │  │  │  │  │  │
  │Down      ↓キー          │  │  │  │  │  │  │  │
  │Pause     Pauseキー       │  │  │  │  │  │  │  │
  │Scroll    ScrollLockキー  │  │  │  │  │  │  │  │
  │Apps      Applicationキー │  │  │  │  │  │  │  │
  │Insert    Insertキー      │  │  │  │  │  │  │  │
  │Delete    Deleteキー      │  │  │  │  │  │  │  │
  │Help      どのキー?       │  │  │  │  │  │  │  │
  │F1〜F24   F1〜F24キー     │  │  │  │  │  │  │  │
  │LBtnDown  左ボタン押し    │  │  │  │  │  │  │  │
  │LBtnUp    左ボタン離し    │  │  │  │  │  │  │  │
  │LBtnMove  左ボタンドラッグ│  │  │  │  │  │  │  │
  │RBtnDown  右ボタン押し    │  │  │  │  │  │  │  │
  │RBtnUp    右ボタン離し    │  │  │  │  │  │  │  │
  │RBtnMove  右ボタンドラッグ│  │  │  │  │  │  │  │
  │MBtnDown  中ボタン押し    │  │  │  │  │  │  │  │
  │MBtnUp    中ボタン離し    │  │  │  │  │  │  │  │
  │MBtnMove  中ボタンドラッグ│  │  │  │  │  │  │  │
  │XBtn1Down                 │  │  │  │  │  │  │  │
  │XBtn1Up                   │  │  │  │  │  │  │  │
  │XBtn1Move                 │  │  │  │  │  │  │  │
  │XBtn2Down                 │  │  │  │  │  │  │  │
  │XBtn2Up                   │  │  │  │  │  │  │  │
  │XBtn2Move                 │  │  │  │  │  │  │  │
  │MouseMove                 │  │  │  │  │  │  │  │
  └─────────────┴─┴─┴─┴─┴─┴─┴─┘

例えば、#\RETと#\C-mは内部的には同じ文字と見なされます。このような文字は以下
のとおりです。

  (eq #\TAB #\C-i) => t
  (eq #\LFD #\C-j) => t
  (eq #\RET #\C-m) => t
  (eq #\ESC #\C-[) => t
  (eq #\DEL #\C-?) => t
  (eq #\NUL #\C-@) => t


■コマンドによりヒストリを変更するには？
[       type]: Tips
[    section]: その他
[description]: 
コマンド別にミニバッファのヒストリを管理する方法です。

  ;;; ヒストリのリスト
  (setq foo-history '("qux" "quux" "quuux"))
  
  ;;; 管理したいコマンド
  (defun foo ()
    (interactive)
    (list
     (let ((*minibuffer-default-history* foo-history)) ; ヒストリを設定する
       (prog1
         (completing-read
          "foo: "               ; プロンプト文字列
          '("foo" "bar" "baz")  ; 補完候補
          :must-match nil       ; 必ず補完候補にマッチしなきゃ駄目？
          :case-fold t)         ; 大文字小文字を区別する？
         ; 変更されたかもしれないから戻しておく
         (setq foo-history *minibuffer-default-history*)))))


■チャンクの概要
[       type]: Tips
[    seealso]: si:make-chunk
[   referred]: si:unpack-string
[    section]: チャンク
[description]: 
xyzzyの外部と入出力するためのデータを格納するオブジェクトです。
チャンク自身は以下の要素から構成されます。

        ┌──────── 16byte ───────┐
        ┏━━━━┳━━━━┳━━━━┳━━━━┓
        ┃データ長┃データ型┃格納先  ┃−      ┃
        ┗━━━━┻━━━━┻━━━━┻━━━━┛
  データ長 : チャンクが管理するデータの長さです。
             make-chunkで指定します。
  データ型 : チャンクが管理するデータの型です。
  格納先   : チャンク自体には管理するデータを内包しません。
             格納先のアドレスだけを管理します。

以下は管理イメージです。

  ;;; 使用例
  (setq chunk (si:make-chunk 'string 8)) => #<chunk 0x00081010>
  (si:chunk-data chunk)                  => 0x00A73DC8
  (si:pack-string chunk 0 "HELLO")       => "HELLO"

      ┌アドレス┐  ┌データ─────────────┐
      ┏━━━━━┳━━━━━┯━━━━━┯━━━━━┓
      ┃0x00081010┃0x00000008│string    │0x00A73DC8┃
      ┠─────╂─────┴─────┴─────┨
      ┃0x00081018┃...                               ┃
      ┠─────╂─────────────────┨
      ┃↓        ┃                                  ┃
      ┠─────╂─┬─┬─┬─┬─┬─┬─┬─┬─┨
      ┃0x00A73DC8┃H │E │L │L │O │\0│  │  │  ┃
      ┠─────╂─┴─┴─┴─┴─┴─┴─┴─┴─┨
      ┃0x00A73DD0┃...                               ┃
      ┠─────╂─────────────────┨
      ┃↓        ┃                                  ┃
      ┗━━━━━┻━━━━━━━━━━━━━━━━━┛

チャンクから情報を取得する関数は以下のとおりです。

  si:address-of  : チャンク自身のアドレスを返します。
  si:chunk-size  : チャンクが管理するデータの長さを返します。
  si:chunk-type  : チャンクが管理するデータの型を返します。
  si:chunk-data  : チャンクが管理するデータの格納先のアドレスを返します。
  si:chunk-owner : データの格納先がチャンク自身が確保したものかどうかを返します。

チャンクを操作する関数は以下のとおりです。

  si:fill-chunk  : チャンクをfill？
  si:clear-chunk : チャンクをクリア？
  si:copy-chunk  : チャンクが管理するデータをコピーします。

チャンクの入出力をする関数は以下のとおりです。

  si:pack-int8          si:unpack-int8   :  8ビット符号付き整数用
  si:pack-uint8         si:unpack-uint8  :  8ビット符号無し整数用
  si:pack-int16         si:unpack-int16  : 16ビット符号付き整数用
  si:pack-uint16        si:unpack-uint16 : 16ビット符号無し整数用
  si:pack-int32         si:unpack-int32  : 32ビット符号付き整数用
  si:pack-uint32        si:unpack-uint32 : 32ビット符号無し整数用
  si:pack-float         si:unpack-float  : float用
  si:pack-double        si:unpack-double : double用
  si:pack-string        si:unpack-string : 文字列用


■バッファの内部構造
[       type]: Tips
[   referred]: create-new-buffer , get-buffer-create
[    section]: バッファ

■パッケージ
[       type]: Tips
[    seealso]: どの関数の頭に何がつくのでしょうか？ , export , use-package , パッケージの概要
[   referred]: *package* , defpackage , delete-package , find-package , find-symbol , import , in-package , intern , list-all-packages , make-package , unexport
[    section]: パッケージ
[description]: 
パッケージは簡単に言うと、いわゆる oblist とか obarray といったものが
いっぱいあって、リーダがシンボルを読んだときにどの obarray を使って
find-symbol や intern をするかを指定するものです。

さらに、一つのパッケージに 内部用と外部用の二つの obarray があり、通常
は内部用に intern されます。関数 export で、内部用から外部用に移動するこ
とができます。

内部用と外部用の違いは、パッケージを作るときに(作るときじゃなくてもい
いけど)他のパッケージを使用(use)すると宣言すると、ある名前を find-symbol
するときに、そのシンボルが指定されたパッケージに存在しない場合、そのパッ
ケージが使用しているパッケージの外部用にあるかを見にいくようになっています。

exportの仕組み：
  exportしても全部のパッケージから見えるわけじゃなくて、そのパッ
  ケージをuseしているパッケージから見えるようになるだけです。

  (package-use-list "user")
  => (#<package: lisp> #<package: editor>)

  (package-use-list "editor")
  => (#<package: lisp>)

  なので、editorパッケージから見えるのは、editorのシンボルとlispのexportさ
  れたシンボルだけです。
  ※「見える」というのはパッケージの修飾子なしで参照できるという意味合いです。


■パッケージの概要
[       type]: Tips
[    seealso]: パッケージ
[   referred]: どの関数の頭に何がつくのでしょうか？
[    section]: パッケージ
[description]: 
パッケージには外部から参照されるシンボル用の空間と、内部のシンボル用の空
間があります。シンボルは最初は内部に登録されます。exportすると外部に移動
させられます。
     system        lisp        editor        user
   ┌───┐   ┌───┐   ┌───┐   ┌───┐
   │s-exp │   │l-exp │   │e-exp │   │u-exp │ <- 外部
   ├───┤   ├───┤   ├───┤   ├───┤
   │s-int │   │l-int │   │e-int │   │u-int │ <- 内部
   └───┘   └───┘   └───┘   └───┘


通常は user で作業をしています。 user は lisp, editor を利用すると宣言し
ています。そのため、l-exp, e-exp, u-exp, u-int に登録されたシンボルをパ
ッケージの修飾子無しで参照できるようになっています（太枠の部分です）。
     system        lisp        editor        user
   ┌───┐   ┏━━━┓   ┏━━━┓   ┏━━━┓
   │s-exp │   ┃l-exp ┃   ┃e-exp ┃   ┃u-exp ┃ <- 外部
   ├───┤   ┗━━━┛   ┗━━━┛   ┠───┨
   │s-int │   │l-int │   │e-int │   ┃u-int ┃ <- 内部
   └───┘   └───┘   └───┘   ┗━━━┛


プログラムを書いて新しいシンボルが出てくると、u-int に登録されます。
(in-package "editor") を実行後にシンボルを書くと e-int に登録されます。
     system        lisp        editor        user
   ┌───┐   ┏━━━┓   ┏━━━┓   ┏━━━┓
   │      │   ┃      ┃   ┃      ┃   ┃      ┃ <- 外部
   │ ...  │   ┃ ...  ┃   ┃ ...  ┃   ┃ ...  ┃
   ├───┤   ┗━━━┛   ┗━━━┛   ┠───┨
   │      │   │      │   │ bar  │   ┃ foo  ┃ 
   │ ...  │   │ ...  │   │ ...  │   ┃ ...  ┃ <- 内部
   └───┘   └───┘   └───┘   ┗━━━┛
このあたりまでは分かりやすいと思うのですが、難しいのは「自分(editor)を
useしているパッケージ(user)に既にあるシンボル(foo)をexportしようとしてエ
ラーがでる」というトラブルです。


u-intとe-intのそれぞれにfooというシンボルを定義している状態を考えます。
この状態自体は問題ありませんが、この状態でeditor::fooをexportしようとす
るとエラーが発生します。
     system        lisp        editor        user
   ┌───┐   ┏━━━┓   ┏━━━┓   ┏━━━┓
   │      │   ┃      ┃   ┃  Ｘ  ┃   ┃      ┃ <- 外部
   │ ...  │   ┃ ...  ┃   ┃ .↑  ┃   ┃ ...  ┃
   ├───┤   ┗━━━┛   ┗━│━┛   ┠───┨
   │      │   │      │   │ foo  │   ┃ foo  ┃ 
   │ ...  │   │ ...  │   │ ...  │   ┃ ...  ┃ <- 内部
   └───┘   └───┘   └───┘   ┗━━━┛
user が参照可能な範囲からすると、u-intに既にあるシンボルと同じ名前のシン
ボルがe-expに入れられようとするため、「名前が衝突するためexportできませ
ん: editor::foo」と怒られます。

  (setq foo "user")
  => "user"
  (setq ed::foo "editor")
  => "editor"
  (export '(ed::foo) "ed")
  => 名前が衝突するためexportできません: editor::foo

これ以外にもこんな形でも起きます。lisp::fooとeditor::fooの間の問題のよう
ですが、実はuserがlispとeditorをuseしていることが原因です。
     system        lisp        editor        user
   ┌───┐   ┏━━━┓   ┏━━━┓   ┏━━━┓
   │      │   ┃ foo  ┃   ┃  Ｘ  ┃   ┃      ┃ <- 外部
   │ ...  │   ┃ ...  ┃   ┃ .↑  ┃   ┃ ...  ┃
   ├───┤   ┗━━━┛   ┗━│━┛   ┠───┨
   │      │   │      │   │ foo  │   ┃      ┃ 
   │ ...  │   │ ...  │   │ ...  │   ┃ ...  ┃ <- 内部
   └───┘   └───┘   └───┘   ┗━━━┛


■ファイル操作の例
[       type]: Tips
[    section]: その他
[description]: 
(defun find-modify-save-test (file)
  (interactive "f")
  (let (temp-buffer)
    (unwind-protect
        (progn
          ;; テンポラリのバッファを作って
          (setq temp-buffer (create-new-buffer "*foo*"))
          ;; カレントバッファにして
          (set-buffer temp-buffer)
          ;; ファイルを読み込む
          (insert-file-contents (merge-pathnames file *src-dir*))
          (goto-char (point-min))
          ;; ここでいろいろやる

          ;; ファイルに書く
          (write-file (merge-pathnames file *dst-dir*)))
      ;; バッファを作っていたら消す(kill-bufferはうるさいのでdelete-bufferで)
      (when temp-buffer
        (delete-buffer temp-buffer)))))


■印刷時のヘッダやフッタに関する表記
[       type]: Tips
[    section]: その他
[description]: 
印刷時のヘッダやフッタに関する表記方法です。以下は 
  Toy's xyzzy memo - Data Library -
  http://www.carabiner-systems.com/xyzzy/data.html)
からの引用です。

--- 引用 ---
印刷時のヘッダやフッタに関する表記 
header and footer 1999/12/25　Written by Tetsuya Kamei [xyzzy:03752] 

  %f   ファイル名
  %F   ファイル名 (ディレクトリ付き)
  %b   バッファ名
  %p   ページ番号
  %P   総ページ数

  %Y   西暦 (YYYY)
  %y   西暦 (YY)
  %m   月   (1〜12)
  %0m  月   (01〜12)
  %*m  月   (January〜December)
  %:m  月   (Jan〜Dec)
  %d   日   (1〜31)
  %0d  日   (01〜31)
  %*w  曜日 (Sunday〜Saturday)
  %:w  曜日 (Sun〜Sat)
  %w   曜日 (日〜土)
  %h   時   (0〜23)
  %0h  時   (00〜23)
  %H   時   (0〜11)
  %0H  時   (00〜11)
  %:H  時   (1〜12)
  %0:H 時   (01〜12)
  %*H       (AM/PM)
  %*:H      (am/pm)
  %M   分   (0〜59)
  %0M  分   (00〜59)
  %s   秒   (0〜59)
  %0s  秒   (00〜59)

  %-   横線

  %l   以前を左詰め
  %r   以降を右詰め
       指定されない部分は中央揃え

  それ以外の文字はそのまま
  --------------------------------------------------------------------------------
  (デフォルト)
    [ヘッダ] %F%l%r%:w, %0d %:m %Y %0h:%0M:%0s
    [フッタ] - %p - 


■各種ロード関係の関数の違い
[       type]: Tips
[    seealso]: load , load-library , autoload , require , *modules*
[    section]: その他
[description]: 
load         インタプリタでloadします。

load-library *.lcがあればそれをロードします。
             *.lcがなければ*.lをロードします。

autoload     関数1つ単位で、呼ばれたときloadするようにできます。
             関数が呼ばれるまではloadされません。

require      あるライブラリをロードします。ただし、既に
             ロード済みならロードしません。

*modules*    この変数を見ると今どのモジュールがロード済か分かります。
             既にロード済だともうロードしません。


■各種言語キーマップ
[       type]: Tips
[    seealso]: define-key
[    section]: キーマップ
[description]: 
プログラム言語毎（というか、モード毎）にキーマップを変更することができます。

  ;;; 言語用キーマップ一覧
  *basic-mode-map*              ; BASIC用
  *csharp-mode-map*             ; C#用
  *c-mode-map*                  ; C言語用
  *c++-mode-map*                ; C++用
  *css-mode-map*                ; CSS用
  *html-mode-map*               ; HTML用
  *idl-mode-map*                ; IDL用
  *java-mode-map*               ; java用
  *LaTeX-mode-map*              ; LaTeX用
  *lisp-mode-map*               ; lisp用
  *pascal-mode-map*             ; PASCAL用
  *perl-mode-map*               ; Perl用
  *sql-mode-map*                ; SQL用

  ;;; その他キーマップ一覧
  *box-drawings-mode-map*       ; 罫線描画モード用
  *buffer-menu-mode-map*        ; buffer-menu用
  *calc-mode-map*               ; calc用
  *calendar-mode-map*           ; calendar用
  *den8-view-mode-map*          ; 電信八号のメール表示用
  *den8-summary-mode-map*       ; 電信八号のメール一覧表示用
  *den8-draft-mode-map*         ; 電信八号の下書き用
  *diff-mode-map*               ; diff用
  *async-grep-mode-map*         ; 非同期grep用
  *lisp-interaction-mode-map*   ; *scratch*というかlisp-interaction-mode用
  *fundamental-mode-map*        ; モードが無いとき用
  *log-summary-mode-map*        ; niftyのログ一覧用
  *log-article-mode-map*        ; niftyのログ用
  *command-output-mode-map*     ; 外部コマンド実行時用
  *shell-mode-map*              ; shellモード用
  *tail-f-mode-map*             ; tail-f用
  *text-mode-map*               ; テキスト用
  *view-mode-map*               ; テキスト表示用

使用例：
  ;;; c++-modeでのキー割り当てを変える
  (define-key ed::*c++-mode-map* #\C-s 'foo)

  ;;; lisp-modeでのキー割り当てを変える
  (define-key ed::*lisp-mode-map*  #\TAB 'lisp-complete-symbol)

  ;;; Lispインタラクションモードでのキー割り当てを変える
  (define-key ed::*lisp-interaction-mode-map* #\TAB 'lisp-complete-symbol)


■起動時処理フロー
[       type]: Tips
[    seealso]: *command-line-mailto-hook* , *init-app-menus-hook* , *load-history-hook* , *post-startup-hook* , *pre-startup-hook* , *process-command-line-hook*
[    section]: システム
[description]: 
  起動時の処理フローです。 $XYZZY/xyzzy.exe を起動すると、最初は init.cc
  から $XYZZY/lisp/startup.l が呼び出されます。以降の主なフローは以下
  のとおりです。
  
  init.cc: 
    1. startupをload-library 
       startup.l: 
        1. loadupをload-library 
           loadup.l: 
            1. estartup を load-library 
             （estartup.l で、e:startup を定義） 
            2. historyをload-library 
             （history.l で、 load-history-file を定義） 
            3. app-menuをload-library 
             （app-menu.l で、 init-app-menus を定義） 
            4. siteinit を load-library 
    2. ダンプが未だならダンプ 
    3. e:startup を実行 
       estartup.l の e:startup: 
        1. フレームを初期化 
        2. *pre-startup-hook* を実行 
        3. .xyzzyを実行 
        4. ヒストリを初期化 
         （history.lのload-history-fileで、 *load-history-hook* を実行） 
        5. メニューを初期化 
         （app-menu.lのinit-app-menusで、 *init-app-menus-hook* を実行） 
        6. *scratch*を作成
        7.引数解析
          (process-command-line から、 *command-line-mailto-hook* とか
           *process-command-line-hook*を実行）
        8. *post-startup-hook*を実行 
  
まとめると、起動時にユーザが変更可能な部分は、以下の順番で実行さ
れます。

  1. $XYZZY/site-lisp/siteinit.l
  2. *pre-startup-hook*
  3. ~/.xyzzy
  4. *load-history-hook*
  5. *init-app-menus-hook*
  6. *command-line-mailto-hook* （-mailtoがある場合）
  7. *process-command-line-hook* （不明なオプションがある場合）
  8. *post-startup-hook*


■型一覧
[       type]: Misc
[    seealso]: deftype , subtypep , type-of , typep
[    section]: シンボル
[description]: 
型は綺麗に階層構造を成す訳ではないのですが、subtypepでロジックに組み込ま
れているところから、嘘にならない程度に階層化したものです。[]付きの物は二
重に出現しています。

  list                                  リスト
  ├null                                ヌル
  └cons                                コンス
  atom                                  アトム
  ├number                              数値
  │├real                              実数
  ││├rational                        有理数
  │││├ratio                         分数
  │││└integer                       整数
  │││  └bignum                      −
  ││└float                           浮動小数点数
  ││  ├short-float                   小精度浮動小数点数
  ││  ├single-float                  単精度浮動小数点数
  ││  ├double-float                  倍精度浮動小数点数
  ││  └long-float                    長精度浮動小数点数
  │└complex                           複素数
  ├symbol                              シンボル
  │├[null]                            −
  │└keyword                           キーワード
  ├character                           文字
  │├base-character                    −
  ││└standard-char                   標準文字
  │└extended-character                −
  ├stream                              ストリーム
  │├two-way-stream                    双方向ストリーム
  │├echo-stream                       −
  │├broadcast-stream                  −
  │├file-stream                       ファイルストリーム
  │├synonym-stream                    文字列ストリーム
  │├string-stream                     −
  │└concatenated-stream               −
  ├sequence                            シーケンス
  │├[list]                            −
  │└[vector]                          −
  └array                               配列
    ├simple-array                      単純配列
    │└simple-string                   単純文字列
    └vector                            ベクタ
      ├simple-vector                   単純ベクタ
      └string                          文字列
        └[simple-string]               −

使用例：
  ;;; listはsequenceで、sequenceはatomだけど、listはatomではない。
  (subtypep 'list 'sequence)    => t
  (subtypep 'sequence 'atom)    => t
  (subtypep 'list 'atom)        => nil

参考：
  typespec.l


■行番号等のON/OFF
[       type]: Tips
[    section]: その他
[description]: 
こんなに簡単にポップアップメニューから実行できます。

使用例：
  ;;; C-RBtnUpで独自のポップアップメニューにします。
  (global-set-key #\C-RBtnUp 'my-apps-popup)
  (defun my-apps-popup ()
    (interactive)
    (track-popup-menu  
     (define-popup-menu
              (:item nil "行番号(&L)"
               'toggle-line-number)
              (:item nil "スクロールバー(&B)"
               'toggle-vscroll-bar)
              (:item nil "モードライン(&M)"
               'toggle-mode-line)
              (:item nil "ファンクションキー(&F)"
               'toggle-function-bar)
              (:item nil "折り返し(&T)"
               'toggle-fold-line)
              (:item nil "リードオンリー(&R)"
               'toggle-read-only))))


■正規表現の表記
[       type]: Tips
[    seealso]: Emacs 互換ではない正規表現は結構あるのでしょうか？
[   referred]: looking-at , match-string , regexp-keyword-list , replace-buffer , scan-buffer , string-looking-at , string-match
[    section]: 検索・正規表現
[description]: 
正規表現の表記方法です。以下は 
  Toy's xyzzy memo - Data Library -
  http://www.carabiner-systems.com/xyzzy/data.html)
からの引用です。

--- 引用 ---
正規表現
regular expression 1999/12/29　Written by Tetsuya Kamei [xyzzy:03768] 

  ^         行頭にマッチ
  $         行末にマッチ
  .         改行文字を除く任意の 1 文字にマッチ
  [...]     文字クラスのどれか 1 文字にマッチ
  [^...]    文字クラスの補集合のどれか 1 文字にマッチ
  *         直前の正規表現の 0 回以上の繰り返しにマッチ (={0,})
  +         直前の正規表現の 1 回以上の繰り返しにマッチ (={1,})
  ?         直前の正規表現の 0 回か 1 回の繰り返しにマッチ (={0,1})
  \{M,N\}   直前の正規表現の M 回以上 N 回以下の繰り返しにマッチ
  \{M,\}    直前の正規表現の M 回以上の繰り返しにマッチ
  \{,N\}    直前の正規表現の N 回以下の繰り返しにマッチ
  \{N\}     直前の正規表現の N 回の繰り返しにマッチ
  \( \)     グルーピング
  \|        選択
  \1 〜 \9  後方参照
  \<        単語の開始にマッチ
  \>        単語の終了にマッチ
  \b        単語の境界にマッチ
  \B        単語の境界以外にマッチ
  \w        英数字にマッチ
  \W        英数字以外にマッチ
  \sc       シンタックスが c の 1 文字にマッチ
  \Sc       シンタックスが c 以外の 1 文字にマッチ
  \`        バッファの先頭にマッチ
  \'        バッファの最後にマッチ
  \         メタキャラクタのエスケープ

  [たぶん xyzzy 0.2.1.186 から]
  *?        直前の正規表現の 0 回以上の最短の繰り返しにマッチ
  +?        直前の正規表現の 1 回以上の最短の繰り返しにマッチ
  ??        直前の正規表現の 0 回か 1 回の最短の繰り返しにマッチ

            (let ((str "aAaaa"))
              (string-match "Aa?" str)
              (format t "[Aa? ] ... ~S: ~D-~D~%"
                      (match-string 0) (match-beginning 0) (match-end 0))
              (string-match "Aa??" str)
              (format t "[Aa??] ... ~S: ~D-~D~%"
                      (match-string 0) (match-beginning 0) (match-end 0)))
            ->[Aa? ] ... "Aa": 1-3
              [Aa??] ... "A": 1-2

  \{M,N\}?  直前の正規表現の M 回以上 N 回以下の最短の繰り返しにマッチ
  \{M,\}?   直前の正規表現の M 回以上の最短の繰り返しにマッチ
  \{,N\}?   直前の正規表現の N 回以下の最短の繰り返しにマッチ
  \(?:regexp\)
            部分正規表現のグルーピングを行うが，後方参照を行わない
            (すなわち\1，\2とかを使って参照できない，と)

  [さらに xyzzy 0.2.2.202 から]
  \_<       シンボルの開始位置にマッチ 
  \_>       シンボルの終了位置にマッチ 
  \_b       シンボルの境界にマッチ 
  \_B       シンボルの境界以外にマッチ 
  \_s       シンボル文字にマッチ 
  \_S       シンボル文字以外にマッチ 


■目的別索引
  - システム
  - バッファ
  - チャンク
  - エラー
  - パッケージ
  - 入出力
  - 検索・正規表現
  - その他
  - キーマップ
  - 関数一覧

■システム
  - 起動時処理フロー

■バッファ
  - バッファの内部構造

■チャンク
  - チャンクの概要

■エラー
  - エラー処理関係

■パッケージ
  - どの関数の頭に何がつくのでしょうか？
  - パッケージ
  - パッケージの概要

■入出力
  - xyzzyで提供されているストリームの種類

■検索・正規表現
  - Emacs 互換ではない正規表現は結構あるのでしょうか？
  - compile-regexp すると一応高速化されるんでしょうか？
  - 正規表現の表記

■その他
  - C-z でアイコン化させるには？
  - DOSのコマンドをキックして結果を文字列にするには？
  - OLEオートメーションの使用例
  - キーワードファイルの書き方
  - コマンドによりヒストリを変更するには？
  - ファイル操作の例
  - 印刷時のヘッダやフッタに関する表記
  - 各種ロード関係の関数の違い
  - 行番号等のON/OFF

■キーマップ
  - BS と C-h に別々の機能を割り当てるには？
  - キー表現使用可能文字
  - 各種言語キーマップ

■インデックス名一覧
データ型
変数と定数
制御構造
パッケージ
関数
マクロ
シンボル
数値
文字
文字列
シーケンス
リスト
ハッシュ
配列
チャンク
評価
入出力
ファイルシステム
エラー
ウィンドウ
バッファ
ミニバッファ
リージョン
モード
シンタックス
キーマップ
テキスト
検索・正規表現
ダイアログ
日付・時間
メニュー
ファイラ
ポジション
プロセス
システム
その他

■関数一覧
  - *
  - *activate-hook*
  - *after-save-buffer-hook*
  - *apropos-no-regexp*
  - *auto-encoding-alist*
  - *auto-fill-hook
  - *auto-mode-alist*
  - *auto-mode-parameter-alist*
  - *auto-update-per-device-directory*
  - *before-delete-buffer-hook*
  - *before-find-file-hook*
  - *before-save-buffer-hook*
  - *brackets-is-wildcard-character*
  - *buffer-bar-context-menu*
  - *buffer-bar-context-menu-buffer*
  - *buffer-bar-context-menu-handler*
  - *buffer-bar-selected-buffer-to-first*
  - *buffer-info-variable-list*
  - *buffer-menu-mode-hook*
  - *buffer-package*
  - *change-buffer-colors-hook*
  - *char-encoding-list*
  - *command-line-mailto-hook*
  - *command-output-mode-hook*
  - *create-buffer-hook*
  - *dabbrev-search-this-buffer-only*
  - *dabbrevs-no-undo*
  - *deactivate-hook*
  - *default-buffer-mode*
  - *default-eol-code*
  - *default-fileio-encoding*
  - *default-load-path*
  - *default-session-directory*
  - *default-write-file-directory*
  - *delete-buffer-hook*
  - *diff-mode-hook*
  - *do-completion
  - *drag-and-drop-hook*
  - *enter-minibuffer-hook*
  - *eol-cr*
  - *eol-crlf*
  - *eol-lf*
  - *error-regexp-list*
  - *etc-path*
  - *executing-macro*
  - *exit-minibuffer-hook*
  - *features*
  - *filer-chdir-hook*
  - *filer-chdir-primary-p*
  - *filer-click-toggle-marks-always*
  - *filer-directories*
  - *filer-drag-and-drop-helper
  - *filer-dual-window*
  - *filer-eat-esc*
  - *filer-echo-filename*
  - *filer-format-comma*
  - *filer-guide-text*
  - *filer-last-command-char*
  - *filer-last-file-mask*
  - *filer-left-window-p*
  - *filer-mark-file-size-unit*
  - *filer-modal*
  - *filer-path-masks*
  - *filer-primary-directory*
  - *filer-primary-file-mask*
  - *filer-retrieve-icon*
  - *filer-secondary-directory*
  - *filer-secondary-file-mask*
  - *filer-use-recycle-bin*
  - *find-file-auto-mode-function*
  - *find-file-file-not-found-hook*
  - *find-file-hooks*
  - *find-file-no-auto-encoding*
  - *find-file-read-only-hook*
  - *find-other-file-requires-file-name*
  - *full-keymap-length*
  - *gensym-counter*
  - *global-abbrev-table*
  - *global-keymap*
  - *gmark-keep-column*
  - *grep-directory-name-hook*
  - *grep-hook*
  - *grepd-hook*
  - *gresreg-directory-name-hook*
  - *history-file-name*
  - *ime-mode-hook*
  - *inhibit-quit*
  - *init-app-menus-hook*
  - *isearch-scanner-hook*
  - *kbd-translate-table*
  - *keyboard*
  - *keyword-load-path*
  - *kill-buffer-kills-scratch*
  - *kill-ring*
  - *kill-ring-max*
  - *kill-xyzzy-hook*
  - *last-command*
  - *lisp-popup-completion-list*
  - *load-history-hook*
  - *load-path*
  - *load-pathname*
  - *local-abbrev-table*
  - *make-backup-filename-hook*
  - *menu-display-length*
  - *minibuffer-buffer-name-history*
  - *minibuffer-directory-name-history*
  - *minibuffer-execute-history*
  - *minibuffer-file-name-history*
  - *minibuffer-lisp-sexp-history*
  - *minibuffer-popup-completion-list*
  - *minibuffer-save-ime-status*
  - *minibuffer-search-string-history*
  - *minibuffer-symbol-name-history*
  - *minor-mode-alist*
  - *modal-filer-save-position*
  - *modal-filer-save-size*
  - *modules*
  - *move-forward-after-undo-deletion*
  - *next-buffer-in-tab-order*
  - *next-screen-context-lines*
  - *package*
  - *page-scroll-half-window*
  - *page-scroll-keep-window-position*
  - *popup-completion-list-default*
  - *post-command-hook*
  - *post-startup-hook*
  - *pre-abbrev-expand-hook*
  - *pre-command-hook*
  - *pre-startup-hook*
  - *prefix-args*
  - *prefix-value*
  - *print-circle*
  - *print-completion-list-hook*
  - *print-length*
  - *print-option-show-dialog*
  - *print-pretty*
  - *process-command-line-hook*
  - *query-kill-buffer-hook*
  - *query-kill-xyzzy-hook*
  - *quotation-prefix*
  - *random-state*
  - *readtable*
  - *rectangle-kill-buffer*
  - *save-buffer-no-filenames-hook*
  - *save-history*
  - *save-history-hook*
  - *save-resume-info*
  - *scroll-bar-step*
  - *select-pseudo-frame-hook*
  - *selection-ring*
  - *show-cursor-line-always*
  - *show-match-hook*
  - *show-matched-parenthesis*
  - *smart-indentation*
  - *standard-input*
  - *standard-output*
  - *status-bar-format*
  - *std-control-default-char*
  - *std-control-down-char*
  - *std-control-next-char*
  - *std-control-prior-char*
  - *std-control-up-char*
  - *tail-f-mode-hook*
  - *this-command*
  - *unicode-to-half-width*
  - *wrap-search*
  - +
  - -
  - /
  - /=
  - 1+
  - 1-
  - :case-fold
  - :key
  - :no-dup
  - :regexp
  - :reverse
  - :right-bound
  - :tail
  - :test
  - :test-not
  - <
  - <=
  - =
  - >
  - >=
  - BS と C-h に別々の機能を割り当てるには？
  - C-z でアイコン化させるには？
  - DOSのコマンドをキックして結果を文字列にするには？
  - Emacs 互換ではない正規表現は結構あるのでしょうか？
  - OLEオートメーションの使用例
  - ``'(backquote)
  - abbrev-mode
  - abbreviate-display-string
  - abs
  - acons
  - acos
  - acosh
  - activate-xyzzy-window
  - add-file-history-to-menu
  - add-history
  - add-hook
  - add-menu-item
  - add-menu-separator
  - add-popup-menu
  - adjoin
  - adjustable-array-p
  - alpha-char-p
  - alphanumericp
  - and
  - append
  - append-file
  - append-rectangle
  - append-to-register
  - append-trail-slash
  - apply
  - apps-popup
  - apropos
  - archiver-dll-config-dialog
  - archiver-dll-version
  - aref
  - array-dimension
  - array-dimensions
  - array-element-type
  - array-has-fill-pointer-p
  - array-rank
  - array-row-major-index
  - array-total-size
  - arrayp
  - ash
  - asin
  - asinh
  - assoc
  - assoc-if
  - assoc-if-not
  - atan
  - atanh
  - atom
  - auto-fill-hook
  - auto-fill-mode
  - auto-save
  - autoload
  - autoload-function-p
  - back-to-indentation
  - backward-char
  - backward-delete-char-untabify
  - backward-delete-char-untabify-or-selection
  - backward-kill-paragraph
  - backward-kill-word
  - backward-line
  - backward-page
  - backward-paragraph
  - backward-sexp
  - backward-virtual-line
  - backward-word
  - base64-decode-region
  - base64-decode-region-to-file
  - beginning-of-buffer
  - beginning-of-defun
  - beginning-of-line
  - beginning-of-virtual-line
  - block
  - bobp
  - bolp
  - both-case-p
  - boundp
  - broadcast-stream-streams
  - buffer-can-redo-p
  - buffer-can-undo-p
  - buffer-eol-code
  - buffer-fileio-encoding
  - buffer-fold-width
  - buffer-lines
  - buffer-list
  - buffer-local-value
  - buffer-menu
  - buffer-mode
  - buffer-modified-count
  - buffer-modified-p
  - buffer-name
  - buffer-process
  - buffer-read-only
  - buffer-selector
  - buffer-size
  - buffer-stream-buffer
  - buffer-stream-p
  - buffer-stream-point
  - buffer-stream-set-point
  - buffer-substring
  - bufferp
  - bury-buffer
  - butlast
  - byte
  - byte-position
  - byte-size
  - caaaar
  - caaadr
  - caaar
  - caadar
  - caaddr
  - caadr
  - caar
  - cadaar
  - cadadr
  - cadar
  - caddar
  - cadddr
  - caddr
  - cadr
  - calendar
  - call-arguments-limit
  - call-interactively
  - call-last-kbd-macro
  - call-menu
  - call-process
  - capitalize-region
  - capitalize-word
  - car
  - case
  - catch
  - cd
  - cdaaar
  - cdaadr
  - cdaar
  - cdadar
  - cdaddr
  - cdadr
  - cdar
  - cddaar
  - cddadr
  - cddar
  - cdddar
  - cddddr
  - cdddr
  - cddr
  - cdr
  - ceiling
  - char
  - char-after
  - char-before
  - char-code
  - char-code-limit
  - char-columns
  - char-downcase
  - char-equal
  - char-greaterp
  - char-lessp
  - char-name
  - char-not-equal
  - char-not-greaterp
  - char-not-lessp
  - char-unicode
  - char-upcase
  - char/=
  - char<
  - char<=
  - char=
  - char>
  - char>=
  - character
  - characterp
  - check-type
  - check-valid-pathname
  - cis
  - clear-all-text-attributes
  - clear-all-text-colors
  - clear-input
  - clear-message
  - clear-minibuffer-message
  - clear-rectangle
  - clear-rectangle-selection
  - clear-reverse-region
  - clear-undo-boundary
  - close
  - close-session
  - close-session-dialog
  - clrhash
  - code-char
  - coerce
  - command-apropos
  - command-execute
  - command-keys
  - command-output-alternate-send-input
  - command-output-mode
  - command-output-send-input
  - commandp
  - compare-buffer-substrings
  - compile-file-pathname
  - compile-regexp
  - compile-regexp すると一応高速化されるんでしょうか？
  - compile-regexp-keyword-list
  - compiled-function-p
  - compiled-regexp-case-fold-p
  - compiled-regexp-source
  - complement
  - completing-read
  - complex
  - complexp
  - concat
  - concatenate
  - concatenated-stream-streams
  - cond
  - conjugate
  - connect
  - cons
  - consp
  - constantp
  - continue-popup
  - convert-encoding-from-internal
  - convert-encoding-to-internal
  - copy-alist
  - copy-file
  - copy-keymap
  - copy-list
  - copy-menu-items
  - copy-readtable
  - copy-rectangle
  - copy-rectangle-selection
  - copy-rectangle-selection-to-clipboard
  - copy-rectangle-to-register
  - copy-region-as-kill
  - copy-region-to-clipboard
  - copy-selection
  - copy-selection-to-clipboard
  - copy-seq
  - copy-string
  - copy-symbol
  - copy-syntax-table
  - copy-to-clipboard
  - copy-to-register
  - cos
  - cosh
  - count
  - count-buffers
  - count-column
  - count-if
  - count-if-not
  - count-windows
  - count-xyzzy-instance
  - create-archive
  - create-directory
  - create-file-buffer
  - create-menu
  - create-new-buffer
  - create-popup-menu
  - create-shortcut
  - create-shortcut-to-desktop
  - create-tab-bar
  - create-tool-bar
  - ctl-x-4-map
  - ctl-x-4-prefix
  - ctl-x-6-map
  - ctl-x-6-prefix
  - ctl-x-map
  - ctl-x-prefix
  - current-column
  - current-line-columns
  - current-line-number
  - current-menu
  - current-virtual-column
  - current-virtual-line-number
  - current-window-configuration
  - cwd
  - dabbrev-expand
  - dabbrev-popup
  - dde-execute
  - dde-initiate
  - dde-poke
  - dde-request
  - dde-terminate
  - decf
  - declaim
  - declare
  - decode-escape-sequence
  - decode-mime-header
  - decode-universal-time
  - default-directory
  - default-value
  - defconstant
  - define-abbrev-table
  - define-command-bar
  - define-condition
  - define-history-variable
  - define-key
  - define-menu
  - define-popup-menu
  - defmacro
  - defpackage
  - defparameter
  - defstruct
  - deftype
  - defun
  - defvar
  - defvar-local
  - delete
  - delete-all-pseudo-frames
  - delete-backward-char
  - delete-backward-char-or-selection
  - delete-blank-lines
  - delete-buffer
  - delete-char
  - delete-char-or-selection
  - delete-command-bar
  - delete-directory
  - delete-duplicates
  - delete-file
  - delete-file-in-archive
  - delete-hook
  - delete-horizontal-spaces
  - delete-if
  - delete-if-not
  - delete-indentation
  - delete-last-ime-composition
  - delete-marker
  - delete-menu
  - delete-other-windows
  - delete-package
  - delete-pseudo-frame
  - delete-rectangle
  - delete-rectangle-selection
  - delete-region
  - delete-text-attribute-point
  - delete-text-attributes
  - delete-text-attributes-if
  - delete-text-attributes-if-not
  - delete-tool-bar
  - delete-trailing-spaces
  - delete-window
  - deleted-buffer-p
  - denominator
  - deposit-field
  - describe-bindings
  - describe-function
  - describe-key
  - describe-key-briefly
  - describe-variable
  - detect-char-encoding
  - dialog
  - dialog-box
  - digit-argument
  - digit-char
  - digit-char-p
  - ding
  - directory
  - directory-name-dialog
  - directory-namestring
  - display-first-tab-char
  - display-newline-char
  - display-rest-tab-char
  - do
  - do*
  - do-all-symbols
  - do-completion
  - do-events
  - do-external-symbols
  - do-symbols
  - dolist
  - dotimes
  - double-float-p
  - down-list
  - downcase-region
  - downcase-word
  - dpb
  - drive-dialog
  - dump-xyzzy
  - echo-stream-input-stream
  - echo-stream-output-stream
  - ed::*auto-save-session-file*
  - ed::*last-search-regexp*
  - ed::*last-search-string*
  - ed::*register-alist*
  - ed::build-summary-function
  - ed::find-file-internal
  - ed::get-register
  - ed::get-selection-start-end
  - ed::map-selection
  - ed::pseudo-frame
  - ed::set-register
  - ed::toggle-mode
  - eighth
  - eject-media
  - elt
  - emacs-write-file
  - enable-post-buffer-modified-hook
  - encode-universal-time
  - end-of-buffer
  - end-of-defun
  - end-of-line
  - end-of-virtual-line
  - endp
  - enlarge-window
  - enlarge-window-horizontally
  - enum-buffers
  - eobp
  - eolp
  - eq
  - eql
  - equal
  - equalp
  - erase-buffer
  - error
  - esc-map
  - etc-path
  - eval
  - eval-buffer
  - eval-expression
  - eval-region
  - eval-when
  - evenp
  - every
  - exchange-point-and-mark
  - execute-extended-command
  - execute-region
  - execute-shell-command
  - execute-subprocess
  - exp
  - expand-abbrev
  - export
  - expt
  - extended-alphabet-char-p
  - extract-archive
  - fast-scroll-down
  - fast-scroll-up
  - fboundp
  - fceiling
  - featurep
  - ffloor
  - fifth
  - file-directory-p
  - file-executable-p
  - file-exist-p
  - file-length
  - file-name-dialog
  - file-namestring
  - file-newer-than-file-p
  - file-position
  - file-property
  - file-readable-p
  - file-visited-p
  - file-writable-p
  - file-write-time
  - filer
  - filer-calc-directory-byte-size
  - filer-calc-directory-size
  - filer-cancel
  - filer-clear-all-marks
  - filer-close
  - filer-context-menu
  - filer-count-marks
  - filer-current-file-directory-p
  - filer-current-file-dot-dot-p
  - filer-demand-reload
  - filer-dual-window-p
  - filer-forward-line
  - filer-forward-page
  - filer-get-current-file
  - filer-get-directory
  - filer-get-drive
  - filer-get-mark-files
  - filer-get-sort-order
  - filer-get-text
  - filer-goto-bof
  - filer-goto-eof
  - filer-goto-file
  - filer-isearch
  - filer-left-window
  - filer-left-window-p
  - filer-mark
  - filer-mark-all
  - filer-mark-match-files
  - filer-modal-p
  - filer-modify-column-width
  - filer-read-char
  - filer-reload
  - filer-right-window
  - filer-scroll-left
  - filer-scroll-right
  - filer-set-directory
  - filer-set-file-mask
  - filer-set-text
  - filer-sort
  - filer-subscribe-to-reload
  - filer-swap-windows
  - filer-toggle-all-marks
  - filer-toggle-mark
  - filer-viewer
  - fill
  - fill-column
  - fill-paragraph
  - fill-pointer
  - fill-region
  - fill-region-as-paragraph
  - fill-region-hook
  - filter-buffer
  - filter-region
  - find
  - find-all-symbols
  - find-buffer
  - find-file
  - find-file-in-archive
  - find-file-other-window
  - find-file-read-only
  - find-if
  - find-if-not
  - find-load-path
  - find-name-buffer
  - find-other-file
  - find-package
  - find-pseudo-frame
  - find-symbol
  - find-text-attribute
  - find-text-attribute-if
  - find-text-attribute-if-not
  - find-text-attribute-point
  - first
  - first-error
  - flet
  - float
  - floatp
  - floor
  - fmakunbound
  - focus-tool-bar
  - following-char
  - format
  - format-date
  - format-date-string
  - format-drive
  - forward-char
  - forward-line
  - forward-list
  - forward-page
  - forward-paragraph
  - forward-sexp
  - forward-virtual-line
  - forward-word
  - fourth
  - fresh-line
  - fround
  - ftruncate
  - funcall
  - function
  - functionp
  - gc
  - gcd
  - gensym
  - gentemp
  - get
  - get-alternate-file-buffer
  - get-buffer-alternate-file-name
  - get-buffer-create
  - get-buffer-file-name
  - get-buffer-window
  - get-clipboard-data
  - get-decoded-time
  - get-disk-usage
  - get-dispatch-macro-character
  - get-file-attributes
  - get-file-buffer
  - get-file-info
  - get-image-size
  - get-ime-mode
  - get-internal-real-time
  - get-local-window-flags
  - get-macro-character
  - get-menu
  - get-menu-position
  - get-next-buffer
  - get-properties
  - get-selection-type
  - get-short-path-name
  - get-special-folder-location
  - get-system-directory
  - get-universal-time
  - get-window-handle
  - get-window-line
  - get-window-start-line
  - get-windows-directory
  - getf
  - gethash
  - gethash-region
  - global-set-key
  - global-unset-key
  - go
  - goal-column
  - goto-bol
  - goto-char
  - goto-column
  - goto-eol
  - goto-last-modified-line
  - goto-line
  - goto-marker
  - goto-matched-parenthesis
  - goto-virtual-bol
  - goto-virtual-column
  - goto-virtual-eol
  - goto-virtual-line
  - graphic-char-p
  - handler-case
  - hash-table-count
  - hash-table-p
  - hash-table-rehash-size
  - hash-table-size
  - hash-table-test
  - hide-command-bar
  - hide-restricted-region
  - hide-tool-bar
  - html-highlight-mode
  - if
  - ignore-errors
  - ignored-extensions
  - imagpart
  - ime-push-composition-string
  - ime-register-word-dialog
  - import
  - in-package
  - incf
  - indent-for-comment
  - indent-region
  - indent-relative
  - indent-to
  - insert
  - insert-buffer
  - insert-buffer-substring
  - insert-file
  - insert-file-contents
  - insert-menu-item
  - insert-menu-separator
  - insert-popup-menu
  - insert-register
  - integer-length
  - integerp
  - interactive
  - interactive-p
  - intern
  - internal-time-units-per-second
  - intersection
  - isqrt
  - jump-to-register
  - just-one-space
  - kana-char-p
  - kanji-char-p
  - kept-undo-information
  - key-to-string
  - keymapp
  - keywordp
  - kill-all-buffers
  - kill-all-local-variables
  - kill-buffer
  - kill-line
  - kill-local-variable
  - kill-paragraph
  - kill-process
  - kill-rectangle
  - kill-rectangle-selection
  - kill-rectangle-selection-to-clipboard
  - kill-region
  - kill-region-to-clipboard
  - kill-selected-buffer
  - kill-selection
  - kill-selection-to-clipboard
  - kill-subprocess
  - kill-word
  - kinsoku-bol-chars
  - kinsoku-eol-chars
  - kinsoku-extend-limit
  - kinsoku-goto-column
  - kinsoku-mode
  - kinsoku-shorten-limit
  - lambda
  - lambda-list-keywords
  - lambda-parameters-limit
  - last
  - launch-application
  - lcm
  - ldb
  - ldb-test
  - ldiff
  - length
  - let
  - let*
  - lisp-complete-symbol
  - lisp-indent-hook
  - list
  - list*
  - list-all-packages
  - list-archive
  - list-function
  - list-length
  - list-server-resources
  - list-servers
  - list-text-attributes
  - list-tool-bars
  - list-xyzzy-windows
  - listen
  - listp
  - load-file
  - load-keyword-file
  - load-library
  - load-session
  - local-keymap
  - local-set-key
  - local-unset-key
  - local-variable-p
  - lock-file
  - log
  - logand
  - logandc1
  - logandc2
  - logeqv
  - logior
  - lognand
  - lognor
  - lognot
  - logorc1
  - logorc2
  - logxor
  - long-float-p
  - long-operation
  - looking-at
  - looking-back
  - looking-for
  - lookup-dictionary
  - lookup-key-command
  - lookup-keymap
  - loop
  - lower-case-p
  - machine-name
  - macro-function
  - macroexpand
  - macroexpand-1
  - macrolet
  - make-array
  - make-backup-files
  - make-broadcast-stream
  - make-buffer-stream
  - make-concatenated-stream
  - make-condition
  - make-dispatch-macro-character
  - make-echo-stream
  - make-hash-table
  - make-keymap
  - make-list
  - make-list-from-keyword-table
  - make-local-variable
  - make-marker
  - make-package
  - make-process
  - make-random-state
  - make-sequence
  - make-sparse-keymap
  - make-string-input-stream
  - make-symbol
  - make-syntax-table
  - make-temp-file-name
  - make-two-way-stream
  - make-variable-buffer-local
  - make-vector
  - makunbound
  - map
  - map-backslash-to-slash
  - map-char-encoding-region
  - map-into
  - map-slash-to-backslash
  - mapc
  - mapcan
  - mapcar
  - mapcon
  - maphash
  - mapl
  - maplist
  - mark
  - mark-dialog-box
  - mark-page
  - mark-paragraph
  - mark-sexp
  - mark-whole-buffer
  - mark-word
  - marker-buffer
  - marker-point
  - markerp
  - mask-field
  - match-beginning
  - match-data
  - match-end
  - match-string
  - max
  - mc-autoload
  - mc-load-file
  - mc-load-library
  - member
  - member-if
  - member-if-not
  - menup
  - merge
  - merge-pathnames
  - message
  - message-box
  - meta-prefix
  - min
  - minibuffer-message
  - minibuffer-prompt
  - minibuffer-window
  - minibuffer-window-p
  - minor-mode-map
  - minusp
  - mismatch
  - mod
  - mode-line-format
  - mode-name
  - mode-specific-indent-command
  - modify-text-attributes
  - modify-text-attributes-if
  - modify-text-attributes-if-not
  - mouse-menu-popup
  - msgbox
  - multiple-value-bind
  - multiple-value-call
  - multiple-value-list
  - multiple-value-prog1
  - multiple-value-setq
  - namestring
  - narrow-to-region
  - nbutlast
  - nconc
  - need-buffer-save-p
  - need-not-save
  - negative-argument
  - new-file
  - new-pseudo-frame
  - newline
  - newline-and-indent
  - next-buffer
  - next-error
  - next-line
  - next-line-add-newlines
  - next-page
  - next-pseudo-frame
  - next-virtual-line
  - next-window
  - next-word
  - next-xyzzy-window
  - nil
  - nintersection
  - ninth
  - no-or-yes-p
  - not
  - not-modified
  - notany
  - notevery
  - nreconc
  - nreverse
  - nset-difference
  - nset-exclusive-or
  - nstring-capitalize
  - nstring-downcase
  - nstring-upcase
  - nsublis
  - nsubst
  - nsubst-if
  - nsubst-if-not
  - nsubstitute
  - nsubstitute-if
  - nsubstitute-if-not
  - nth
  - nthcdr
  - null
  - number-of-function-bar-labels
  - numberp
  - numerator
  - nunion
  - oddp
  - open
  - open-filer
  - open-line
  - open-network-stream
  - open-rectangle
  - open-rectangle-selection
  - open-session-dialog
  - open-stream-p
  - operate-on-rectangle
  - operate-on-rectangle-selection
  - or
  - os-build-number
  - os-csd-version
  - os-major-version
  - os-minor-version
  - os-platform
  - other-buffer
  - other-pseudo-frame
  - other-window
  - overwrite-char
  - overwrite-mode
  - overwrite-rectangle
  - package-name
  - package-use-list
  - package-used-by-list
  - packagep
  - pairlis
  - parse-integer
  - parse-point-syntax
  - paste-from-clipboard
  - paste-rectangle-from-clipboard
  - path-equal
  - pathname-device
  - pathname-directory
  - pathname-host
  - pathname-match-p
  - pathname-name
  - pathname-type
  - peek-char
  - perform-replace
  - phase
  - pipe-command
  - plain-error
  - plusp
  - point
  - point-marker
  - point-max
  - point-min
  - point-to-register
  - pop
  - pop-to-buffer
  - popup-list
  - popup-string
  - pos-not-visible-in-window-p
  - pos-visible-in-window-p
  - position
  - position-if
  - position-if-not
  - post-buffer-modified-hook
  - post-buffer-modified-hook-enabled-p
  - pre-selection-p
  - preceding-char
  - prepend-to-register
  - previous-buffer
  - previous-line
  - previous-page
  - previous-pseudo-frame
  - previous-virtual-line
  - previous-window
  - previous-word
  - previous-xyzzy-window
  - prin1
  - princ
  - print-buffer
  - print-dialog
  - process-buffer
  - process-eol-code
  - process-exit-code
  - process-filter
  - process-incode
  - process-marker
  - process-outcode
  - process-send-n
  - process-send-string
  - process-send-y
  - process-sentinel
  - process-status
  - processp
  - proclaim
  - prog
  - prog*
  - prog1
  - prog2
  - progn
  - provide
  - psetq
  - pseudo-frame-selector
  - push
  - pushnew
  - quietly-read-abbrev-file
  - quit
  - quote
  - quote-char
  - quote-region
  - quote-string
  - quoted-printable-decode-region
  - quoted-printable-decode-region-to-file
  - random
  - rassoc
  - rassoc-if
  - rassoc-if-not
  - rational
  - rationalize
  - rationalp
  - re-search-backward
  - re-search-backward-again
  - re-search-forward
  - re-search-forward-again
  - read
  - read-as-string
  - read-buffer-name
  - read-char
  - read-char-encoding
  - read-char-no-hang
  - read-command-name
  - read-delimited-list
  - read-directory-name
  - read-exact-char-encoding
  - read-exist-buffer-name
  - read-exist-file-name
  - read-file
  - read-file-name
  - read-file-name-list
  - read-from-string
  - read-function-name
  - read-integer
  - read-into
  - read-line
  - read-line-into
  - read-preserving-whitespace
  - read-registry
  - read-sexp
  - read-string
  - read-symbol-name
  - read-variable-name
  - readtable-case
  - readtablep
  - realp
  - realpart
  - recenter
  - redo
  - reduce
  - refresh-screen
  - refresh-tool-bars
  - regexp-keyword-list
  - regexp-quote
  - regexpp
  - region-beginning
  - region-end
  - register-history-variable
  - rem
  - remhash
  - remove
  - remove-duplicates
  - remove-if
  - remove-if-not
  - remove-trail-slash
  - remprop
  - rename
  - rename-buffer
  - rename-file
  - rename-pseudo-frame
  - repeat-backward-search
  - repeat-complex-command
  - repeat-forward-search
  - replace
  - replace-buffer
  - replace-match
  - replace-string
  - require
  - resolve-shortcut
  - rest
  - restore-window-configuration-register
  - return
  - return-from
  - revappend
  - reverse
  - reverse-region
  - rewind-ime-composition
  - rotatef
  - round
  - row-major-aref
  - rplaca
  - rplacd
  - run-console
  - run-hook-with-args
  - run-hook-with-args-until-success
  - run-hook-with-args-while-success
  - run-hooks
  - safe-caaaar
  - safe-caaadr
  - safe-caaar
  - safe-caadar
  - safe-caaddr
  - safe-caadr
  - safe-caar
  - safe-cadaar
  - safe-cadadr
  - safe-cadar
  - safe-caddar
  - safe-cadddr
  - safe-caddr
  - safe-cadr
  - safe-car
  - safe-cdaaar
  - safe-cdaadr
  - safe-cdaar
  - safe-cdadar
  - safe-cdaddr
  - safe-cdadr
  - safe-cdar
  - safe-cddaar
  - safe-cddadr
  - safe-cddar
  - safe-cdddar
  - safe-cddddr
  - safe-cdddr
  - safe-cddr
  - safe-cdr
  - save-all-buffers
  - save-all-buffers-kill-xyzzy
  - save-buffer
  - save-buffers-kill-xyzzy
  - save-excursion
  - save-restriction
  - save-session
  - save-session-dialog
  - save-some-buffers
  - save-window-configuration-to-register
  - save-window-excursion
  - scan-buffer
  - schar
  - screen-height
  - screen-width
  - scroll-down-both-window
  - scroll-down-other-window
  - scroll-left
  - scroll-other-window
  - scroll-right
  - scroll-up-both-window
  - scroll-up-other-window
  - scroll-window
  - scroll-window-horizontally
  - search-backward
  - search-backward-again
  - search-forward
  - search-forward-again
  - second
  - select-buffer
  - select-pseudo-frame
  - selected-buffer
  - selected-pseudo-frame
  - selected-window
  - selection-backward-char
  - selection-backward-word
  - selection-beginning-of-buffer
  - selection-beginning-of-line
  - selection-beginning-of-virtual-line
  - selection-end-of-buffer
  - selection-end-of-line
  - selection-end-of-virtual-line
  - selection-forward-char
  - selection-forward-word
  - selection-mark
  - selection-next-page
  - selection-next-virtual-line
  - selection-paragraph
  - selection-point
  - selection-previous-page
  - selection-previous-virtual-line
  - selection-start-end
  - selection-whole-buffer
  - self-insert-command
  - sequencep
  - set
  - set-buffer
  - set-buffer-alternate-file-name
  - set-buffer-colors
  - set-buffer-eol-code
  - set-buffer-file-name
  - set-buffer-fileio-encoding
  - set-buffer-fold-type-column
  - set-buffer-fold-type-column-update
  - set-buffer-fold-type-none
  - set-buffer-fold-type-none-update
  - set-buffer-fold-type-window
  - set-buffer-fold-type-window-update
  - set-buffer-fold-width
  - set-buffer-modified-p
  - set-default
  - set-default-directory
  - set-default-fold-width
  - set-difference
  - set-dispatch-macro-character
  - set-exclusive-or
  - set-extended-key-translate-table
  - set-file-write-time
  - set-fill-column
  - set-fill-prefix
  - set-function-bar-label
  - set-goal-column
  - set-kinsoku-chars
  - set-local-window-flags
  - set-macro-character
  - set-mark
  - set-mark-command
  - set-marker
  - set-menu
  - set-meta-bit
  - set-minor-mode-map
  - set-number-of-function-bar-labels
  - set-per-device-directory
  - set-process-eol-code
  - set-process-filter
  - set-process-incode
  - set-process-outcode
  - set-process-sentinel
  - set-syntax-comment-column
  - set-syntax-end-c++-comment
  - set-syntax-end-comment
  - set-syntax-end-multi-comment
  - set-syntax-escape
  - set-syntax-from-char
  - set-syntax-junk
  - set-syntax-match
  - set-syntax-math
  - set-syntax-option
  - set-syntax-punctuation
  - set-syntax-quote
  - set-syntax-start-c++-comment
  - set-syntax-start-column-comment
  - set-syntax-start-comment
  - set-syntax-start-multi-comment
  - set-syntax-string
  - set-syntax-symbol
  - set-syntax-symbol-prefix
  - set-syntax-tag
  - set-syntax-whitespace
  - set-syntax-word
  - set-tab-columns
  - set-text-attribute
  - set-text-color
  - set-variable
  - set-window
  - set-window-configuration
  - set-window-flags
  - setf
  - setq
  - setq-default
  - setup-temp-buffer
  - seventh
  - shell-execute
  - shift-region
  - shiftf
  - short-float-p
  - show-command-bar
  - show-html-help
  - show-tool-bar
  - show-winhelp
  - shrink-window
  - shrink-window-horizontally
  - si:*activate-toplevel
  - si:*builtin-function-p
  - si:*load-library
  - si:*paste-hook*
  - si:*set-readtable-case
  - si:*stream-line-number
  - si:base64-decode
  - si:base64-encode
  - si:canonicalize-type
  - si:closure-variable
  - si:dump-image-path
  - si:getenv
  - si:make-chunk
  - si:make-string-chunk
  - si:md5
  - si:quoted-printable-decode
  - si:system-root
  - si:unpack-string
  - si:uudecode
  - si:uuencode
  - si:www-url-decode
  - si:www-url-encode
  - signal-process
  - signum
  - simple-string
  - simple-string-p
  - simple-vector-p
  - sin
  - single-float-p
  - sinh
  - sit-for
  - sixth
  - skip-chars-backward
  - skip-chars-forward
  - skip-syntax-spec-backward
  - skip-syntax-spec-forward
  - skip-token
  - skip-white-backward
  - skip-white-forward
  - sleep-for
  - smart-indentation
  - software-type
  - software-version
  - some
  - sort
  - spec-map
  - special
  - special-file-p
  - special-form-p
  - specific-command-prefix
  - split-line
  - split-string
  - split-window
  - split-window-vertically
  - sqrt
  - stable-sort
  - standard-char-p
  - start-selection
  - start-selection-as-line
  - start-selection-as-region
  - start-timer
  - start-xyzzy-server
  - step
  - stop-selection
  - stop-timer
  - stop-xyzzy-server
  - store-match-data
  - streamp
  - string
  - string-capitalize
  - string-downcase
  - string-equal
  - string-greaterp
  - string-left-trim
  - string-lessp
  - string-looking-at
  - string-match
  - string-matchp
  - string-not-equal
  - string-not-greaterp
  - string-not-lessp
  - string-rectangle
  - string-rectangle-selection
  - string-replace-match
  - string-right-trim
  - string-trim
  - string-upcase
  - string/=
  - string<
  - string<=
  - string=
  - string>
  - string>=
  - stringp
  - sub-directory-p
  - sublis
  - subseq
  - subsetp
  - subst
  - subst-if
  - subst-if-not
  - substitute
  - substitute-if
  - substitute-if-not
  - substitute-key-definition
  - substitute-string
  - substring
  - subtypep
  - svref
  - switch-pseudo-frame
  - switch-to-buffer
  - switch-to-buffer-other-window
  - symbol-function
  - symbol-name
  - symbol-package
  - symbol-plist
  - symbol-value
  - symbolp
  - syntax-c++-comment-p
  - syntax-close-p
  - syntax-close-tag-p
  - syntax-end-c++-comment-p
  - syntax-end-comment-p
  - syntax-end-multi-comment-1-p
  - syntax-end-multi-comment-2-p
  - syntax-escape-p
  - syntax-junk-p
  - syntax-math-p
  - syntax-open-p
  - syntax-open-tag-p
  - syntax-punctuation-p
  - syntax-quote-p
  - syntax-start-column-comment-p
  - syntax-start-comment-p
  - syntax-start-multi-comment-1-p
  - syntax-start-multi-comment-2-p
  - syntax-string-p
  - syntax-symbol-p
  - syntax-symbol-prefix-p
  - syntax-table
  - syntax-table-p
  - syntax-whitespace-p
  - syntax-word-p
  - t
  - tab-bar-add-item
  - tab-bar-current-item
  - tab-bar-delete-item
  - tab-bar-find-item
  - tab-bar-list-items
  - tab-bar-modify-item
  - tab-bar-select-item
  - tab-columns
  - tabify
  - tagbody
  - tail-f
  - tailp
  - tan
  - tanh
  - tenth
  - terpri
  - third
  - throw
  - title-bar-format
  - toggle-ime
  - toggle-over
  - toggle-read-only
  - toggle-session-auto-save
  - toggle-trace-on-error
  - tool-bar-exist-p
  - tool-bar-info
  - track-popup-menu
  - transpose-chars
  - transpose-lines
  - transpose-paragraphs
  - transpose-region
  - transpose-words
  - trap-errors
  - truename
  - truncate
  - two-way-stream-input-stream
  - two-way-stream-output-stream
  - type-of
  - typep
  - undefine-key
  - undefined
  - undo
  - undo-boundary
  - unexport
  - unicode-char
  - unintern
  - uninterned
  - union
  - universal-argument
  - unless
  - unread-char
  - unregister-history-variable
  - unset-marker
  - unset-minor-mode-map
  - unshift-region
  - untabify
  - unuse-package
  - unwind-protect
  - up-list
  - upcase-region
  - upcase-word
  - update-mode-line
  - upper-case-p
  - use-keymap
  - use-local-menu
  - use-package
  - use-syntax-table
  - user-config-path
  - user-homedir-pathname
  - user-name
  - uudecode-region
  - uudecode-region-to-file
  - valid-path-p
  - values
  - values-list
  - vconcat
  - vector
  - vector-pop
  - vector-push
  - vector-push-extend
  - vectorp
  - verify-visited-file-modtime
  - version-up-xyzzy
  - view-register
  - virtual-bolp
  - virtual-eolp
  - what-cursor-position
  - when
  - while
  - widen
  - wild-pathname-p
  - window-buffer
  - window-columns
  - window-coordinate
  - window-height
  - window-lines
  - window-width
  - windowp
  - with-hash-table-iterator
  - with-input-from-buffer
  - with-input-from-selected-buffer
  - with-input-from-string
  - with-interval-message
  - with-open-file
  - with-open-stream
  - with-output-to-buffer
  - with-output-to-selected-buffer
  - with-output-to-string
  - with-output-to-temp-buffer
  - with-package-iterator
  - with-selected-window
  - with-set-buffer
  - word-char-p
  - write
  - write-char
  - write-file
  - write-region
  - write-registry
  - wrong-disk
  - wrong-disk-pathname
  - xyzzy-dumped-p
  - xyzzyで提供されているストリームの種類
  - y-or-n-p
  - yank
  - yank-and-pop
  - yank-pop
  - yank-rectangle
  - yank-rectangle-as-region
  - yank-rectangle-selection
  - yank-selection
  - yank-selection-and-pop
  - yank-to-clipboard
  - yes-no-or-cancel-p
  - yes-or-no-p
  - zap-to-char
  - zerop
  - どの関数の頭に何がつくのでしょうか？
  - エラー処理関係
  - キーワードファイルの書き方
  - キー表現使用可能文字
  - コマンドによりヒストリを変更するには？
  - チャンクの概要
  - バッファの内部構造
  - パッケージ
  - パッケージの概要
  - ファイル操作の例
  - 印刷時のヘッダやフッタに関する表記
  - 各種ロード関係の関数の違い
  - 各種言語キーマップ
  - 起動時処理フロー
  - 型一覧
  - 行番号等のON/OFF
  - 正規表現の表記

